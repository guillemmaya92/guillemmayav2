[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\n\n\n\n\nJul 11, 2026\n\n\nNeocolonialism: The power of a floating exchange rate market\n\n\n\n\nJul 11, 2026\n\n\nMiddle-Income Trap\n\n\n\n\nJun 12, 2026\n\n\nChina: From rural to urban\n\n\n\n\nMay 18, 2026\n\n\nA history of global debt\n\n\n\n\nApr 11, 2026\n\n\nIntrapercentile Analysis of Economic Inequalities\n\n\n\n\nMar 14, 2026\n\n\nWho absorbs the World’s surplus?\n\n\n\n\nFeb 21, 2026\n\n\nWhere is the income/wealth distribution concentrated?\n\n\n\n\nNov 3, 2025\n\n\nInside Airbnb: Listing concentration by host\n\n\n\n\nNov 3, 2025\n\n\nGlobal temperature anomalies\n\n\n\n\nNov 3, 2025\n\n\nGlobal North: Inequalities in GDP per Capita\n\n\n\n\nOct 9, 2025\n\n\nGlobalization Eras\n\n\n\n\nSep 21, 2025\n\n\nGlobal Patterns in Wealth-Income Ratios\n\n\n\n\nAug 14, 2025\n\n\nCapital is Back: From Labor to Capital in the Modern Economy\n\n\n\n\nJul 11, 2025\n\n\nEuropean Regions NUTS2: GDP per Capita\n\n\n\n\nJun 21, 2025\n\n\nGlobal structure economy: A vision of GDP per capita and population\n\n\n\n\nMay 18, 2025\n\n\nLorenz Curves: A global and national perspectives\n\n\n\n\nApr 9, 2025\n\n\nAlquiler de vivienda en Catalunya: Distribución de precios\n\n\n\n\nMar 4, 2025\n\n\nBitcoin Wealth Distribution: Utopian vision of anarcho-capitalism\n\n\n\n\nFeb 17, 2025\n\n\nExploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\n\n\n\n\nJan 25, 2025\n\n\nDistribution of Global GDP: Visualizing Income Mountains\n\n\n\n\nDec 27, 2024\n\n\nBitcoin Logarithmic Trends: Analysis since each halving\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "posts/202603-current-account-balance/index.html",
    "href": "posts/202603-current-account-balance/index.html",
    "title": "Who absorbs the World’s surplus?",
    "section": "",
    "text": "Global trade imbalances reveal structural asymmetries in the international financial system, with the United States playing a unique role due to the dominance of the U.S. dollar. While some economies accumulate surpluses, the U.S. consistently runs large trade deficits. This persistent imbalance is not simply a weakness but a reflection of the exorbitant privilege` of the dollar as the world’s primary reserve currency.\n\n\nCode\n# Libraries\n# =====================================================================\nimport os\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport matplotlib.ticker as mticker\nfrom matplotlib import font_manager\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction (IMF)\n# =====================================================================\n#Parameter\nparameters = ['BCA', 'NGDPD']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Data Manipulation\n# =====================================================================\n# Pivot Parameter to columns and filter nulls\ndf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\ndf = df.dropna(subset=['BCA'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Country', 'Year', 'BCA', 'NGDPD', 'Analytical', 'Region', 'Cod_Currency']]\ndf = df[df['Region'].notna()]\n\n# Custom region\nconditions = [\n    df['ISO3'] == 'USA',\n    df['ISO3'] == 'GBR',\n    df['ISO3'].isin(['CHN', 'TWN', 'HKG', 'MAC']),\n    df['ISO3'] == 'JPN',\n    df['Cod_Currency'] == 'EUR',\n    df['BCA'] &gt;= 0,\n    df['BCA'] &lt; 0\n]\nresult = ['USA', 'UK', 'Greater China', 'Japan', 'Eurozone', 'Other Surplus', 'Other Deficit']\n\ndf['Region'] = np.select(conditions, result)\n\n# Groupping region and year\ndf = df.groupby([\"Region\", \"Year\"], as_index=False)[[\"BCA\", \"NGDPD\"]].sum()\n\n# Add total GDP\ndf['NGDPD'] = df.groupby('Year')['NGDPD'].transform('sum')\ndf['Ratio'] = df['BCA'] / df['NGDPD'] * 100\n\n# Pivot Regions\ndf = df.pivot_table(index=\"Year\", columns=\"Region\", values=\"Ratio\", aggfunc=\"sum\")\n\n# Reorder columns\ndf = df[[\"USA\", \"UK\", \"Eurozone\", \"Greater China\", \"Japan\", \"Other Surplus\", \"Other Deficit\"]]\n\n# Filter period\ndf = df.loc[df.index &lt;= 2029]\n\n# Values\nusa_percent = df.loc[2029, 'USA'] / (df.loc[2029, 'Other Deficit'] + df.loc[2029, 'USA'] + df.loc[2029, 'UK'])\nuk_percent = df.loc[2029, 'UK'] / (df.loc[2029, 'Other Deficit'] + df.loc[2029, 'USA'] + df.loc[2029, 'UK'])\neur_percent = df.loc[2029, 'Eurozone'] / (df.loc[2029, 'Other Surplus'] + df.loc[2029, 'Eurozone'] + df.loc[2029, 'Greater China'] + df.loc[2029, 'Japan'])\nchn_percent = df.loc[2029, 'Greater China'] / (df.loc[2029, 'Other Surplus'] + df.loc[2029, 'Eurozone'] + df.loc[2029, 'Greater China'] + df.loc[2029, 'Japan'])\njpn_percent = df.loc[2029, 'Japan'] / (df.loc[2029, 'Other Surplus'] + df.loc[2029, 'Eurozone'] + df.loc[2029, 'Greater China'] + df.loc[2029, 'Japan'])\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette\npalette = [\"#C00000\", \"#E75527\", \"#002D64\", \"#157FFF\", \"#90bee0\", \"#E8F1F8\", \"#FFE1E1\"]\n\n# Create figure\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Crear figure and plot\nax = df.plot(kind=\"bar\", stacked=True, width=0.9, color=palette, legend=False, ax=ax)\n\n# Title\nfig.add_artist(plt.Line2D([0.11, 0.11], [0.91, 1], linewidth=6, color='#203764', solid_capstyle='butt')) \nplt.text(0, 1.12, f'Who Absorbs the World’s Surplus?', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.08, f'Global imbalance in the current account', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, f'(as percent of global GDP)', fontsize=8, color='#262626', ha='left', transform=plt.gca().transAxes)\n\n# Adjust ticks and grid\nplt.ylim(-3, 3)\nax.set_xticks(range(0, 50, 5))  # Ajustar el rango con len(df)+1\nax.set_xticklabels(df.index[::len(df) // 10], fontsize=9, rotation=0)\nax.yaxis.set_major_formatter(mticker.FuncFormatter(lambda x, pos: f'{int(x):,}'.replace(\",\", \".\")))\nplt.gca().set_xlabel('')\nplt.yticks(fontsize=9, color='#282828')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\n\n# Custom legend values\nhandles = [\n    mpatches.Patch(color=palette[0], label=\"USA\", linewidth=2),\n    mpatches.Patch(color=palette[1], label=\"UK\", linewidth=2),\n    mpatches.Patch(color=palette[2], label=\"Eurozone\", linewidth=2),\n    mpatches.Patch(color=palette[3], label=\"Greater China (大中华)\", linewidth=2),\n    mpatches.Patch(color=palette[4], label=\"Japan (日本)\", linewidth=2),\n    mpatches.Patch(color=palette[5], label=\"Other Surplus\", linewidth=2),\n    mpatches.Patch(color=palette[6], label=\"Other Deficit\", linewidth=2)\n]\n\n# Legend\nlegend = plt.legend(\n    handles=handles,\n    loc='lower center', #center\n    bbox_to_anchor=(0.5, -0.12),\n    ncol=8,\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n# legend.set_bbox_to_anchor((60, 0), transform=ax.transData)\n\n# Change Font (accept chinese characters)\nprop = font_manager.FontProperties(fname='C:\\\\Windows\\\\Fonts\\\\msyh.ttc')\nfor text in legend.get_texts():\n    text.set_fontproperties(prop)\n    text.set_fontsize(8)\n\n# Add Data Source\nplt.text(0, -0.15, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.15, space + 'IMF World Economic Outlook Database, 2024', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Add text\nplt.text(50, -0.35, f\"← {usa_percent:.0%}\", fontsize=7, ha='left', va='bottom')\nplt.text(50, -0.6, f\"← {uk_percent:.0%}\", fontsize=7, ha='left', va='bottom')\nplt.text(50, 0.15, f\"← {eur_percent:.0%}\", fontsize=7, ha='left', va='bottom')\nplt.text(50, 0.55, f\"← {chn_percent:.0%}\", fontsize=7, ha='left', va='bottom')\nplt.text(50, 0.8, f\"← {jpn_percent:.0%}\", fontsize=7, ha='left', va='bottom')\n\nplt.text(50, 2, f\"World\\nsurplus\", fontsize=7, fontweight = 'bold', ha='left', va='top')\nplt.text(50, -1.8, f\"World\\ndeficit\", fontsize=7, fontweight = 'bold', ha='left', va='bottom')\n\n# Forecast\nplt.text(47, 3.1, f'Forecast', fontsize=7, fontweight='bold', color='gray', ha='center')\nax.axvspan(44.5, 49.5, color='gray', alpha=0.15, edgecolor='none')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_IMF_Global_Surplus.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show :)\nplt.show()"
  },
  {
    "objectID": "posts/202603-current-account-balance/index.html#summary",
    "href": "posts/202603-current-account-balance/index.html#summary",
    "title": "Who absorbs the World’s surplus?",
    "section": "",
    "text": "Global trade imbalances reveal structural asymmetries in the international financial system, with the United States playing a unique role due to the dominance of the U.S. dollar. While some economies accumulate surpluses, the U.S. consistently runs large trade deficits. This persistent imbalance is not simply a weakness but a reflection of the exorbitant privilege` of the dollar as the world’s primary reserve currency.\n\n\nCode\n# Libraries\n# =====================================================================\nimport os\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport matplotlib.ticker as mticker\nfrom matplotlib import font_manager\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction (IMF)\n# =====================================================================\n#Parameter\nparameters = ['BCA', 'NGDPD']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Data Manipulation\n# =====================================================================\n# Pivot Parameter to columns and filter nulls\ndf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\ndf = df.dropna(subset=['BCA'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Country', 'Year', 'BCA', 'NGDPD', 'Analytical', 'Region', 'Cod_Currency']]\ndf = df[df['Region'].notna()]\n\n# Custom region\nconditions = [\n    df['ISO3'] == 'USA',\n    df['ISO3'] == 'GBR',\n    df['ISO3'].isin(['CHN', 'TWN', 'HKG', 'MAC']),\n    df['ISO3'] == 'JPN',\n    df['Cod_Currency'] == 'EUR',\n    df['BCA'] &gt;= 0,\n    df['BCA'] &lt; 0\n]\nresult = ['USA', 'UK', 'Greater China', 'Japan', 'Eurozone', 'Other Surplus', 'Other Deficit']\n\ndf['Region'] = np.select(conditions, result)\n\n# Groupping region and year\ndf = df.groupby([\"Region\", \"Year\"], as_index=False)[[\"BCA\", \"NGDPD\"]].sum()\n\n# Add total GDP\ndf['NGDPD'] = df.groupby('Year')['NGDPD'].transform('sum')\ndf['Ratio'] = df['BCA'] / df['NGDPD'] * 100\n\n# Pivot Regions\ndf = df.pivot_table(index=\"Year\", columns=\"Region\", values=\"Ratio\", aggfunc=\"sum\")\n\n# Reorder columns\ndf = df[[\"USA\", \"UK\", \"Eurozone\", \"Greater China\", \"Japan\", \"Other Surplus\", \"Other Deficit\"]]\n\n# Filter period\ndf = df.loc[df.index &lt;= 2029]\n\n# Values\nusa_percent = df.loc[2029, 'USA'] / (df.loc[2029, 'Other Deficit'] + df.loc[2029, 'USA'] + df.loc[2029, 'UK'])\nuk_percent = df.loc[2029, 'UK'] / (df.loc[2029, 'Other Deficit'] + df.loc[2029, 'USA'] + df.loc[2029, 'UK'])\neur_percent = df.loc[2029, 'Eurozone'] / (df.loc[2029, 'Other Surplus'] + df.loc[2029, 'Eurozone'] + df.loc[2029, 'Greater China'] + df.loc[2029, 'Japan'])\nchn_percent = df.loc[2029, 'Greater China'] / (df.loc[2029, 'Other Surplus'] + df.loc[2029, 'Eurozone'] + df.loc[2029, 'Greater China'] + df.loc[2029, 'Japan'])\njpn_percent = df.loc[2029, 'Japan'] / (df.loc[2029, 'Other Surplus'] + df.loc[2029, 'Eurozone'] + df.loc[2029, 'Greater China'] + df.loc[2029, 'Japan'])\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette\npalette = [\"#C00000\", \"#E75527\", \"#002D64\", \"#157FFF\", \"#90bee0\", \"#E8F1F8\", \"#FFE1E1\"]\n\n# Create figure\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Crear figure and plot\nax = df.plot(kind=\"bar\", stacked=True, width=0.9, color=palette, legend=False, ax=ax)\n\n# Title\nfig.add_artist(plt.Line2D([0.11, 0.11], [0.91, 1], linewidth=6, color='#203764', solid_capstyle='butt')) \nplt.text(0, 1.12, f'Who Absorbs the World’s Surplus?', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.08, f'Global imbalance in the current account', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, f'(as percent of global GDP)', fontsize=8, color='#262626', ha='left', transform=plt.gca().transAxes)\n\n# Adjust ticks and grid\nplt.ylim(-3, 3)\nax.set_xticks(range(0, 50, 5))  # Ajustar el rango con len(df)+1\nax.set_xticklabels(df.index[::len(df) // 10], fontsize=9, rotation=0)\nax.yaxis.set_major_formatter(mticker.FuncFormatter(lambda x, pos: f'{int(x):,}'.replace(\",\", \".\")))\nplt.gca().set_xlabel('')\nplt.yticks(fontsize=9, color='#282828')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\n\n# Custom legend values\nhandles = [\n    mpatches.Patch(color=palette[0], label=\"USA\", linewidth=2),\n    mpatches.Patch(color=palette[1], label=\"UK\", linewidth=2),\n    mpatches.Patch(color=palette[2], label=\"Eurozone\", linewidth=2),\n    mpatches.Patch(color=palette[3], label=\"Greater China (大中华)\", linewidth=2),\n    mpatches.Patch(color=palette[4], label=\"Japan (日本)\", linewidth=2),\n    mpatches.Patch(color=palette[5], label=\"Other Surplus\", linewidth=2),\n    mpatches.Patch(color=palette[6], label=\"Other Deficit\", linewidth=2)\n]\n\n# Legend\nlegend = plt.legend(\n    handles=handles,\n    loc='lower center', #center\n    bbox_to_anchor=(0.5, -0.12),\n    ncol=8,\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n# legend.set_bbox_to_anchor((60, 0), transform=ax.transData)\n\n# Change Font (accept chinese characters)\nprop = font_manager.FontProperties(fname='C:\\\\Windows\\\\Fonts\\\\msyh.ttc')\nfor text in legend.get_texts():\n    text.set_fontproperties(prop)\n    text.set_fontsize(8)\n\n# Add Data Source\nplt.text(0, -0.15, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.15, space + 'IMF World Economic Outlook Database, 2024', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Add text\nplt.text(50, -0.35, f\"← {usa_percent:.0%}\", fontsize=7, ha='left', va='bottom')\nplt.text(50, -0.6, f\"← {uk_percent:.0%}\", fontsize=7, ha='left', va='bottom')\nplt.text(50, 0.15, f\"← {eur_percent:.0%}\", fontsize=7, ha='left', va='bottom')\nplt.text(50, 0.55, f\"← {chn_percent:.0%}\", fontsize=7, ha='left', va='bottom')\nplt.text(50, 0.8, f\"← {jpn_percent:.0%}\", fontsize=7, ha='left', va='bottom')\n\nplt.text(50, 2, f\"World\\nsurplus\", fontsize=7, fontweight = 'bold', ha='left', va='top')\nplt.text(50, -1.8, f\"World\\ndeficit\", fontsize=7, fontweight = 'bold', ha='left', va='bottom')\n\n# Forecast\nplt.text(47, 3.1, f'Forecast', fontsize=7, fontweight='bold', color='gray', ha='center')\nax.axvspan(44.5, 49.5, color='gray', alpha=0.15, edgecolor='none')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_IMF_Global_Surplus.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show :)\nplt.show()"
  },
  {
    "objectID": "posts/202601-airbnb-distribution/index.html",
    "href": "posts/202601-airbnb-distribution/index.html",
    "title": "Inside Airbnb: Listing concentration by host",
    "section": "",
    "text": "Airbnb, a platform that offers intermediary services between tenants and property owners, has become a challenge in many cities, as well as a controversial topic for defending liberalization and low regulation of the housing market.\nThis chart is a replica of the one published by Anna Gordun on towardsdatascience, with the addition of direct data extraction using BeautifulSoup and an alternative to her code using pandas and matplotlib.\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\nfrom bs4 import BeautifulSoup\nfrom io import StringIO\n\n# Data Extraction (insideairbnb)\n# ==========================================\n# Extract url pages in a dataframe\nurl = \"https://insideairbnb.com/get-the-data/\"\nresponse = requests.get(url)\nresponse.encoding = 'utf-8'\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# Get unique URLs that contain 'listings.csv'\nlistings_urls = set(a['href'] for a in soup.find_all('a', href=True) if a['href'].endswith('listings.csv'))\n\n# Convert the set back to a DataFrame\ndf_urls = pd.DataFrame(list(listings_urls), columns=[\"url\"])\n\n# Add city, province and country\ndf_urls['city'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-4].title() if len(x.strip('/').split('/')) &gt;= 4 else None)\ndf_urls['province'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-5].title() if len(x.strip('/').split('/')) &gt;= 5 else None)\ndf_urls['country'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-6].title() if len(x.strip('/').split('/')) &gt;= 6 else None)\n\n# Solve empty values \ndf_urls['country'] = df_urls.apply(lambda row: row['city'] if row['province'] == \"Data.Insideairbnb.Com\" else row['country'], axis=1)\ndf_urls['country'] = df_urls.apply(lambda row: row['province'] if row['country'] == \"Data.Insideairbnb.Com\" else row['country'], axis=1)\ndf_urls['province'] = df_urls.apply(lambda row: row['city'] if row['province'] == \"Data.Insideairbnb.Com\" else row['province'], axis=1)\n\n# Filter cities and convert to list\nurls = df_urls.to_dict(orient='records')\n\n# Create empty list\ndfs = []\n\n# Iterate over each url and city in the list of dictionaries\nfor entry in urls:\n    url = entry['url']\n    city = entry['city']\n    province = entry['province']\n    country = entry['country']\n    response = requests.get(url)\n    df = pd.read_csv(StringIO(response.text), encoding='utf-8')\n    df['city'] = city\n    df['province'] = province\n    df['country'] = country\n    dfs.append(df)\n\n# Concatenate dataframes\ndf = pd.concat(dfs, axis=0, ignore_index=True)\n\n# Data Manipulation\n# ==========================================\n# Group and category data\nhost_count = df.groupby(['host_id']).size().reset_index(name='count')\nbins = [0, 1, 2, 5, 10, 100, float('inf')]\nlabels = ['1', '2', '+2', '+5', '+10', '+100']\nhost_count['host_category'] = pd.cut(host_count['count'], bins=bins, labels=labels, right=True)\n\n# Join and select columns\ndf = pd.merge(df, host_count, on='host_id', how='left')\ndf = df[['country', 'id', 'host_id', 'host_name', 'host_category', 'count', 'license']]\n\n# Check if have license\ndf['license_category'] = df['license'].apply(lambda x: 0 if pd.isna(x) or x == 'Exempt' else 1)\n\n# Grouping by host category\ndf = df.groupby(['country', 'host_category']).agg(\n    {'id': 'count', 'license_category': 'sum'}).reset_index()\n\n# Rename columns\ndf = df.rename(columns={'id': 'property', 'license_category': 'license'})\n\n# Calculate percents\ndf['side'] = np.where(df['host_category'].isin(['1', '2']), 'left', 'right')\ndf['property_percent'] = df['property'] / df.groupby('country')['property'].transform('sum') * 100\ndf['property_percent'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"host_category\", values=\"property_percent\").fillna(0)\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['1'] + df_pivot['2']\ndf_pivot['total_right'] = df_pivot['+2'] + df_pivot['+5'] + df_pivot['+10'] + df_pivot['+100']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"2\", \"1\", \"+2\", \"+5\", \"+10\", \"+100\"]\ndfplot = df_pivot[order]\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#537c78\", \"#7ba591\", \"#cc222b\", \"#f15b4c\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 7), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Who is your Airbnb host?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07, f'% of airbnb listings in European countries managed by singles/multiproperty hosts', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=7)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=8, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Individual', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#537c78\")\nplt.text(0.75, 1.02, 'Professional', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#faa41b\")\n\n# Add strict regulation zone\nynum = 14\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.3, 'Countries with strict Airbnb Regulations', fontsize=6, fontweight='bold', color=\"gray\")\n\n# Add values for individual bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey')\n\n# Add values for professional bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey')\n\n# Legend configuration\nplt.plot([], [], label=\"Number of properties per host: \", color='white')\nplt.legend(\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.1),\n    ncol=7,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.2\n)\n\n# Add Data Source\nplt.text(0, -0.12, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.12, space + 'Inside Airbnb', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n    \n# Plot it! :)\nplt.show()\n\n\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\nfrom io import StringIO\n\n# Data Extraction (insideairbnb)\n# ==========================================\n# Extract url pages in a dataframe\nurl = \"https://insideairbnb.com/get-the-data/\"\nresponse = requests.get(url)\nresponse.encoding = 'utf-8'\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# Get unique URLs that contain 'listings.csv'\nlistings_urls = set(a['href'] for a in soup.find_all('a', href=True) if a['href'].endswith('listings.csv'))\n\n# Convert the set back to a DataFrame\ndf_urls = pd.DataFrame(list(listings_urls), columns=[\"url\"])\n\n# Add city, province and country\ndf_urls['city'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-4].title() if len(x.strip('/').split('/')) &gt;= 4 else None)\ndf_urls['province'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-5].title() if len(x.strip('/').split('/')) &gt;= 5 else None)\ndf_urls['country'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-6].title() if len(x.strip('/').split('/')) &gt;= 6 else None)\n\n# Solve empty values \ndf_urls['country'] = df_urls.apply(lambda row: row['city'] if row['province'] == \"Data.Insideairbnb.Com\" else row['country'], axis=1)\ndf_urls['country'] = df_urls.apply(lambda row: row['province'] if row['country'] == \"Data.Insideairbnb.Com\" else row['country'], axis=1)\ndf_urls['province'] = df_urls.apply(lambda row: row['city'] if row['province'] == \"Data.Insideairbnb.Com\" else row['province'], axis=1)\n\n# Filter cities and convert to list\ncities = {\"Girona\", \"Barcelona\", \"Amsterdam\", \"Prague\", \"Mallorca\", \"Lisbon\", \"Malaga\", \"Athens\", \"Viena\", \"Crete\", \"Florence\", \"London\", \"Edinburgh\", \"Rome\", \"Paris\", \"Copenhagen\", \"Andalucia\"}\ndf_urls = df_urls[df_urls['city'].isin(cities)]\nurls = df_urls.to_dict(orient='records')\n\n# Create empty list\ndfs = []\n\n# Iterate over each url and city in the list of dictionaries\nfor entry in urls:\n    url = entry['url']\n    city = entry['city']\n    province = entry['province']\n    country = entry['country']\n    response = requests.get(url)\n    df = pd.read_csv(StringIO(response.text), encoding='utf-8')\n    df['city'] = city\n    df['province'] = province\n    df['country'] = country\n    dfs.append(df)\n\n# Concatenate dataframes\ndf = pd.concat(dfs, axis=0, ignore_index=True)\n\n# Data Manipulation\n# ==========================================\n# Group and category data\nhost_count = df.groupby(['host_id']).size().reset_index(name='count')\nbins = [0, 1, 2, 5, 10, 100, float('inf')]\nlabels = ['1', '2', '+2', '+5', '+10', '+100']\nhost_count['host_category'] = pd.cut(host_count['count'], bins=bins, labels=labels, right=True)\n\n# Join and select columns\ndf = pd.merge(df, host_count, on='host_id', how='left')\ndf = df[['city', 'id', 'host_id', 'host_name', 'host_category', 'count', 'license']]\n\n# Check if have license\ndf['license_category'] = df['license'].apply(lambda x: 0 if pd.isna(x) or x == 'Exempt' else 1)\n\n# Grouping by host category\ndf = df.groupby(['city', 'host_category']).agg(\n    {'id': 'count', 'license_category': 'sum'}).reset_index()\n\n# Rename columns\ndf = df.rename(columns={'id': 'property', 'license_category': 'license'})\n\n# Calculate percents\ndf['side'] = np.where(df['host_category'].isin(['1', '2']), 'left', 'right')\ndf['property_percent'] = df['property'] / df.groupby('city')['property'].transform('sum') * 100\ndf['property_percent'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"city\", columns=\"host_category\", values=\"property_percent\").fillna(0)\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['1'] + df_pivot['2']\ndf_pivot['total_right'] = df_pivot['+2'] + df_pivot['+5'] + df_pivot['+10'] + df_pivot['+100']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"2\", \"1\", \"+2\", \"+5\", \"+10\", \"+100\"]\ndfplot = df_pivot[order]\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#537c78\", \"#7ba591\", \"#cc222b\", \"#f15b4c\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Who is your Airbnb host?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07, f'% of airbnb listings in European cities owned by singles/multiproperty hosts', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Individual', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#537c78\")\nplt.text(0.75, 1.02, 'Professional', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#faa41b\")\n\n# Add strict regulation zone\nynum = 6\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.4, 'Cities with strict Airbnb Regulations', fontsize=7, fontweight='bold', color=\"gray\")\n\n# Add values for individual bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey')\n\n# Add values for professional bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey')\n\n# Legend configuration\nplt.plot([], [], label=\"Number of properties per host: \", color='white')\nplt.legend(\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=7,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.2\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'Inside Airbnb', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n# Plot it! :)\nplt.show()"
  },
  {
    "objectID": "posts/202601-airbnb-distribution/index.html#summary",
    "href": "posts/202601-airbnb-distribution/index.html#summary",
    "title": "Inside Airbnb: Listing concentration by host",
    "section": "",
    "text": "Airbnb, a platform that offers intermediary services between tenants and property owners, has become a challenge in many cities, as well as a controversial topic for defending liberalization and low regulation of the housing market.\nThis chart is a replica of the one published by Anna Gordun on towardsdatascience, with the addition of direct data extraction using BeautifulSoup and an alternative to her code using pandas and matplotlib.\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\nfrom bs4 import BeautifulSoup\nfrom io import StringIO\n\n# Data Extraction (insideairbnb)\n# ==========================================\n# Extract url pages in a dataframe\nurl = \"https://insideairbnb.com/get-the-data/\"\nresponse = requests.get(url)\nresponse.encoding = 'utf-8'\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# Get unique URLs that contain 'listings.csv'\nlistings_urls = set(a['href'] for a in soup.find_all('a', href=True) if a['href'].endswith('listings.csv'))\n\n# Convert the set back to a DataFrame\ndf_urls = pd.DataFrame(list(listings_urls), columns=[\"url\"])\n\n# Add city, province and country\ndf_urls['city'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-4].title() if len(x.strip('/').split('/')) &gt;= 4 else None)\ndf_urls['province'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-5].title() if len(x.strip('/').split('/')) &gt;= 5 else None)\ndf_urls['country'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-6].title() if len(x.strip('/').split('/')) &gt;= 6 else None)\n\n# Solve empty values \ndf_urls['country'] = df_urls.apply(lambda row: row['city'] if row['province'] == \"Data.Insideairbnb.Com\" else row['country'], axis=1)\ndf_urls['country'] = df_urls.apply(lambda row: row['province'] if row['country'] == \"Data.Insideairbnb.Com\" else row['country'], axis=1)\ndf_urls['province'] = df_urls.apply(lambda row: row['city'] if row['province'] == \"Data.Insideairbnb.Com\" else row['province'], axis=1)\n\n# Filter cities and convert to list\nurls = df_urls.to_dict(orient='records')\n\n# Create empty list\ndfs = []\n\n# Iterate over each url and city in the list of dictionaries\nfor entry in urls:\n    url = entry['url']\n    city = entry['city']\n    province = entry['province']\n    country = entry['country']\n    response = requests.get(url)\n    df = pd.read_csv(StringIO(response.text), encoding='utf-8')\n    df['city'] = city\n    df['province'] = province\n    df['country'] = country\n    dfs.append(df)\n\n# Concatenate dataframes\ndf = pd.concat(dfs, axis=0, ignore_index=True)\n\n# Data Manipulation\n# ==========================================\n# Group and category data\nhost_count = df.groupby(['host_id']).size().reset_index(name='count')\nbins = [0, 1, 2, 5, 10, 100, float('inf')]\nlabels = ['1', '2', '+2', '+5', '+10', '+100']\nhost_count['host_category'] = pd.cut(host_count['count'], bins=bins, labels=labels, right=True)\n\n# Join and select columns\ndf = pd.merge(df, host_count, on='host_id', how='left')\ndf = df[['country', 'id', 'host_id', 'host_name', 'host_category', 'count', 'license']]\n\n# Check if have license\ndf['license_category'] = df['license'].apply(lambda x: 0 if pd.isna(x) or x == 'Exempt' else 1)\n\n# Grouping by host category\ndf = df.groupby(['country', 'host_category']).agg(\n    {'id': 'count', 'license_category': 'sum'}).reset_index()\n\n# Rename columns\ndf = df.rename(columns={'id': 'property', 'license_category': 'license'})\n\n# Calculate percents\ndf['side'] = np.where(df['host_category'].isin(['1', '2']), 'left', 'right')\ndf['property_percent'] = df['property'] / df.groupby('country')['property'].transform('sum') * 100\ndf['property_percent'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"host_category\", values=\"property_percent\").fillna(0)\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['1'] + df_pivot['2']\ndf_pivot['total_right'] = df_pivot['+2'] + df_pivot['+5'] + df_pivot['+10'] + df_pivot['+100']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"2\", \"1\", \"+2\", \"+5\", \"+10\", \"+100\"]\ndfplot = df_pivot[order]\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#537c78\", \"#7ba591\", \"#cc222b\", \"#f15b4c\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 7), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Who is your Airbnb host?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07, f'% of airbnb listings in European countries managed by singles/multiproperty hosts', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=7)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=8, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Individual', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#537c78\")\nplt.text(0.75, 1.02, 'Professional', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#faa41b\")\n\n# Add strict regulation zone\nynum = 14\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.3, 'Countries with strict Airbnb Regulations', fontsize=6, fontweight='bold', color=\"gray\")\n\n# Add values for individual bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey')\n\n# Add values for professional bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey')\n\n# Legend configuration\nplt.plot([], [], label=\"Number of properties per host: \", color='white')\nplt.legend(\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.1),\n    ncol=7,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.2\n)\n\n# Add Data Source\nplt.text(0, -0.12, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.12, space + 'Inside Airbnb', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n    \n# Plot it! :)\nplt.show()\n\n\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\nfrom io import StringIO\n\n# Data Extraction (insideairbnb)\n# ==========================================\n# Extract url pages in a dataframe\nurl = \"https://insideairbnb.com/get-the-data/\"\nresponse = requests.get(url)\nresponse.encoding = 'utf-8'\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# Get unique URLs that contain 'listings.csv'\nlistings_urls = set(a['href'] for a in soup.find_all('a', href=True) if a['href'].endswith('listings.csv'))\n\n# Convert the set back to a DataFrame\ndf_urls = pd.DataFrame(list(listings_urls), columns=[\"url\"])\n\n# Add city, province and country\ndf_urls['city'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-4].title() if len(x.strip('/').split('/')) &gt;= 4 else None)\ndf_urls['province'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-5].title() if len(x.strip('/').split('/')) &gt;= 5 else None)\ndf_urls['country'] = df_urls['url'].apply(lambda x: x.strip('/').split('/')[-6].title() if len(x.strip('/').split('/')) &gt;= 6 else None)\n\n# Solve empty values \ndf_urls['country'] = df_urls.apply(lambda row: row['city'] if row['province'] == \"Data.Insideairbnb.Com\" else row['country'], axis=1)\ndf_urls['country'] = df_urls.apply(lambda row: row['province'] if row['country'] == \"Data.Insideairbnb.Com\" else row['country'], axis=1)\ndf_urls['province'] = df_urls.apply(lambda row: row['city'] if row['province'] == \"Data.Insideairbnb.Com\" else row['province'], axis=1)\n\n# Filter cities and convert to list\ncities = {\"Girona\", \"Barcelona\", \"Amsterdam\", \"Prague\", \"Mallorca\", \"Lisbon\", \"Malaga\", \"Athens\", \"Viena\", \"Crete\", \"Florence\", \"London\", \"Edinburgh\", \"Rome\", \"Paris\", \"Copenhagen\", \"Andalucia\"}\ndf_urls = df_urls[df_urls['city'].isin(cities)]\nurls = df_urls.to_dict(orient='records')\n\n# Create empty list\ndfs = []\n\n# Iterate over each url and city in the list of dictionaries\nfor entry in urls:\n    url = entry['url']\n    city = entry['city']\n    province = entry['province']\n    country = entry['country']\n    response = requests.get(url)\n    df = pd.read_csv(StringIO(response.text), encoding='utf-8')\n    df['city'] = city\n    df['province'] = province\n    df['country'] = country\n    dfs.append(df)\n\n# Concatenate dataframes\ndf = pd.concat(dfs, axis=0, ignore_index=True)\n\n# Data Manipulation\n# ==========================================\n# Group and category data\nhost_count = df.groupby(['host_id']).size().reset_index(name='count')\nbins = [0, 1, 2, 5, 10, 100, float('inf')]\nlabels = ['1', '2', '+2', '+5', '+10', '+100']\nhost_count['host_category'] = pd.cut(host_count['count'], bins=bins, labels=labels, right=True)\n\n# Join and select columns\ndf = pd.merge(df, host_count, on='host_id', how='left')\ndf = df[['city', 'id', 'host_id', 'host_name', 'host_category', 'count', 'license']]\n\n# Check if have license\ndf['license_category'] = df['license'].apply(lambda x: 0 if pd.isna(x) or x == 'Exempt' else 1)\n\n# Grouping by host category\ndf = df.groupby(['city', 'host_category']).agg(\n    {'id': 'count', 'license_category': 'sum'}).reset_index()\n\n# Rename columns\ndf = df.rename(columns={'id': 'property', 'license_category': 'license'})\n\n# Calculate percents\ndf['side'] = np.where(df['host_category'].isin(['1', '2']), 'left', 'right')\ndf['property_percent'] = df['property'] / df.groupby('city')['property'].transform('sum') * 100\ndf['property_percent'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"city\", columns=\"host_category\", values=\"property_percent\").fillna(0)\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['1'] + df_pivot['2']\ndf_pivot['total_right'] = df_pivot['+2'] + df_pivot['+5'] + df_pivot['+10'] + df_pivot['+100']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"2\", \"1\", \"+2\", \"+5\", \"+10\", \"+100\"]\ndfplot = df_pivot[order]\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#537c78\", \"#7ba591\", \"#cc222b\", \"#f15b4c\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Who is your Airbnb host?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07, f'% of airbnb listings in European cities owned by singles/multiproperty hosts', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Individual', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#537c78\")\nplt.text(0.75, 1.02, 'Professional', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#faa41b\")\n\n# Add strict regulation zone\nynum = 6\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.4, 'Cities with strict Airbnb Regulations', fontsize=7, fontweight='bold', color=\"gray\")\n\n# Add values for individual bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey')\n\n# Add values for professional bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey')\n\n# Legend configuration\nplt.plot([], [], label=\"Number of properties per host: \", color='white')\nplt.legend(\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=7,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.2\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'Inside Airbnb', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n# Plot it! :)\nplt.show()"
  },
  {
    "objectID": "posts/202511-gdpc-global-north/index.html",
    "href": "posts/202511-gdpc-global-north/index.html",
    "title": "Global North: Inequalities in GDP per Capita",
    "section": "",
    "text": "Absolute inequalities in GDP per capita between the Global North and other regions of the world highlight the significant economic divide that persists globally. These disparities emphasize the concrete differences in wealth, living standards, and access to essential resources, underscoring the structural imbalance in global development.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.KD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = ['1960', '2023']\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'year',\n    'SP.POP.TOTL': 'pop',\n    'NY.GDP.PCAP.KD': 'gdpc'\n})\n\n# Filter nulls and create total\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_wb['gdpt'] = df_wb['gdpc'] * df_wb['pop']\n\n# Data Manipulation\n# =====================================================================\n# Merge queries\ndf = df_wb.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Analytical2', 'year', 'pop', 'gdpt']]\ndf = df.rename(columns={'Analytical2': 'group'})\ndf = df[df['group'].notna()]\n\n# Summarizing Groups\ndfg = df.copy()\ndfg['group'] = np.where(dfg['group'] == 'Global North', 'Global North', 'Rest World')\ndfg = dfg.groupby(['group', 'year'])[['pop', 'gdpt']].sum().reset_index()\ndfg['gdpc'] = dfg['gdpt'] / dfg['pop']\ndfg['gdpcdif'] = dfg['gdpc'] - dfg.groupby('group')['gdpc'].shift()\n\n# Summarizing Analytical\ndf = df.groupby(['group', 'year'])[['pop', 'gdpt']].sum().reset_index()\ndf['gdpc'] = df['gdpt'] / df['pop']\n\n# Porcentual\ndf['pop%'] = df['pop'] / df.groupby('year')['pop'].transform('sum')\n\ndf = df.sort_values(by=['pop%', 'year'], ascending=[False, True])\n\n# Data Visualization\n# =====================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Filter dataframes\ndf_1960 = df[df['year'] == 1960]\ndf_2023 = df[df['year'] == 2023]\n\n# Values\nrw60 = dfg.loc[(dfg['group'] == 'Rest World') & (dfg['year'] == 1960), 'gdpc'].values[0]\ngn60 = dfg.loc[(dfg['group'] == 'Global North') & (dfg['year'] == 1960), 'gdpc'].values[0]\nrw23 = dfg.loc[(dfg['group'] == 'Rest World') & (dfg['year'] == 2023), 'gdpc'].values[0]\ngn23 = dfg.loc[(dfg['group'] == 'Global North') & (dfg['year'] == 2023), 'gdpc'].values[0]\n\n# Colors\ngroup_colors = {\n    'East Asia & Pacific': '#4D93D9',\n    'Eastern Europe & Central Asia': '#00B050',\n    'Global North': '#808080',\n    'Latin America and the Caribbean': '#C00000',\n    'Middle East & North Africa': '#F1A983',\n    'South Asia': '#FFC000',\n    'Sub-Saharan Africa': '#7030A0'\n}\n\n# Define ticks\nxticks = np.linspace(0, 50000, 5)\n\n# Create figure and suplots\nfig, axes = plt.subplots(2, 1, figsize=(12, 5))\n\n# First plot (1960)\naxes[0].scatter(df_1960['gdpc'], df_1960['year'], s=df_1960['pop%'] * 12000, alpha=0.4, c=df_1960['group'].map(group_colors), edgecolors='w')\naxes[0].set_yticks([1960])\naxes[0].set_xlim(0, 50000)\naxes[0].set_xticks(xticks)\naxes[0].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: f'{x:,.0f}'))\naxes[0].axvline(x=rw60, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {rw60}')\naxes[0].axvline(x=gn60, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {gn60}')\naxes[0].text(rw60 +2500, 1960 + 70, f'{rw60:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[0].text(gn60 +1800, 1960 + 70, f'{gn60:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[0].text((gn60-rw60)/2+rw60, 1960 + 50, f'GAP \\n{gn60-rw60:,.0f}$', color='#373737', fontsize=8, fontweight='bold', \n             va='bottom', ha='center', rotation=0)\naxes[0].text((gn60-rw60)/2+rw60, 1960 + 25, f'+{(gn60-rw60)/rw60*100:,.0f}%', color='#12330b', fontsize=8, \n             va='bottom', ha='center', rotation=0)\n\n# Second plot (2023)\naxes[1].scatter(df_2023['gdpc'], df_2023['year'], s=df_2023['pop%'] * 12000, alpha=0.4, c=df_2023['group'].map(group_colors), edgecolors='w')\naxes[1].set_xlabel('GDP per capita ($US constant 2015)', fontsize=10, fontweight='bold')\naxes[1].set_yticks([2023])\naxes[1].set_xlim(0, 50000) \naxes[1].set_xticks(xticks)\naxes[1].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: f'{x:,.0f}'))\naxes[1].axvline(x=rw23, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {rw23}')\naxes[1].axvline(x=gn23, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {gn23}')\naxes[1].text(rw23 +1800, 2023 + 70, f'{rw23:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[1].text(gn23 +1800, 2023 + 70, f'{gn23:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[1].text((gn23-rw23)/2+rw23, 2023 + 50, f'GAP \\n{gn23-rw23:,.0f}$', color='#373737', fontsize=8, fontweight='bold', \n             va='bottom', ha='center', rotation=0)\naxes[1].text((gn23-rw23)/2+rw23, 2023 + 25, f'+{(gn23-rw23)/rw23*100:,.0f}%', color='#12330b', fontsize=8, \n             va='bottom', ha='center', rotation=0)\n\n# Configuration\nyticklabels_1960 = axes[0].get_yticklabels()\nyticklabels_1960[0].set_fontweight('bold')\nyticklabels_1960[0].set_fontsize(14)\nyticklabels_1960[0].set_color('darkgrey')\naxes[0].set_yticklabels(yticklabels_1960)\n\nyticklabels_2023 = axes[1].get_yticklabels()\nyticklabels_2023[0].set_fontweight('bold')\nyticklabels_2023[0].set_fontsize(14)\nyticklabels_2023[0].set_color('darkgrey')\naxes[1].set_yticklabels(yticklabels_2023)\n\n# Grid and labels\naxes[0].text(0, 1.25, 'Global Inequalities in GDP per Capita', fontsize=13, fontweight='bold', ha='left', transform=axes[0].transAxes)\naxes[0].text(0, 1.1, 'Evolution by region from 1960 to 2023', fontsize=9, color='#262626', ha='left', transform=axes[0].transAxes)\n\n# Add custom legend\nhandles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10) \n           for color in group_colors.values()]\n\nlabels = list(group_colors.keys())\n\nlegend = axes[0].legend(handles, labels, title=\"Regions\", bbox_to_anchor=(1.05, 0.5), loc='upper left', \n                        frameon=False, fontsize='8', title_fontsize='10')\n\nplt.setp(legend.get_title(), fontweight='bold')\n\n# Add Data Source\naxes[1].text(0, -0.5, 'Data Source: World Bank.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Notes\naxes[1].text(0, -0.6, 'Notes: The size corresponds to the percentage of the total population.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Global North\naxes[1].text(0, -0.7, 'Global North: US, European Union, Canada, Australia, New Zealand, Russia, Switzerland, Iceland, Israel, Greenland, Norway, Japan', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Adjusting plot...\nplt.tight_layout()\n\nplt.savefig(\"C:/Users/guill/Downloads/FIG_WORLDBANK_Global_North.png\", dpi=300, bbox_inches='tight') \n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202511-gdpc-global-north/index.html#summary",
    "href": "posts/202511-gdpc-global-north/index.html#summary",
    "title": "Global North: Inequalities in GDP per Capita",
    "section": "",
    "text": "Absolute inequalities in GDP per capita between the Global North and other regions of the world highlight the significant economic divide that persists globally. These disparities emphasize the concrete differences in wealth, living standards, and access to essential resources, underscoring the structural imbalance in global development.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.KD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = ['1960', '2023']\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'year',\n    'SP.POP.TOTL': 'pop',\n    'NY.GDP.PCAP.KD': 'gdpc'\n})\n\n# Filter nulls and create total\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_wb['gdpt'] = df_wb['gdpc'] * df_wb['pop']\n\n# Data Manipulation\n# =====================================================================\n# Merge queries\ndf = df_wb.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Analytical2', 'year', 'pop', 'gdpt']]\ndf = df.rename(columns={'Analytical2': 'group'})\ndf = df[df['group'].notna()]\n\n# Summarizing Groups\ndfg = df.copy()\ndfg['group'] = np.where(dfg['group'] == 'Global North', 'Global North', 'Rest World')\ndfg = dfg.groupby(['group', 'year'])[['pop', 'gdpt']].sum().reset_index()\ndfg['gdpc'] = dfg['gdpt'] / dfg['pop']\ndfg['gdpcdif'] = dfg['gdpc'] - dfg.groupby('group')['gdpc'].shift()\n\n# Summarizing Analytical\ndf = df.groupby(['group', 'year'])[['pop', 'gdpt']].sum().reset_index()\ndf['gdpc'] = df['gdpt'] / df['pop']\n\n# Porcentual\ndf['pop%'] = df['pop'] / df.groupby('year')['pop'].transform('sum')\n\ndf = df.sort_values(by=['pop%', 'year'], ascending=[False, True])\n\n# Data Visualization\n# =====================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Filter dataframes\ndf_1960 = df[df['year'] == 1960]\ndf_2023 = df[df['year'] == 2023]\n\n# Values\nrw60 = dfg.loc[(dfg['group'] == 'Rest World') & (dfg['year'] == 1960), 'gdpc'].values[0]\ngn60 = dfg.loc[(dfg['group'] == 'Global North') & (dfg['year'] == 1960), 'gdpc'].values[0]\nrw23 = dfg.loc[(dfg['group'] == 'Rest World') & (dfg['year'] == 2023), 'gdpc'].values[0]\ngn23 = dfg.loc[(dfg['group'] == 'Global North') & (dfg['year'] == 2023), 'gdpc'].values[0]\n\n# Colors\ngroup_colors = {\n    'East Asia & Pacific': '#4D93D9',\n    'Eastern Europe & Central Asia': '#00B050',\n    'Global North': '#808080',\n    'Latin America and the Caribbean': '#C00000',\n    'Middle East & North Africa': '#F1A983',\n    'South Asia': '#FFC000',\n    'Sub-Saharan Africa': '#7030A0'\n}\n\n# Define ticks\nxticks = np.linspace(0, 50000, 5)\n\n# Create figure and suplots\nfig, axes = plt.subplots(2, 1, figsize=(12, 5))\n\n# First plot (1960)\naxes[0].scatter(df_1960['gdpc'], df_1960['year'], s=df_1960['pop%'] * 12000, alpha=0.4, c=df_1960['group'].map(group_colors), edgecolors='w')\naxes[0].set_yticks([1960])\naxes[0].set_xlim(0, 50000)\naxes[0].set_xticks(xticks)\naxes[0].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: f'{x:,.0f}'))\naxes[0].axvline(x=rw60, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {rw60}')\naxes[0].axvline(x=gn60, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {gn60}')\naxes[0].text(rw60 +2500, 1960 + 70, f'{rw60:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[0].text(gn60 +1800, 1960 + 70, f'{gn60:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[0].text((gn60-rw60)/2+rw60, 1960 + 50, f'GAP \\n{gn60-rw60:,.0f}$', color='#373737', fontsize=8, fontweight='bold', \n             va='bottom', ha='center', rotation=0)\naxes[0].text((gn60-rw60)/2+rw60, 1960 + 25, f'+{(gn60-rw60)/rw60*100:,.0f}%', color='#12330b', fontsize=8, \n             va='bottom', ha='center', rotation=0)\n\n# Second plot (2023)\naxes[1].scatter(df_2023['gdpc'], df_2023['year'], s=df_2023['pop%'] * 12000, alpha=0.4, c=df_2023['group'].map(group_colors), edgecolors='w')\naxes[1].set_xlabel('GDP per capita ($US constant 2015)', fontsize=10, fontweight='bold')\naxes[1].set_yticks([2023])\naxes[1].set_xlim(0, 50000) \naxes[1].set_xticks(xticks)\naxes[1].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: f'{x:,.0f}'))\naxes[1].axvline(x=rw23, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {rw23}')\naxes[1].axvline(x=gn23, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {gn23}')\naxes[1].text(rw23 +1800, 2023 + 70, f'{rw23:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[1].text(gn23 +1800, 2023 + 70, f'{gn23:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[1].text((gn23-rw23)/2+rw23, 2023 + 50, f'GAP \\n{gn23-rw23:,.0f}$', color='#373737', fontsize=8, fontweight='bold', \n             va='bottom', ha='center', rotation=0)\naxes[1].text((gn23-rw23)/2+rw23, 2023 + 25, f'+{(gn23-rw23)/rw23*100:,.0f}%', color='#12330b', fontsize=8, \n             va='bottom', ha='center', rotation=0)\n\n# Configuration\nyticklabels_1960 = axes[0].get_yticklabels()\nyticklabels_1960[0].set_fontweight('bold')\nyticklabels_1960[0].set_fontsize(14)\nyticklabels_1960[0].set_color('darkgrey')\naxes[0].set_yticklabels(yticklabels_1960)\n\nyticklabels_2023 = axes[1].get_yticklabels()\nyticklabels_2023[0].set_fontweight('bold')\nyticklabels_2023[0].set_fontsize(14)\nyticklabels_2023[0].set_color('darkgrey')\naxes[1].set_yticklabels(yticklabels_2023)\n\n# Grid and labels\naxes[0].text(0, 1.25, 'Global Inequalities in GDP per Capita', fontsize=13, fontweight='bold', ha='left', transform=axes[0].transAxes)\naxes[0].text(0, 1.1, 'Evolution by region from 1960 to 2023', fontsize=9, color='#262626', ha='left', transform=axes[0].transAxes)\n\n# Add custom legend\nhandles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10) \n           for color in group_colors.values()]\n\nlabels = list(group_colors.keys())\n\nlegend = axes[0].legend(handles, labels, title=\"Regions\", bbox_to_anchor=(1.05, 0.5), loc='upper left', \n                        frameon=False, fontsize='8', title_fontsize='10')\n\nplt.setp(legend.get_title(), fontweight='bold')\n\n# Add Data Source\naxes[1].text(0, -0.5, 'Data Source: World Bank.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Notes\naxes[1].text(0, -0.6, 'Notes: The size corresponds to the percentage of the total population.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Global North\naxes[1].text(0, -0.7, 'Global North: US, European Union, Canada, Australia, New Zealand, Russia, Switzerland, Iceland, Israel, Greenland, Norway, Japan', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Adjusting plot...\nplt.tight_layout()\n\nplt.savefig(\"C:/Users/guill/Downloads/FIG_WORLDBANK_Global_North.png\", dpi=300, bbox_inches='tight') \n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202509-wid-beta-2023/index.html",
    "href": "posts/202509-wid-beta-2023/index.html",
    "title": "Global Patterns in Wealth-Income Ratios",
    "section": "",
    "text": "A plot that shows a snapshot of the wealth-income ratio in 2023, offering insight into the current economic landscape.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Extract Data (Countries)\n# ===================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Extract Data (WID)\n# ===================================================\n# URL del archivo Parquet en GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/master/Data/WID_Values.parquet\"\ndf = pd.read_parquet(url, engine=\"pyarrow\")\ndf = df[df['year'].isin([1980, 2023])]\n\n# Transform Data\n# ===================================================\ndf['tincome'] = df['tincome2'] / df['xusd'] / 1000\ndf['twealth'] = df['twealth2'] / df['xusd'] / 1000\ndf['gdptotal'] = df['gdptotal'] / df['xusd']\ndf['tincomeVAR'] = (df['tincome'] / df.groupby('country')['tincome'].shift(1) -1) * 100\ndf['twealthVAR'] = (df['twealth'] / df.groupby('country')['twealth'].shift(1) -1) * 100\ndf['wiratioVAR'] = (df['wiratio'] - df.groupby('country')['wiratio'].shift(1))\ndf = df[df['year'] == 2023]\ndf = df[df['wiratio'].notna() & df['tincome'].notna()]\ndf = pd.merge(df, df_countries, left_on='country', right_on='ISO2', how='inner')\ndf = df[['year', 'country', 'Country_Abr', 'gdptotal', 'tincome', 'twealth', 'wiratio', 'tincomeVAR', 'twealthVAR', 'wiratioVAR']]\ndf = df[(df['tincome'] &gt;= 0) & (df['tincome'] &lt;= 120000)]\ndf = df.sort_values(by='gdptotal', ascending=True)\ndf = df.rename(\n        columns={\n            'year': 'year',\n            'Country_Abr': 'country_name',\n            'gdptotal': 'total_income',\n            'tincome': 'incomeCY',\n            'twealth': 'wealthCY', \n            'wiratio': 'betaCY',\n            'tincomeVAR': 'incomeVAR',\n            'twealthVAR': 'wealthVAR',\n            'wiratioVAR': 'betaVAR'\n        }\n    )\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Crea la figura\nfig = go.Figure()\n\n# Marker size y line width calculados\nmarker_size = np.sqrt(df[\"total_income\"] / df[\"total_income\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"total_income\"] / df[\"total_income\"].max()) * 4 + 0.5\n\n# Primero agregamos los puntos del scatter\nfig.add_trace(go.Scatter(\n    x=df[\"betaCY\"],\n    y=df[\"incomeCY\"],\n    mode='markers',\n    text=df[\"country_name\"],\n    customdata=np.vstack((df[\"incomeCY\"], df[\"wealthCY\"], df[\"incomeVAR\"], df[\"wealthVAR\"], df[\"betaCY\"], df[\"betaVAR\"])).T,\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;Income Avg ($):&lt;/b&gt; %{y:.0f}k | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[2]:.2f}%&lt;br&gt;\" + \n                  \"&lt;b&gt;Wealth Avg ($):&lt;/b&gt; %{customdata[1]:.0f}k | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[3]:.2f}%&lt;br&gt;\" +\n                  \"&lt;b&gt;Ratio:&lt;/b&gt; %{customdata[4]:.2f} | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[5]:.2f}pp&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Ahora agregamos las imágenes de las banderas\nfor i, row in df.iterrows():\n    country_iso = row[\"country\"]\n    \n    # Calcular tamaño de la imagen\n    image_size = marker_size[i] * 0.205\n\n    # Añadir la imagen de la bandera, asegurándose de que el orden es correcto\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/guillemmaya92/world_flags_round/refs/heads/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"betaCY\"],\n            y=row[\"incomeCY\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8\n        )\n    )\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=6,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=6, x1=12,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Wealth-Income Ratio&lt;/b&gt;\",\n    title_x=0.11,\n    title_y=0.93,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Global Patterns in Wealth-Income Ratios and Average Income per Capita\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.06,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; World Inequality Database (WID)\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.12,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;b&gt;Currency:&lt;/b&gt; Official exchange rate {df[\"year\"].max()} of the local currency to USD.\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.14,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;i&gt;@guillemmaya&lt;/i&gt;\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=1,\n            y=-0.14,\n            showarrow=False,\n            font=dict(size=11),\n            align=\"right\"\n        ),\n        dict(\n            text=str(df[\"year\"].max()),\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.08,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;Wealth-Income Ratio&lt;/b&gt;\",\n        range=[0, 12],\n        tickvals=[i *  4 / 2 for i in range(7)],\n        ticktext=[f\"{int(i * 4 / 2)}\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;Average Income per Capita ($US)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",   \n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;  Total Income&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Save as HTML file!\nfig.write_html(\"C:/Users/guill/Desktop/FIG_WID_CapitalisBack_Flag.html\")\nfig.write_image(\"C:/Users/guill/Desktop/FIG_WID_CapitalisBack_Flag.png\")\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202509-wid-beta-2023/index.html#summary",
    "href": "posts/202509-wid-beta-2023/index.html#summary",
    "title": "Global Patterns in Wealth-Income Ratios",
    "section": "",
    "text": "A plot that shows a snapshot of the wealth-income ratio in 2023, offering insight into the current economic landscape.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Extract Data (Countries)\n# ===================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Extract Data (WID)\n# ===================================================\n# URL del archivo Parquet en GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/master/Data/WID_Values.parquet\"\ndf = pd.read_parquet(url, engine=\"pyarrow\")\ndf = df[df['year'].isin([1980, 2023])]\n\n# Transform Data\n# ===================================================\ndf['tincome'] = df['tincome2'] / df['xusd'] / 1000\ndf['twealth'] = df['twealth2'] / df['xusd'] / 1000\ndf['gdptotal'] = df['gdptotal'] / df['xusd']\ndf['tincomeVAR'] = (df['tincome'] / df.groupby('country')['tincome'].shift(1) -1) * 100\ndf['twealthVAR'] = (df['twealth'] / df.groupby('country')['twealth'].shift(1) -1) * 100\ndf['wiratioVAR'] = (df['wiratio'] - df.groupby('country')['wiratio'].shift(1))\ndf = df[df['year'] == 2023]\ndf = df[df['wiratio'].notna() & df['tincome'].notna()]\ndf = pd.merge(df, df_countries, left_on='country', right_on='ISO2', how='inner')\ndf = df[['year', 'country', 'Country_Abr', 'gdptotal', 'tincome', 'twealth', 'wiratio', 'tincomeVAR', 'twealthVAR', 'wiratioVAR']]\ndf = df[(df['tincome'] &gt;= 0) & (df['tincome'] &lt;= 120000)]\ndf = df.sort_values(by='gdptotal', ascending=True)\ndf = df.rename(\n        columns={\n            'year': 'year',\n            'Country_Abr': 'country_name',\n            'gdptotal': 'total_income',\n            'tincome': 'incomeCY',\n            'twealth': 'wealthCY', \n            'wiratio': 'betaCY',\n            'tincomeVAR': 'incomeVAR',\n            'twealthVAR': 'wealthVAR',\n            'wiratioVAR': 'betaVAR'\n        }\n    )\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Crea la figura\nfig = go.Figure()\n\n# Marker size y line width calculados\nmarker_size = np.sqrt(df[\"total_income\"] / df[\"total_income\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"total_income\"] / df[\"total_income\"].max()) * 4 + 0.5\n\n# Primero agregamos los puntos del scatter\nfig.add_trace(go.Scatter(\n    x=df[\"betaCY\"],\n    y=df[\"incomeCY\"],\n    mode='markers',\n    text=df[\"country_name\"],\n    customdata=np.vstack((df[\"incomeCY\"], df[\"wealthCY\"], df[\"incomeVAR\"], df[\"wealthVAR\"], df[\"betaCY\"], df[\"betaVAR\"])).T,\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;Income Avg ($):&lt;/b&gt; %{y:.0f}k | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[2]:.2f}%&lt;br&gt;\" + \n                  \"&lt;b&gt;Wealth Avg ($):&lt;/b&gt; %{customdata[1]:.0f}k | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[3]:.2f}%&lt;br&gt;\" +\n                  \"&lt;b&gt;Ratio:&lt;/b&gt; %{customdata[4]:.2f} | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[5]:.2f}pp&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Ahora agregamos las imágenes de las banderas\nfor i, row in df.iterrows():\n    country_iso = row[\"country\"]\n    \n    # Calcular tamaño de la imagen\n    image_size = marker_size[i] * 0.205\n\n    # Añadir la imagen de la bandera, asegurándose de que el orden es correcto\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/guillemmaya92/world_flags_round/refs/heads/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"betaCY\"],\n            y=row[\"incomeCY\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8\n        )\n    )\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=6,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=6, x1=12,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Wealth-Income Ratio&lt;/b&gt;\",\n    title_x=0.11,\n    title_y=0.93,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Global Patterns in Wealth-Income Ratios and Average Income per Capita\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.06,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; World Inequality Database (WID)\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.12,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;b&gt;Currency:&lt;/b&gt; Official exchange rate {df[\"year\"].max()} of the local currency to USD.\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.14,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;i&gt;@guillemmaya&lt;/i&gt;\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=1,\n            y=-0.14,\n            showarrow=False,\n            font=dict(size=11),\n            align=\"right\"\n        ),\n        dict(\n            text=str(df[\"year\"].max()),\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.08,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;Wealth-Income Ratio&lt;/b&gt;\",\n        range=[0, 12],\n        tickvals=[i *  4 / 2 for i in range(7)],\n        ticktext=[f\"{int(i * 4 / 2)}\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;Average Income per Capita ($US)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",   \n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;  Total Income&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Save as HTML file!\nfig.write_html(\"C:/Users/guill/Desktop/FIG_WID_CapitalisBack_Flag.html\")\nfig.write_image(\"C:/Users/guill/Desktop/FIG_WID_CapitalisBack_Flag.png\")\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202507-gdpc-europe-nuts2/index.html",
    "href": "posts/202507-gdpc-europe-nuts2/index.html",
    "title": "European Regions NUTS2: GDP per Capita",
    "section": "",
    "text": "The chart displays regional GDP per capita adjusted for purchasing power standards (PPS) at the NUTS 2 level, highlighting economic disparities across European regions.\n\n\nCode\n# Libraries\n# ======================================\nimport eurostat\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mcolors\nimport matplotlib.patches as mpatches\n\n# EUROSTAT Data\n# ======================================\n# Get Data from Eurostat\ndataset = eurostat.get_data_df('TGS00005')\ndf = pd.DataFrame(dataset)\n\n# Select and rename columns\ndf = df[['geo\\TIME_PERIOD', '2019']]\ndf = df.rename(columns={'geo\\\\TIME_PERIOD': 'geo'})\n\n# GEOPANDAS Data\n# ======================================\n# Read GEOJSON file\ngeojson_url = \"https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_60M_2021_4326_LEVL_2.geojson\"\ngdf = gpd.read_file(geojson_url)\n\n# Merge dataframes\ngdf = gdf.merge(df, left_on='NUTS_ID', right_on='geo')\n\n# Filter french islands\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('FRY')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('ES70')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('PT20')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('PT30')]\n\n# STATIC Map\n# ======================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create figure\nfig, ax = plt.subplots(1, 1, figsize=(12, 12))\n\n# Define palette range\nranges = [7000, 16000, 22000, 27000, 32000, 38000, 80000]\ncolors = ['#d66d35', '#e5a53e', '#efcd94', '#d5dcef', '#88a0d0', '#4b6cb0']  # Colores específicos para cada rango\nlabels = [\n    '≥ 5 700 to 12 800',\n    '≥ 12 800 to 17 600',\n    '≥ 17 600 to 22 000',\n    '≥ 22 000 to 27 000',\n    '≥ 27 000 to 32 200',\n    '≥ 32 200 to 70 400'\n]\n\n# Plot Map\ngdf.plot(\n    column='2019', \n    ax=ax, \n    legend=False,\n    cmap=mcolors.ListedColormap(colors), \n    linewidth=0.15, \n    edgecolor='black', \n    norm=mcolors.BoundaryNorm(boundaries=ranges, ncolors=len(colors))\n)\n\n# Custom Legend\npatches = [mpatches.Patch(color=color, label=label) for color, label in zip(colors, labels)]\nlegend = ax.legend(\n    handles=patches, \n    loc='upper left', \n    fontsize=8, \n    title=\"GDP per capita\", \n    title_fontsize=9, \n    labelspacing=0.5, \n    borderpad=0.3\n)\nlegend.get_title().set_fontweight('bold')\nplt.subplots_adjust(right=0.8)\n\n# Configuration\nplt.text(0, 1.05, 'Regional GDP per capita', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.02, 'By NUTS 2 Region (Europe)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\nax.set_axis_off()\n\n # Add Year label\nformatted_date = 2019 \nax.text(1, 1.06, f'{formatted_date}',\n    transform=ax.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.1, 'Data Source: Eurostat (2024), GDP and main components (output, expenditure and income)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight = 'bold',\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.12, 'Notes: Gross domestic product (GDP) at current market prices by NUTS 2 region', \n    transform=plt.gca().transAxes,\n    fontsize=8, \n    color='gray')\n\n# Add author\nplt.text(1, -0.1, '@guillemmaya.com', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='#212121', \n    ha='right')\n\n# Save it!\nplt.savefig('C:/Users/guill/Downloads/FIG_EUROSTAT_Map_GDP.png', format='png', bbox_inches='tight')\n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/202507-gdpc-europe-nuts2/index.html#summary",
    "href": "posts/202507-gdpc-europe-nuts2/index.html#summary",
    "title": "European Regions NUTS2: GDP per Capita",
    "section": "",
    "text": "The chart displays regional GDP per capita adjusted for purchasing power standards (PPS) at the NUTS 2 level, highlighting economic disparities across European regions.\n\n\nCode\n# Libraries\n# ======================================\nimport eurostat\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mcolors\nimport matplotlib.patches as mpatches\n\n# EUROSTAT Data\n# ======================================\n# Get Data from Eurostat\ndataset = eurostat.get_data_df('TGS00005')\ndf = pd.DataFrame(dataset)\n\n# Select and rename columns\ndf = df[['geo\\TIME_PERIOD', '2019']]\ndf = df.rename(columns={'geo\\\\TIME_PERIOD': 'geo'})\n\n# GEOPANDAS Data\n# ======================================\n# Read GEOJSON file\ngeojson_url = \"https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_60M_2021_4326_LEVL_2.geojson\"\ngdf = gpd.read_file(geojson_url)\n\n# Merge dataframes\ngdf = gdf.merge(df, left_on='NUTS_ID', right_on='geo')\n\n# Filter french islands\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('FRY')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('ES70')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('PT20')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('PT30')]\n\n# STATIC Map\n# ======================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create figure\nfig, ax = plt.subplots(1, 1, figsize=(12, 12))\n\n# Define palette range\nranges = [7000, 16000, 22000, 27000, 32000, 38000, 80000]\ncolors = ['#d66d35', '#e5a53e', '#efcd94', '#d5dcef', '#88a0d0', '#4b6cb0']  # Colores específicos para cada rango\nlabels = [\n    '≥ 5 700 to 12 800',\n    '≥ 12 800 to 17 600',\n    '≥ 17 600 to 22 000',\n    '≥ 22 000 to 27 000',\n    '≥ 27 000 to 32 200',\n    '≥ 32 200 to 70 400'\n]\n\n# Plot Map\ngdf.plot(\n    column='2019', \n    ax=ax, \n    legend=False,\n    cmap=mcolors.ListedColormap(colors), \n    linewidth=0.15, \n    edgecolor='black', \n    norm=mcolors.BoundaryNorm(boundaries=ranges, ncolors=len(colors))\n)\n\n# Custom Legend\npatches = [mpatches.Patch(color=color, label=label) for color, label in zip(colors, labels)]\nlegend = ax.legend(\n    handles=patches, \n    loc='upper left', \n    fontsize=8, \n    title=\"GDP per capita\", \n    title_fontsize=9, \n    labelspacing=0.5, \n    borderpad=0.3\n)\nlegend.get_title().set_fontweight('bold')\nplt.subplots_adjust(right=0.8)\n\n# Configuration\nplt.text(0, 1.05, 'Regional GDP per capita', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.02, 'By NUTS 2 Region (Europe)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\nax.set_axis_off()\n\n # Add Year label\nformatted_date = 2019 \nax.text(1, 1.06, f'{formatted_date}',\n    transform=ax.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.1, 'Data Source: Eurostat (2024), GDP and main components (output, expenditure and income)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight = 'bold',\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.12, 'Notes: Gross domestic product (GDP) at current market prices by NUTS 2 region', \n    transform=plt.gca().transAxes,\n    fontsize=8, \n    color='gray')\n\n# Add author\nplt.text(1, -0.1, '@guillemmaya.com', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='#212121', \n    ha='right')\n\n# Save it!\nplt.savefig('C:/Users/guill/Downloads/FIG_EUROSTAT_Map_GDP.png', format='png', bbox_inches='tight')\n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/202505-lorenz-curves/index.html",
    "href": "posts/202505-lorenz-curves/index.html",
    "title": "Lorenz Curves: A global and national perspectives",
    "section": "",
    "text": "This is a global graphical representation of income and wealth for the years 1995 and 2021. Illustrating the dynamics of inequality by comparing Gini indices through Lorenz curves, both within (intra-country) and between (inter-country) nations.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patheffects as patheffects\n\n# Parameters\n# =====================================================================\n# Select between Income/Wealth\nselection = 'Income'\nyear = 2021\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction (Percentages)\n# ===================================================\n# URL GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/WID_Percentiles.parquet\"\n\n# Extract data from parquet\ndf = pd.read_parquet(url, engine='pyarrow')\n\n# Filter year\ndf = df[df['year'] == year]\n\n# Data Extraction (Values)\n# ===================================================\n# URL GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/WID_Values.parquet\"\n\n# Extract data from parquet\ndfv = pd.read_parquet(url, engine='pyarrow')\n\n# Filter year\ndfv = dfv[dfv['year'] == year]\n\n# Extract world values\ngincomew = dfv.loc[dfv['country'] == 'WO', 'gincome'].iloc[0]\ngwealthw = dfv.loc[dfv['country'] == 'WO', 'gwealth'].iloc[0]\n\n# Extract countries weighted average values\ndfincome = dfv[dfv['country'].isin(df_countries['ISO2']) & dfv['gincome'].notnull() & dfv['population'].notnull()]\ndfwealth = dfv[dfv['country'].isin(df_countries['ISO2']) & dfv['gwealth'].notnull() & dfv['population'].notnull()]\n\ngincomec = np.average(dfincome['gincome'], weights= dfincome['population'])\ngwealthc = np.average(dfwealth['gwealth'], weights= dfwealth['population'])\n\n# Dynamic value\nginiw = round(gwealthw, 2) if selection == 'Wealth' else round(gincomew, 2)\nginic= round(gwealthc, 2) if selection == 'Wealth' else round(gincomec, 2)\n\n# Data Manipulation\n# ===================================================\n# Calculate cummulative\ndf['percentile'] =  df['percentile'] / 100\ndf['income'] =  df['income'] / 100\ndf['wealth'] =  df['wealth'] / 100\ndf['income_cum'] =  df.groupby(['country'])['income'].cumsum() / df.groupby(['country'])['income'].transform('sum')\ndf['wealth_cum'] =  df.groupby(['country'])['wealth'].cumsum() / df.groupby(['country'])['wealth'].transform('sum')\ndf['value_cum'] = df['income_cum'] if selection == 'Income' else df['wealth_cum']\n\n# Countries\ndfc = df.merge(df_countries, how='left', left_on='country', right_on='ISO2')\ndfc = dfc[dfc['Region'].notna()]\ndfc = dfc[['country', 'percentile', 'value_cum']]\n\n# World\ndfw = df[df['country'] == \"WO\"]\ndfw = dfw[['country', 'percentile', 'value_cum']]\ndfw['country'] = 'Inter-Countries'\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\nplt.figure(figsize=(10, 10))\n\n# Basic Grey Plot Lines\nsns.lineplot(\n    data=dfc, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=0.4,\n    alpha=0.5,\n    palette=['#808080']\n).legend_.remove()\n\n# Black Shadow Plot Lines\nsns.lineplot(\n    data=dfw, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=2.25,\n    alpha=1,\n    palette=['black']\n).legend_.remove()\n\n# Color Plot Lines\nsns.lineplot(\n    data=dfw, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=1.5,\n    alpha=1,\n    palette=['#FF0000']\n).legend_.remove()\n\n# Add Inequality lines\nplt.plot([0, 1], [0, 1], color=\"gray\", linestyle=\"-\", linewidth=1)\n\n# Configuración del gráfico\nplt.text(0, 1.05, f'Global {selection} Distribution', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.02, 'A global and national perspective on Lorenz curves', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlabel('Cumulative Population (%)', fontsize=10, fontweight='bold')\nplt.ylabel(f'Cumulative {selection} (%)', fontsize=10, fontweight='bold')\nplt.xlim(0, 1)\nplt.ylim(0, 1)\n\n# Adjust grid and layout\nplt.grid(True, linestyle='-', color='grey', linewidth=0.08)\nplt.gca().set_aspect('equal', adjustable='box')\n\n# Add Data Source\nplt.text(0, -0.1, 'Data Source: World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\n\n# Variable notes\nnoteincome = 'Income: Post-tax national income is the sum of primary incomes over all sectors (private and public), minus taxes.'\nnotewealth = 'Wealth: Total value of non-financial and financial assets held by households, minus their debts.'\nnote = noteincome if selection == 'income' else notewealth\n\n# Add Notes\nplt.text(0, -0.12, note, \n    transform=plt.gca().transAxes, \n    fontsize=7,\n    fontstyle='italic',\n    color='gray')\n\n# Add Author\nplt.text(0.85, -0.1, '@guillemmaya.com', \n    transform=plt.gca().transAxes, \n    fontsize=9,\n    fontstyle='italic',\n    color='#212121')\n\n # Add Year label\nformatted_date = year\nplt.text(1, 1.06, f'{formatted_date}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Create custom lines\nintra_line = mlines.Line2D([], [], color='#808080', label=f'Gini Intra-Countries: {ginic}', linewidth=2)\ninter_line = mlines.Line2D([], [], color='#FF0000', label=f'Gini Inter-Countries: {giniw}', linewidth=2)\ninter_line.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\ninter_circle = mlines.Line2D([], [], marker='o', color='w', markerfacecolor='#FF0000', markeredgecolor='black', markersize=8, label='Inter-Countries', linewidth=0)\n\n# Add custom legend\nplt.legend(handles=[intra_line, inter_line])\n\n# Save the figure\nplt.savefig('C:/Users/guill/Desktop/FIG_WID_Global_Lorenz_Curves.png', format='png', dpi=300, bbox_inches='tight')\n\n# Show the plot!\nplt.show()"
  },
  {
    "objectID": "posts/202505-lorenz-curves/index.html#summary",
    "href": "posts/202505-lorenz-curves/index.html#summary",
    "title": "Lorenz Curves: A global and national perspectives",
    "section": "",
    "text": "This is a global graphical representation of income and wealth for the years 1995 and 2021. Illustrating the dynamics of inequality by comparing Gini indices through Lorenz curves, both within (intra-country) and between (inter-country) nations.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patheffects as patheffects\n\n# Parameters\n# =====================================================================\n# Select between Income/Wealth\nselection = 'Income'\nyear = 2021\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction (Percentages)\n# ===================================================\n# URL GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/WID_Percentiles.parquet\"\n\n# Extract data from parquet\ndf = pd.read_parquet(url, engine='pyarrow')\n\n# Filter year\ndf = df[df['year'] == year]\n\n# Data Extraction (Values)\n# ===================================================\n# URL GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/WID_Values.parquet\"\n\n# Extract data from parquet\ndfv = pd.read_parquet(url, engine='pyarrow')\n\n# Filter year\ndfv = dfv[dfv['year'] == year]\n\n# Extract world values\ngincomew = dfv.loc[dfv['country'] == 'WO', 'gincome'].iloc[0]\ngwealthw = dfv.loc[dfv['country'] == 'WO', 'gwealth'].iloc[0]\n\n# Extract countries weighted average values\ndfincome = dfv[dfv['country'].isin(df_countries['ISO2']) & dfv['gincome'].notnull() & dfv['population'].notnull()]\ndfwealth = dfv[dfv['country'].isin(df_countries['ISO2']) & dfv['gwealth'].notnull() & dfv['population'].notnull()]\n\ngincomec = np.average(dfincome['gincome'], weights= dfincome['population'])\ngwealthc = np.average(dfwealth['gwealth'], weights= dfwealth['population'])\n\n# Dynamic value\nginiw = round(gwealthw, 2) if selection == 'Wealth' else round(gincomew, 2)\nginic= round(gwealthc, 2) if selection == 'Wealth' else round(gincomec, 2)\n\n# Data Manipulation\n# ===================================================\n# Calculate cummulative\ndf['percentile'] =  df['percentile'] / 100\ndf['income'] =  df['income'] / 100\ndf['wealth'] =  df['wealth'] / 100\ndf['income_cum'] =  df.groupby(['country'])['income'].cumsum() / df.groupby(['country'])['income'].transform('sum')\ndf['wealth_cum'] =  df.groupby(['country'])['wealth'].cumsum() / df.groupby(['country'])['wealth'].transform('sum')\ndf['value_cum'] = df['income_cum'] if selection == 'Income' else df['wealth_cum']\n\n# Countries\ndfc = df.merge(df_countries, how='left', left_on='country', right_on='ISO2')\ndfc = dfc[dfc['Region'].notna()]\ndfc = dfc[['country', 'percentile', 'value_cum']]\n\n# World\ndfw = df[df['country'] == \"WO\"]\ndfw = dfw[['country', 'percentile', 'value_cum']]\ndfw['country'] = 'Inter-Countries'\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\nplt.figure(figsize=(10, 10))\n\n# Basic Grey Plot Lines\nsns.lineplot(\n    data=dfc, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=0.4,\n    alpha=0.5,\n    palette=['#808080']\n).legend_.remove()\n\n# Black Shadow Plot Lines\nsns.lineplot(\n    data=dfw, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=2.25,\n    alpha=1,\n    palette=['black']\n).legend_.remove()\n\n# Color Plot Lines\nsns.lineplot(\n    data=dfw, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=1.5,\n    alpha=1,\n    palette=['#FF0000']\n).legend_.remove()\n\n# Add Inequality lines\nplt.plot([0, 1], [0, 1], color=\"gray\", linestyle=\"-\", linewidth=1)\n\n# Configuración del gráfico\nplt.text(0, 1.05, f'Global {selection} Distribution', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.02, 'A global and national perspective on Lorenz curves', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlabel('Cumulative Population (%)', fontsize=10, fontweight='bold')\nplt.ylabel(f'Cumulative {selection} (%)', fontsize=10, fontweight='bold')\nplt.xlim(0, 1)\nplt.ylim(0, 1)\n\n# Adjust grid and layout\nplt.grid(True, linestyle='-', color='grey', linewidth=0.08)\nplt.gca().set_aspect('equal', adjustable='box')\n\n# Add Data Source\nplt.text(0, -0.1, 'Data Source: World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\n\n# Variable notes\nnoteincome = 'Income: Post-tax national income is the sum of primary incomes over all sectors (private and public), minus taxes.'\nnotewealth = 'Wealth: Total value of non-financial and financial assets held by households, minus their debts.'\nnote = noteincome if selection == 'income' else notewealth\n\n# Add Notes\nplt.text(0, -0.12, note, \n    transform=plt.gca().transAxes, \n    fontsize=7,\n    fontstyle='italic',\n    color='gray')\n\n# Add Author\nplt.text(0.85, -0.1, '@guillemmaya.com', \n    transform=plt.gca().transAxes, \n    fontsize=9,\n    fontstyle='italic',\n    color='#212121')\n\n # Add Year label\nformatted_date = year\nplt.text(1, 1.06, f'{formatted_date}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Create custom lines\nintra_line = mlines.Line2D([], [], color='#808080', label=f'Gini Intra-Countries: {ginic}', linewidth=2)\ninter_line = mlines.Line2D([], [], color='#FF0000', label=f'Gini Inter-Countries: {giniw}', linewidth=2)\ninter_line.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\ninter_circle = mlines.Line2D([], [], marker='o', color='w', markerfacecolor='#FF0000', markeredgecolor='black', markersize=8, label='Inter-Countries', linewidth=0)\n\n# Add custom legend\nplt.legend(handles=[intra_line, inter_line])\n\n# Save the figure\nplt.savefig('C:/Users/guill/Desktop/FIG_WID_Global_Lorenz_Curves.png', format='png', dpi=300, bbox_inches='tight')\n\n# Show the plot!\nplt.show()"
  },
  {
    "objectID": "posts/202503-bitcoin-distribution/index.html",
    "href": "posts/202503-bitcoin-distribution/index.html",
    "title": "Bitcoin Wealth Distribution: Utopian vision of anarcho-capitalism",
    "section": "",
    "text": "A plot that shows the distribution wealth of Bitcoin among the wallets with a balance greater than $5,000 USD.\n\n\nCode\n# Libraries\n# ===================================================\nimport pandas as pd\nimport numpy as np\nfrom bs4 import BeautifulSoup\nimport requests\nfrom io import StringIO\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport matplotlib.patches as patches\n\n# Bitcoin Price\n# ===================================================\nurl = \"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\"\nresponse = requests.get(url)\ndata = response.json()\nbtcprice = data.get(\"USD\")\n\n# Bitcoin Supply\n# ===================================================\ndef get_btc_supply():\n    response = requests.get(\"https://blockchain.info/q/totalbc\")\n    satoshi = int(response.text)\n    btcsupply = satoshi / 100000000\n    return btcsupply\nbtcsupply = get_btc_supply()\n\n# Data Extraction\n# ===================================================\nurl = \"https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html\"\nsoup = BeautifulSoup(requests.get(url).text, \"html.parser\")\ntable = soup.find(\"table\", {\"class\": \"table table-condensed bb\"})\ndf = pd.read_html(StringIO(str(table)))[0]\n\n# Data Transformation\n# ===================================================\n# Select columns\ndf = df[['Balance, BTC', 'Addresses', 'BTC']]\n\n# Rename columns and add average\ndf.rename(columns={'Addresses': 'rows', 'BTC': 'btc'}, inplace=True)\n\n# Extract start and end range\ndf['start'] = df['Balance, BTC'].str.extract(r'[\\[\\(](\\d[\\d,\\.]*)')\ndf['end'] = df['Balance, BTC'].str.extract(r'-\\s([\\d,\\.]+)\\)')\ndf['btc'] = df['btc'].str.extract('([0-9.]+)')\n\n# Convert to values\ndf['rows'] = df['rows'].replace({',': ''}, regex=True).astype(int)\ndf['start'] = df['start'].replace({',': ''}, regex=True).astype(float)\ndf['end'] = df['end'].replace({',': ''}, regex=True).astype(float)\ndf['btc'] = df['btc'].replace({',': ''}, regex=True).astype(float)\n\n# Add average price\ndf['average'] = df['btc'] / df['rows']\n\n# Select columns\ndf = df[['rows', 'start', 'end', 'btc', 'average']]\n\n# Change first and last value\ndf.loc[df.index[0], 'start'] = 0.000001\ndf.loc[df.index[-1], 'end'] = 250000\n\n# Create a list\nresult = []\n\n# Iterate over each row \nfor index, row in df.iterrows():\n    n = int(row['rows'])\n    start = row['start']\n    end = row['end']\n    average = row['average']\n    \n    # Generate a distribution\n    valores = np.logspace(np.log(start) / np.log(12), np.log(end) / np.log(12), n)\n        \n   # Calcular el factor de escala para ajustar el promedio\n    current_average = np.mean(valores)\n    scale_factor = average / current_average\n    adjusted_values = valores * scale_factor\n\n    # Add values to result list\n    result.extend(valores)\n\n# Crear a dataframe with all values\ndf = pd.DataFrame(result, columns=['btc'])\n\n# Calculate marketcap\nmarketcap = btcsupply * btcprice\n\n# USD Value, Filter &gt;5000 and count\ndf['usd'] = df['btc'] * btcprice\ndf = df[df['usd'] &gt; 5000]\ndf['count'] = 1\n\n# Grouping by 100 percentiles\ndf['percentile'] = pd.qcut(df['btc'], 100, labels=False) + 1\n\n# Grouping by 10 percentiles\ndf['percentile2'] = pd.cut(\n    df['percentile'], \n    bins=range(1, 111, 10), \n    right=False, \n    labels=[i + 9 for i in range(1, 101, 10)]\n).astype(int)\n\n# Calculate GINI Index\ndef gini(x):\n    x = np.array(x)\n    x = np.sort(x)\n    n = len(x)\n    gini_index = (2 * np.sum(np.arange(1, n + 1) * x) - (n + 1) * np.sum(x)) / (n * np.sum(x))\n    return gini_index\ngini_value = gini(df['usd'])\n\n# Summarizing data \ndf = df.groupby(['percentile', 'percentile2'])[['usd', 'btc', 'count']].sum().reset_index()\n\n# Average price\ndf['average_usd'] = df['usd'] / df['count']\ndf['percentage'] = df['usd'] / df['usd'].sum()\n\n# Select columns\ndf = df[['percentile', 'percentile2', 'usd', 'count', 'average_usd', 'percentage']]\n\n# Define palette\ncolor_palette = {\n    10: \"#050407\",\n    20: \"#07111e\",\n    30: \"#15334b\",\n    40: \"#2b5778\",\n    50: \"#417da1\",\n    60: \"#5593bb\",\n    70: \"#5a7aa3\",\n    80: \"#6d5e86\",\n    90: \"#a2425c\",\n    100: \"#D21E00\"\n}\n\n# Map palette color\ndf['color'] = df['percentile2'].map(color_palette)\n\n# Percentiles dataframe 2\ndf2 = df.copy()\ndf2 = df2.groupby(['percentile2', 'color'], as_index=False)[['usd', 'count']].sum()\ndf2['average_usd'] = df2['usd'] / df2['count']\ndf2['percentage'] = df2['usd'] / (df2['usd']).sum()\ndf2['count'] = 10\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create the figure and suplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [10, 0.5]})\n\n# First Plot\n# ==================\n# Plot Bars\nbars = ax1.bar(df['percentile'], df['average_usd'], color=df['color'], edgecolor='darkgrey', linewidth=0.5, zorder=2)\n\n# Title and labels\nax1.text(0, 1.1, 'Bitcoin Wealth Distribution', fontsize=13, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.06, 'Intrapercentile Analysis of Wealth Concentration (excluding &lt; 5000$ wallets)', fontsize=9, color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlabel('% Wallets', fontsize=10, weight='bold')\nax1.set_ylabel('Wealth ($)', fontsize=10, weight='bold')\n\n# Configuration\nax1.grid(axis='x', linestyle='-', alpha=0.5, zorder=1)\nax1.set_xlim(0, 101)\nax1.set_ylim(0, 2000000)\nax1.set_xticks(np.arange(0, 101, step=10))\nax1.set_yticks(np.arange(0, 2000001, step=250000))\nax1.tick_params(axis='x', labelsize=10)\nax1.tick_params(axis='y', labelsize=10)\nax1.spines['top'].set_visible(False)\nax1.spines['right'].set_visible(False)\n\n# Function to format Y axis\ndef format_func(value, tick_number):\n    if value &gt;= 1e6:\n        return '{:,.1f}M'.format(value / 1e6)\n    else:\n        return '{:,.0f}K'.format(value / 1e3)\n\n# Formatting x and y axis\nax1.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{x:.0f}%'))\nax1.yaxis.set_major_formatter(FuncFormatter(format_func))\n\n# Lines and area to separate outliers\nax1.axhline(y=1850000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.axhline(y=1800000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.add_patch(patches.Rectangle((0, 1800000), 105, 50000, linewidth=0, edgecolor='none', facecolor='white', zorder=3))\n\n# Y Axis modify the outlier value\nlabels = [item.get_text() for item in ax1.get_yticklabels()]\nlabels[-1] = '17M'\nax1.set_yticklabels(labels)\n\n# Show labels each 10 percentile\nfor i, (bar, value) in enumerate(zip(bars, df['average_usd'])):\n    value_rounded = round(value / 5000) * 5000\n    if i % 10 == 0:\n        ax1.text(bar.get_x() + bar.get_width() / 2, \n                 abs(bar.get_height()) * 1.4 + 50000,\n                 f'{value_rounded:,.0f}',\n                 ha='center', \n                 va='bottom', \n                 fontsize=8.5,\n                 color='#2c2c2c', \n                 rotation=90)\n\n# Show GINI Index\nax1.text(\n    0.09, 0.97, f\"Gini Index: {gini_value:.2f}\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='right',\n    va='top', \n    bbox=dict(boxstyle=\"round,pad=0.3\", edgecolor='gray', facecolor='white')\n)\n\n# Show MarketCap\nax1.text(\n    0.05, 0.88, \n    f\"Price: ${btcprice / 1e3:.0f} k\\nMCap: ${marketcap / 1e12:.2f} Bn\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='center',\n    va='top'\n)\n\n# Second Plot\n# ==================\n# Plot Bars\nax2.barh([0] * len(df2), df2['count'], left=df2['percentile2'] - df2['count'], color=df2['color'])\n\n# Configuration\nax2.grid(axis='x', linestyle='-', color='white', alpha=1, linewidth=0.5)\nax2.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)\nax2.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)\nax2.spines['top'].set_visible(False)\nax2.spines['right'].set_visible(False)\nax2.spines['left'].set_visible(False)\nax2.spines['bottom'].set_visible(False)\nx_ticks = np.linspace(df2['percentile2'].min(), df2['percentile2'].max(), 10)\nax2.set_xticks(x_ticks)\nax2.set_xlim(0, 101)\n\n# Add label values\nfor i, row in df2.iterrows():\n    plt.text(row['percentile2'] - row['count'] + row['count'] / 2, 0, \n             f'{row[\"percentage\"] * 100:.2f}%', ha='center', va='center', color='white', fontweight='bold')\n    \n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.1, f'{formatted_date}',\n    transform=ax1.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nax2.text(0, -0.5, 'Data Source: BitInfoCharts. \"Top 100 Richest Bitcoin Addresses.\"',\n         transform=ax2.transAxes,\n         fontsize=8,\n         color='#2c2c2c')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\nplt.savefig(\"C:/Users/guill/Downloads/FIG_BITINFO_Bitcoin_Wealth_Distribution.png\", dpi=300, bbox_inches='tight') \n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/202503-bitcoin-distribution/index.html#summary",
    "href": "posts/202503-bitcoin-distribution/index.html#summary",
    "title": "Bitcoin Wealth Distribution: Utopian vision of anarcho-capitalism",
    "section": "",
    "text": "A plot that shows the distribution wealth of Bitcoin among the wallets with a balance greater than $5,000 USD.\n\n\nCode\n# Libraries\n# ===================================================\nimport pandas as pd\nimport numpy as np\nfrom bs4 import BeautifulSoup\nimport requests\nfrom io import StringIO\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport matplotlib.patches as patches\n\n# Bitcoin Price\n# ===================================================\nurl = \"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\"\nresponse = requests.get(url)\ndata = response.json()\nbtcprice = data.get(\"USD\")\n\n# Bitcoin Supply\n# ===================================================\ndef get_btc_supply():\n    response = requests.get(\"https://blockchain.info/q/totalbc\")\n    satoshi = int(response.text)\n    btcsupply = satoshi / 100000000\n    return btcsupply\nbtcsupply = get_btc_supply()\n\n# Data Extraction\n# ===================================================\nurl = \"https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html\"\nsoup = BeautifulSoup(requests.get(url).text, \"html.parser\")\ntable = soup.find(\"table\", {\"class\": \"table table-condensed bb\"})\ndf = pd.read_html(StringIO(str(table)))[0]\n\n# Data Transformation\n# ===================================================\n# Select columns\ndf = df[['Balance, BTC', 'Addresses', 'BTC']]\n\n# Rename columns and add average\ndf.rename(columns={'Addresses': 'rows', 'BTC': 'btc'}, inplace=True)\n\n# Extract start and end range\ndf['start'] = df['Balance, BTC'].str.extract(r'[\\[\\(](\\d[\\d,\\.]*)')\ndf['end'] = df['Balance, BTC'].str.extract(r'-\\s([\\d,\\.]+)\\)')\ndf['btc'] = df['btc'].str.extract('([0-9.]+)')\n\n# Convert to values\ndf['rows'] = df['rows'].replace({',': ''}, regex=True).astype(int)\ndf['start'] = df['start'].replace({',': ''}, regex=True).astype(float)\ndf['end'] = df['end'].replace({',': ''}, regex=True).astype(float)\ndf['btc'] = df['btc'].replace({',': ''}, regex=True).astype(float)\n\n# Add average price\ndf['average'] = df['btc'] / df['rows']\n\n# Select columns\ndf = df[['rows', 'start', 'end', 'btc', 'average']]\n\n# Change first and last value\ndf.loc[df.index[0], 'start'] = 0.000001\ndf.loc[df.index[-1], 'end'] = 250000\n\n# Create a list\nresult = []\n\n# Iterate over each row \nfor index, row in df.iterrows():\n    n = int(row['rows'])\n    start = row['start']\n    end = row['end']\n    average = row['average']\n    \n    # Generate a distribution\n    valores = np.logspace(np.log(start) / np.log(12), np.log(end) / np.log(12), n)\n        \n   # Calcular el factor de escala para ajustar el promedio\n    current_average = np.mean(valores)\n    scale_factor = average / current_average\n    adjusted_values = valores * scale_factor\n\n    # Add values to result list\n    result.extend(valores)\n\n# Crear a dataframe with all values\ndf = pd.DataFrame(result, columns=['btc'])\n\n# Calculate marketcap\nmarketcap = btcsupply * btcprice\n\n# USD Value, Filter &gt;5000 and count\ndf['usd'] = df['btc'] * btcprice\ndf = df[df['usd'] &gt; 5000]\ndf['count'] = 1\n\n# Grouping by 100 percentiles\ndf['percentile'] = pd.qcut(df['btc'], 100, labels=False) + 1\n\n# Grouping by 10 percentiles\ndf['percentile2'] = pd.cut(\n    df['percentile'], \n    bins=range(1, 111, 10), \n    right=False, \n    labels=[i + 9 for i in range(1, 101, 10)]\n).astype(int)\n\n# Calculate GINI Index\ndef gini(x):\n    x = np.array(x)\n    x = np.sort(x)\n    n = len(x)\n    gini_index = (2 * np.sum(np.arange(1, n + 1) * x) - (n + 1) * np.sum(x)) / (n * np.sum(x))\n    return gini_index\ngini_value = gini(df['usd'])\n\n# Summarizing data \ndf = df.groupby(['percentile', 'percentile2'])[['usd', 'btc', 'count']].sum().reset_index()\n\n# Average price\ndf['average_usd'] = df['usd'] / df['count']\ndf['percentage'] = df['usd'] / df['usd'].sum()\n\n# Select columns\ndf = df[['percentile', 'percentile2', 'usd', 'count', 'average_usd', 'percentage']]\n\n# Define palette\ncolor_palette = {\n    10: \"#050407\",\n    20: \"#07111e\",\n    30: \"#15334b\",\n    40: \"#2b5778\",\n    50: \"#417da1\",\n    60: \"#5593bb\",\n    70: \"#5a7aa3\",\n    80: \"#6d5e86\",\n    90: \"#a2425c\",\n    100: \"#D21E00\"\n}\n\n# Map palette color\ndf['color'] = df['percentile2'].map(color_palette)\n\n# Percentiles dataframe 2\ndf2 = df.copy()\ndf2 = df2.groupby(['percentile2', 'color'], as_index=False)[['usd', 'count']].sum()\ndf2['average_usd'] = df2['usd'] / df2['count']\ndf2['percentage'] = df2['usd'] / (df2['usd']).sum()\ndf2['count'] = 10\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create the figure and suplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [10, 0.5]})\n\n# First Plot\n# ==================\n# Plot Bars\nbars = ax1.bar(df['percentile'], df['average_usd'], color=df['color'], edgecolor='darkgrey', linewidth=0.5, zorder=2)\n\n# Title and labels\nax1.text(0, 1.1, 'Bitcoin Wealth Distribution', fontsize=13, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.06, 'Intrapercentile Analysis of Wealth Concentration (excluding &lt; 5000$ wallets)', fontsize=9, color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlabel('% Wallets', fontsize=10, weight='bold')\nax1.set_ylabel('Wealth ($)', fontsize=10, weight='bold')\n\n# Configuration\nax1.grid(axis='x', linestyle='-', alpha=0.5, zorder=1)\nax1.set_xlim(0, 101)\nax1.set_ylim(0, 2000000)\nax1.set_xticks(np.arange(0, 101, step=10))\nax1.set_yticks(np.arange(0, 2000001, step=250000))\nax1.tick_params(axis='x', labelsize=10)\nax1.tick_params(axis='y', labelsize=10)\nax1.spines['top'].set_visible(False)\nax1.spines['right'].set_visible(False)\n\n# Function to format Y axis\ndef format_func(value, tick_number):\n    if value &gt;= 1e6:\n        return '{:,.1f}M'.format(value / 1e6)\n    else:\n        return '{:,.0f}K'.format(value / 1e3)\n\n# Formatting x and y axis\nax1.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{x:.0f}%'))\nax1.yaxis.set_major_formatter(FuncFormatter(format_func))\n\n# Lines and area to separate outliers\nax1.axhline(y=1850000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.axhline(y=1800000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.add_patch(patches.Rectangle((0, 1800000), 105, 50000, linewidth=0, edgecolor='none', facecolor='white', zorder=3))\n\n# Y Axis modify the outlier value\nlabels = [item.get_text() for item in ax1.get_yticklabels()]\nlabels[-1] = '17M'\nax1.set_yticklabels(labels)\n\n# Show labels each 10 percentile\nfor i, (bar, value) in enumerate(zip(bars, df['average_usd'])):\n    value_rounded = round(value / 5000) * 5000\n    if i % 10 == 0:\n        ax1.text(bar.get_x() + bar.get_width() / 2, \n                 abs(bar.get_height()) * 1.4 + 50000,\n                 f'{value_rounded:,.0f}',\n                 ha='center', \n                 va='bottom', \n                 fontsize=8.5,\n                 color='#2c2c2c', \n                 rotation=90)\n\n# Show GINI Index\nax1.text(\n    0.09, 0.97, f\"Gini Index: {gini_value:.2f}\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='right',\n    va='top', \n    bbox=dict(boxstyle=\"round,pad=0.3\", edgecolor='gray', facecolor='white')\n)\n\n# Show MarketCap\nax1.text(\n    0.05, 0.88, \n    f\"Price: ${btcprice / 1e3:.0f} k\\nMCap: ${marketcap / 1e12:.2f} Bn\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='center',\n    va='top'\n)\n\n# Second Plot\n# ==================\n# Plot Bars\nax2.barh([0] * len(df2), df2['count'], left=df2['percentile2'] - df2['count'], color=df2['color'])\n\n# Configuration\nax2.grid(axis='x', linestyle='-', color='white', alpha=1, linewidth=0.5)\nax2.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)\nax2.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)\nax2.spines['top'].set_visible(False)\nax2.spines['right'].set_visible(False)\nax2.spines['left'].set_visible(False)\nax2.spines['bottom'].set_visible(False)\nx_ticks = np.linspace(df2['percentile2'].min(), df2['percentile2'].max(), 10)\nax2.set_xticks(x_ticks)\nax2.set_xlim(0, 101)\n\n# Add label values\nfor i, row in df2.iterrows():\n    plt.text(row['percentile2'] - row['count'] + row['count'] / 2, 0, \n             f'{row[\"percentage\"] * 100:.2f}%', ha='center', va='center', color='white', fontweight='bold')\n    \n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.1, f'{formatted_date}',\n    transform=ax1.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nax2.text(0, -0.5, 'Data Source: BitInfoCharts. \"Top 100 Richest Bitcoin Addresses.\"',\n         transform=ax2.transAxes,\n         fontsize=8,\n         color='#2c2c2c')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\nplt.savefig(\"C:/Users/guill/Downloads/FIG_BITINFO_Bitcoin_Wealth_Distribution.png\", dpi=300, bbox_inches='tight') \n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/202501-distribution-mountains-gdpc/index.html",
    "href": "posts/202501-distribution-mountains-gdpc/index.html",
    "title": "Distribution of Global GDP: Visualizing Income Mountains",
    "section": "",
    "text": "A plot that shows the evolution of Daily Income based on GDP per Capita ($US constant 2017) from 1900 to 2100.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\nfrom matplotlib.lines import Line2D\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'iso3'})\n\n# Data Extraction (GAPMINDER)\n# ====================================================================\n# URL Github\nurlgap = 'https://raw.githubusercontent.com/guillemmaya92/world_map/refs/heads/main/gapminder-gdp.csv'\ndfgap = pd.read_csv(urlgap, delimiter=';')\n\n# Transform iso3 to upper and divide population\ndfgap['iso3'] = dfgap['iso3'].str.upper()\ndfgap['pop'] = dfgap['pop'] // 1000000\n\n# Filter years\ndfgap = dfgap[dfgap['year'] &gt; 1900]\n\n# Data Manipulation\n# ====================================================================\n# Copy Dataframe\ndf = dfgap.copy()\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['iso3'].unique():\n    temp_df = df[df['iso3'] == iso3].copy()\n    temp_df['date'] = pd.to_datetime(temp_df['year'], format='%Y')\n    temp_df = temp_df[['date', 'pop', 'gdpc']]\n    temp_df = temp_df.set_index('date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['iso3'] = iso3\n    temp_df['year'] = temp_df['date'].dt.year \n    dfs.append(temp_df)\n\n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='iso3', right_on='iso3')\ndf = df[['iso3', 'Country', 'Region', 'year', 'date', 'pop', 'gdpc']]\ndf = df[df['Region'].notna()]\n\n# Expand dataframe with population\ncolumns = df.columns\ndf = np.repeat(df.values, df['pop'].astype(int), axis=0)\ndf = pd.DataFrame(df, columns=columns)\n\n# Function to create a new distribution\ndef distribution(df):\n    average = df['gdpc'].mean()\n    inequality = np.geomspace(1, 10, len(df))\n    df['gdpcd'] = inequality * (average / np.mean(inequality))\n    \n    return df\n\ndf = df.groupby(['iso3', 'year', 'date']).apply(distribution).reset_index(drop=True)\n\n# Logarithmic distribution\ndf['gdpcdl'] = np.log(df['gdpcd'])\n\n# Logarithmic distribution\ndf['Region'] = np.where(df['iso3'] == 'CHN', 'China', df['Region'])\ndf['Region'] = np.where(df['iso3'] == 'USA', 'USA', df['Region'])\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\n\n# Create a palette\nfig, ax = plt.subplots(figsize=(16, 9))\n\ndef update(year):\n    ax.clear()\n    df_filtered = df[df['date'] == year]\n\n    # Calculate mean value\n    max_value = df_filtered['gdpcdl'].max()\n    mean_value = df_filtered['gdpcdl'].median()\n    mean_value_r = df_filtered['gdpcd'].median() // 365\n    population = len(df_filtered)\n    year = df_filtered['date'].min()\n\n    # Custom palette area\n    custom_area = {\n        'China': '#e3d6b1',\n        'Asia': '#fff3d0',\n        'Europe': '#ccdccd',\n        'Oceania': '#90a8b7',\n        'USA': '#f09c9c',\n        'Americas': '#fdcccc',\n        'Africa': '#ffe3ce'\n    }\n\n    # Custom palette line\n    custom_line = {\n        'China': '#cc9d0e',\n        'Asia': '#FFC107',\n        'Europe': '#004d00',\n        'Oceania': '#003366',\n        'USA': '#a60707',\n        'Americas': '#FF0000',\n        'Africa': '#FF6F00'\n    }\n\n    # Region Order\n    order_region = ['China', 'Asia', 'Africa', 'USA', 'Americas', 'Europe', 'Oceania'] \n\n    # Create kdeplot area and lines\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_area, fill=True, linewidth=1, linestyle='-', ax=ax)\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_line, fill=False, linewidth=1, linestyle='-', ax=ax)\n\n    # Configuration grid and labels\n    ax.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    ax.text(0, 1.02, 'Evolution by region from 1980 to 2030', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    ax.set_xlabel('Daily Income PPP ($US constant 2017)', fontsize=10, fontweight='bold')\n    ax.set_ylabel('Frequency of total population', fontsize=10, fontweight='bold')\n    ax.tick_params(axis='x', labelsize=9)\n    ax.tick_params(axis='y', labelsize=9)\n    ax.grid(axis='x')\n    ax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    ax.set_ylim(0, 0.4)\n    ax.set_xlim(3, 13)\n\n    # Functions to round axis\n    def round_to_nearest(value, step=0.05):\n        return np.floor(value / step) * step\n    def round_to_nearest_1(value, step=0.25):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_5(value, step=5):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_10(value, step=10):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_50(value, step=50):\n        return int(np.round(value / step) * step)\n\n    # Inverse logarhitmic xticklabels\n    xticks = np.linspace(3, 13, num=12)\n    ax.set_xticks(xticks)\n    ax.set_xticklabels([\n        # Condition 1\n        f'{round_to_nearest(np.exp(tick) / 365) :.2f}' if np.exp(tick) / 365 &lt; 1 else\n        # Condition 2\n        f'{round_to_nearest_1(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 5 else\n        # Condition 3\n        f'{round_to_nearest_5(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 100 else\n        # Condition 4\n        f'{round_to_nearest_10(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 500 else\n        # Condition 5\n        f'{round_to_nearest_50(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 10000 else\n        # Condition 6\n        f'{int(np.exp(tick) / 365)}'\n        for tick in xticks\n    ])\n\n    # Black color to xticklabels\n    for label in ax.get_xticklabels():\n        label.set_color('black')\n        \n    # Median line\n    ax.axvline(mean_value, color='darkred', linestyle='--', linewidth=0.5)\n    ax.text(\n        x=mean_value + (max_value * 0.01),\n        y=ax.get_ylim()[1] * 0.98,\n        s=f'Median: {mean_value_r:,.1f} $/day',\n        color='darkred',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Population label\n    ax.text(\n        0.02,\n        0.98,\n        s=f'Population: {population:,.0f} (M)',\n        transform=ax.transAxes,\n        color='dimgrey',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Add Year label\n    formatted_date = year.strftime('%Y') \n    ax.text(1, 1.06, f'{formatted_date}',\n        transform=ax.transAxes,\n        fontsize=22, ha='right', va='top',\n        fontweight='bold', color='#D3D3D3')\n\n    # Add a custom legend\n    legend_elements = [Line2D([0], [0], color=color, lw=4, label=region, alpha=0.4) for region, color in custom_line.items()]\n    legend = ax.legend(handles=legend_elements, title='Region', title_fontsize='10', fontsize='9', loc='upper right')\n    plt.setp(legend.get_title(), fontweight='bold')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkblue', va='center')\n\n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: Gapminder (2024). GDP per capita Dataset.', \n        transform=plt.gca().transAxes, \n        fontsize=8, \n        color='gray')\n\n    # Add Notes\n    plt.text(0, -0.12, 'Notes: The distribution of values, based on GDP per capita, has been calculated using a logarithmic scale ranging from 1 to 10 and adjusted proportionally to the population size of each country.', \n        transform=plt.gca().transAxes,\n        fontsize=8, \n        color='gray')\n\n# Configurate animation\nyears = sorted(df['date'].unique())\nani = animation.FuncAnimation(fig, update, frames=years, repeat=False, interval=50, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guillem.maya/Downloads/FIG_GDP_Capita_Distribution_PPP_KDEPLOT_GAPMINDER.webp', writer='imagemagick', fps=80)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202501-distribution-mountains-gdpc/index.html#summary",
    "href": "posts/202501-distribution-mountains-gdpc/index.html#summary",
    "title": "Distribution of Global GDP: Visualizing Income Mountains",
    "section": "",
    "text": "A plot that shows the evolution of Daily Income based on GDP per Capita ($US constant 2017) from 1900 to 2100.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\nfrom matplotlib.lines import Line2D\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'iso3'})\n\n# Data Extraction (GAPMINDER)\n# ====================================================================\n# URL Github\nurlgap = 'https://raw.githubusercontent.com/guillemmaya92/world_map/refs/heads/main/gapminder-gdp.csv'\ndfgap = pd.read_csv(urlgap, delimiter=';')\n\n# Transform iso3 to upper and divide population\ndfgap['iso3'] = dfgap['iso3'].str.upper()\ndfgap['pop'] = dfgap['pop'] // 1000000\n\n# Filter years\ndfgap = dfgap[dfgap['year'] &gt; 1900]\n\n# Data Manipulation\n# ====================================================================\n# Copy Dataframe\ndf = dfgap.copy()\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['iso3'].unique():\n    temp_df = df[df['iso3'] == iso3].copy()\n    temp_df['date'] = pd.to_datetime(temp_df['year'], format='%Y')\n    temp_df = temp_df[['date', 'pop', 'gdpc']]\n    temp_df = temp_df.set_index('date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['iso3'] = iso3\n    temp_df['year'] = temp_df['date'].dt.year \n    dfs.append(temp_df)\n\n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='iso3', right_on='iso3')\ndf = df[['iso3', 'Country', 'Region', 'year', 'date', 'pop', 'gdpc']]\ndf = df[df['Region'].notna()]\n\n# Expand dataframe with population\ncolumns = df.columns\ndf = np.repeat(df.values, df['pop'].astype(int), axis=0)\ndf = pd.DataFrame(df, columns=columns)\n\n# Function to create a new distribution\ndef distribution(df):\n    average = df['gdpc'].mean()\n    inequality = np.geomspace(1, 10, len(df))\n    df['gdpcd'] = inequality * (average / np.mean(inequality))\n    \n    return df\n\ndf = df.groupby(['iso3', 'year', 'date']).apply(distribution).reset_index(drop=True)\n\n# Logarithmic distribution\ndf['gdpcdl'] = np.log(df['gdpcd'])\n\n# Logarithmic distribution\ndf['Region'] = np.where(df['iso3'] == 'CHN', 'China', df['Region'])\ndf['Region'] = np.where(df['iso3'] == 'USA', 'USA', df['Region'])\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\n\n# Create a palette\nfig, ax = plt.subplots(figsize=(16, 9))\n\ndef update(year):\n    ax.clear()\n    df_filtered = df[df['date'] == year]\n\n    # Calculate mean value\n    max_value = df_filtered['gdpcdl'].max()\n    mean_value = df_filtered['gdpcdl'].median()\n    mean_value_r = df_filtered['gdpcd'].median() // 365\n    population = len(df_filtered)\n    year = df_filtered['date'].min()\n\n    # Custom palette area\n    custom_area = {\n        'China': '#e3d6b1',\n        'Asia': '#fff3d0',\n        'Europe': '#ccdccd',\n        'Oceania': '#90a8b7',\n        'USA': '#f09c9c',\n        'Americas': '#fdcccc',\n        'Africa': '#ffe3ce'\n    }\n\n    # Custom palette line\n    custom_line = {\n        'China': '#cc9d0e',\n        'Asia': '#FFC107',\n        'Europe': '#004d00',\n        'Oceania': '#003366',\n        'USA': '#a60707',\n        'Americas': '#FF0000',\n        'Africa': '#FF6F00'\n    }\n\n    # Region Order\n    order_region = ['China', 'Asia', 'Africa', 'USA', 'Americas', 'Europe', 'Oceania'] \n\n    # Create kdeplot area and lines\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_area, fill=True, linewidth=1, linestyle='-', ax=ax)\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_line, fill=False, linewidth=1, linestyle='-', ax=ax)\n\n    # Configuration grid and labels\n    ax.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    ax.text(0, 1.02, 'Evolution by region from 1980 to 2030', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    ax.set_xlabel('Daily Income PPP ($US constant 2017)', fontsize=10, fontweight='bold')\n    ax.set_ylabel('Frequency of total population', fontsize=10, fontweight='bold')\n    ax.tick_params(axis='x', labelsize=9)\n    ax.tick_params(axis='y', labelsize=9)\n    ax.grid(axis='x')\n    ax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    ax.set_ylim(0, 0.4)\n    ax.set_xlim(3, 13)\n\n    # Functions to round axis\n    def round_to_nearest(value, step=0.05):\n        return np.floor(value / step) * step\n    def round_to_nearest_1(value, step=0.25):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_5(value, step=5):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_10(value, step=10):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_50(value, step=50):\n        return int(np.round(value / step) * step)\n\n    # Inverse logarhitmic xticklabels\n    xticks = np.linspace(3, 13, num=12)\n    ax.set_xticks(xticks)\n    ax.set_xticklabels([\n        # Condition 1\n        f'{round_to_nearest(np.exp(tick) / 365) :.2f}' if np.exp(tick) / 365 &lt; 1 else\n        # Condition 2\n        f'{round_to_nearest_1(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 5 else\n        # Condition 3\n        f'{round_to_nearest_5(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 100 else\n        # Condition 4\n        f'{round_to_nearest_10(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 500 else\n        # Condition 5\n        f'{round_to_nearest_50(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 10000 else\n        # Condition 6\n        f'{int(np.exp(tick) / 365)}'\n        for tick in xticks\n    ])\n\n    # Black color to xticklabels\n    for label in ax.get_xticklabels():\n        label.set_color('black')\n        \n    # Median line\n    ax.axvline(mean_value, color='darkred', linestyle='--', linewidth=0.5)\n    ax.text(\n        x=mean_value + (max_value * 0.01),\n        y=ax.get_ylim()[1] * 0.98,\n        s=f'Median: {mean_value_r:,.1f} $/day',\n        color='darkred',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Population label\n    ax.text(\n        0.02,\n        0.98,\n        s=f'Population: {population:,.0f} (M)',\n        transform=ax.transAxes,\n        color='dimgrey',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Add Year label\n    formatted_date = year.strftime('%Y') \n    ax.text(1, 1.06, f'{formatted_date}',\n        transform=ax.transAxes,\n        fontsize=22, ha='right', va='top',\n        fontweight='bold', color='#D3D3D3')\n\n    # Add a custom legend\n    legend_elements = [Line2D([0], [0], color=color, lw=4, label=region, alpha=0.4) for region, color in custom_line.items()]\n    legend = ax.legend(handles=legend_elements, title='Region', title_fontsize='10', fontsize='9', loc='upper right')\n    plt.setp(legend.get_title(), fontweight='bold')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkblue', va='center')\n\n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: Gapminder (2024). GDP per capita Dataset.', \n        transform=plt.gca().transAxes, \n        fontsize=8, \n        color='gray')\n\n    # Add Notes\n    plt.text(0, -0.12, 'Notes: The distribution of values, based on GDP per capita, has been calculated using a logarithmic scale ranging from 1 to 10 and adjusted proportionally to the population size of each country.', \n        transform=plt.gca().transAxes,\n        fontsize=8, \n        color='gray')\n\n# Configurate animation\nyears = sorted(df['date'].unique())\nani = animation.FuncAnimation(fig, update, frames=years, repeat=False, interval=50, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guillem.maya/Downloads/FIG_GDP_Capita_Distribution_PPP_KDEPLOT_GAPMINDER.webp', writer='imagemagick', fps=80)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "hello world!",
    "section": "",
    "text": "From nowhere, delving into the challenges faced by modern economies. I am an enthusiast of data and economics, interested in exploring and uncovering a genuine comprehension of the global world. Focused on social inequalities and the development of a sustainable economy, I pursue a transversal approach that examines these concepts from a holistic and multidisciplinary perspective.\n\n\n Back to top"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "Guillem Maya",
    "section": "",
    "text": "Download pdf"
  },
  {
    "objectID": "cv.html#about-me",
    "href": "cv.html#about-me",
    "title": "Guillem Maya",
    "section": "About me",
    "text": "About me"
  },
  {
    "objectID": "cv.html#experience",
    "href": "cv.html#experience",
    "title": "Guillem Maya",
    "section": "Experience",
    "text": "Experience"
  },
  {
    "objectID": "cv.html#education",
    "href": "cv.html#education",
    "title": "Guillem Maya",
    "section": "Education",
    "text": "Education"
  },
  {
    "objectID": "cv.html#language",
    "href": "cv.html#language",
    "title": "Guillem Maya",
    "section": "Language",
    "text": "Language"
  },
  {
    "objectID": "cv.html#skills",
    "href": "cv.html#skills",
    "title": "Guillem Maya",
    "section": "Skills",
    "text": "Skills"
  },
  {
    "objectID": "posts/202412-bitcoin-halvings/index.html",
    "href": "posts/202412-bitcoin-halvings/index.html",
    "title": "Bitcoin Logarithmic Trends: Analysis since each halving",
    "section": "",
    "text": "A plot that shows the logarithmic price of Bitcoin over each halving period.\n\n\nCode\n# Libraries\n# ==============================================================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\n\n# Get API Data\n# ==============================================================================\n# Create a df with final year dates\ndp = pd.DataFrame({'date': pd.date_range(start='2010-12-31', end='2024-12-31', freq='Y')})\ndp['to_ts'] = dp['date'].apply(lambda x: int(pd.to_datetime(x).timestamp()))\n\n# Create an empty list\ndataframes = []\n\n# Iterate API with each date\nfor to_ts in dp['to_ts']:\n    # Build an URL with parameters and transform data\n    url = f\"https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USD&limit=365&toTs={to_ts}\"\n    response = requests.get(url)\n    data = response.json().get(\"Data\", {}).get(\"Data\", [])\n    df = pd.DataFrame([\n        {\n            \"symbol\": \"BTCUSD\",\n            \"date\": pd.to_datetime(entry[\"time\"], unit=\"s\").date(),\n            \"open\": entry[\"open\"],\n            \"close\": entry[\"close\"],\n            \"low\": entry[\"low\"],\n            \"high\": entry[\"high\"],\n            \"volume\": entry[\"volumeto\"]\n        }\n        for entry in data\n    ])\n    dataframes.append(df)\n# Combine all df into one\nbtc = pd.concat(dataframes, ignore_index=True)\n\n# DataSet 0 - Halving\n#================================================================================\nhalving = {'halving': [0 , 1, 2, 3, 4],\n           'date': ['2009-01-03', '2012-11-28', '2016-07-09', '2020-05-11', '2024-04-20'] \n           }\n\nhalving = pd.DataFrame(halving)\nhalving['date'] = pd.to_datetime(halving['date'])\n\n# DataSet 1 - BTC Price\n# ==============================================================================\n# Prepare dataset\nbtc = btc.drop_duplicates()\nbtc['date'] = pd.to_datetime(btc['date'])\nbtc['year_month'] = btc['date'].dt.strftime('%Y-%m')\nbtc = btc.set_index('date')\nbtc = btc.asfreq('D').ffill()\nbtc = btc.reset_index()\nbtc.sort_values(by=['date'], inplace=True)\nbtc = pd.merge(btc, halving, on='date', how='left')\nbtc['halving'].fillna(method='ffill', inplace=True)\nbtc['halving'].fillna(0, inplace=True)\nbtc['halving'] = btc['halving'].astype(int)\nbtc['first_close'] = btc.groupby('halving')['close'].transform('first')\nbtc['increase'] = (btc['close'] - btc['first_close']) / btc['first_close'] * 100\nbtc['days'] = btc.groupby('halving').cumcount() + 1\nbtc['closelog'] = np.log10(btc['close'])\nbtc = btc[btc['halving'] &gt;= 1]\nbtc['daystotal'] = btc.groupby('symbol').cumcount() + 1\n\n# Graph 1 - SEABORN\n# ==============================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Colors Background\nregions = [\n    (0, 500, '#6B8E23'), # Green\n    (500, 1000, '#FF4500'), # Red\n    (1000, 1500, '#FFA500') # Orange\n    ]  \n\n# Colors Palette Lines\nlines = {\n    0: '#E0E0E0',  # Very Light Grey\n    1: '#C0C0C0',  # Light Grey\n    2: '#808080',  # Medium Grey\n    3: '#404040',  # Dark Grey\n    4: '#8B0000'   # Red\n}\n\n# Seaborn to plot a graph\nsns.set(style=\"whitegrid\", rc={\"grid.color\": \"0.95\", \"axes.grid.axis\": \"y\"})\nplt.figure(figsize=(16, 9))\nsns.lineplot(x='days', y='closelog', hue='halving', data=btc, markers=True, palette=lines, linewidth=1)\n\n# Add region colors in the background\nfor start, end, color in regions:\n    plt.axvspan(start, end, color=color, alpha=0.05)\n\n# Title and axis\nplt.title('Bitcoin Logarithmic Trends: Analysis Since Each Halving', fontsize=16, fontweight='bold', pad=20)\nplt.xlabel('Days',  fontsize=10, fontweight='bold')\nplt.ylabel('Log Price', fontsize=10, fontweight='bold')\nplt.xlim(0, 1500)\nplt.xticks(range(0, 1501, 125), fontsize=9)\nplt.tick_params(axis='both', labelsize=8)\nplt.yticks(fontsize=9)\n\n# Custom legend\nlegend = plt.legend(title=\"Halving\", loc='lower right', fontsize=8, title_fontsize='10')\nnew_title = 'Dates:'\nlegend.set_title(new_title)\nnew_labels = ['1st Halving: 2012-11-28 to 2016-07-09', '2nd Halving: 2016-07-09 to 2020-05-11', '3rd Halving: 2020-05-11 to 2024-04-20', '4th Halving: 2024-04-20 to present'] # Adjust the number of labels according to your data\nfor text, new_label in zip(legend.texts, new_labels):\n    text.set_text(new_label)\n\n# Maximo First 750 days\nbtc1 = btc[(btc['days'] &gt;= 0) & (btc['days'] &lt;= 750)]\nfor halving, group in btc1.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='*', color='darkgoldenrod', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgoldenrod')\n\n# Min Between 500 and 1000 days\nbtc2 = btc[(btc['days'] &gt;= 500) & (btc['days'] &lt;= 1000)]\nfor halving, group in btc2.groupby('halving'):\n    min_value = group['closelog'].min()\n    min_row = group[group['closelog'] == min_value].iloc[0]\n    plt.plot(min_row['days'], min_row['closelog'] - 0.05, marker='v', color='darkred', markersize=5)\n    plt.text(min_row['days'], min_row['closelog'] -0.15, f'{min_row[\"close\"]:,.0f} ({min_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkred')\n\n# Max After 750 days \nbtc3 = btc[(btc['days'] &gt;= 750) & (btc['days'] &lt;= 1500)]\nfor halving, group in btc3.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='^', color='darkgreen', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgreen')\n\n# Custom Last Dots\nmax_vals = btc.groupby('halving').agg({'closelog': 'last', 'days': 'max'}).reset_index()\nfor index, row in max_vals.iterrows():\n    plt.plot(row['days'], row['closelog'], 'ro', markersize=2)\n\n# Custom Line labels\nfor halving, group in btc.groupby('halving'):\n    last_point = group.iloc[-1]\n    x = last_point['days']\n    y = last_point['closelog']\n    max_days = group['days'].max()\n    plt.text(x + 8, y, f'Halving {halving}\\n{max_days} days', color=lines[halving], fontsize=8, ha='left', va='center')\n    \n# Add Year Label\ncurrent_year_month = btc['year_month'].max() \nplt.text(1, 1.05, f'{current_year_month}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.065, 'Data Source: CryptoCompare', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='gray')\n\n# Adjust layout\nplt.tight_layout()\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202412-bitcoin-halvings/index.html#summary",
    "href": "posts/202412-bitcoin-halvings/index.html#summary",
    "title": "Bitcoin Logarithmic Trends: Analysis since each halving",
    "section": "",
    "text": "A plot that shows the logarithmic price of Bitcoin over each halving period.\n\n\nCode\n# Libraries\n# ==============================================================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\n\n# Get API Data\n# ==============================================================================\n# Create a df with final year dates\ndp = pd.DataFrame({'date': pd.date_range(start='2010-12-31', end='2024-12-31', freq='Y')})\ndp['to_ts'] = dp['date'].apply(lambda x: int(pd.to_datetime(x).timestamp()))\n\n# Create an empty list\ndataframes = []\n\n# Iterate API with each date\nfor to_ts in dp['to_ts']:\n    # Build an URL with parameters and transform data\n    url = f\"https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USD&limit=365&toTs={to_ts}\"\n    response = requests.get(url)\n    data = response.json().get(\"Data\", {}).get(\"Data\", [])\n    df = pd.DataFrame([\n        {\n            \"symbol\": \"BTCUSD\",\n            \"date\": pd.to_datetime(entry[\"time\"], unit=\"s\").date(),\n            \"open\": entry[\"open\"],\n            \"close\": entry[\"close\"],\n            \"low\": entry[\"low\"],\n            \"high\": entry[\"high\"],\n            \"volume\": entry[\"volumeto\"]\n        }\n        for entry in data\n    ])\n    dataframes.append(df)\n# Combine all df into one\nbtc = pd.concat(dataframes, ignore_index=True)\n\n# DataSet 0 - Halving\n#================================================================================\nhalving = {'halving': [0 , 1, 2, 3, 4],\n           'date': ['2009-01-03', '2012-11-28', '2016-07-09', '2020-05-11', '2024-04-20'] \n           }\n\nhalving = pd.DataFrame(halving)\nhalving['date'] = pd.to_datetime(halving['date'])\n\n# DataSet 1 - BTC Price\n# ==============================================================================\n# Prepare dataset\nbtc = btc.drop_duplicates()\nbtc['date'] = pd.to_datetime(btc['date'])\nbtc['year_month'] = btc['date'].dt.strftime('%Y-%m')\nbtc = btc.set_index('date')\nbtc = btc.asfreq('D').ffill()\nbtc = btc.reset_index()\nbtc.sort_values(by=['date'], inplace=True)\nbtc = pd.merge(btc, halving, on='date', how='left')\nbtc['halving'].fillna(method='ffill', inplace=True)\nbtc['halving'].fillna(0, inplace=True)\nbtc['halving'] = btc['halving'].astype(int)\nbtc['first_close'] = btc.groupby('halving')['close'].transform('first')\nbtc['increase'] = (btc['close'] - btc['first_close']) / btc['first_close'] * 100\nbtc['days'] = btc.groupby('halving').cumcount() + 1\nbtc['closelog'] = np.log10(btc['close'])\nbtc = btc[btc['halving'] &gt;= 1]\nbtc['daystotal'] = btc.groupby('symbol').cumcount() + 1\n\n# Graph 1 - SEABORN\n# ==============================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Colors Background\nregions = [\n    (0, 500, '#6B8E23'), # Green\n    (500, 1000, '#FF4500'), # Red\n    (1000, 1500, '#FFA500') # Orange\n    ]  \n\n# Colors Palette Lines\nlines = {\n    0: '#E0E0E0',  # Very Light Grey\n    1: '#C0C0C0',  # Light Grey\n    2: '#808080',  # Medium Grey\n    3: '#404040',  # Dark Grey\n    4: '#8B0000'   # Red\n}\n\n# Seaborn to plot a graph\nsns.set(style=\"whitegrid\", rc={\"grid.color\": \"0.95\", \"axes.grid.axis\": \"y\"})\nplt.figure(figsize=(16, 9))\nsns.lineplot(x='days', y='closelog', hue='halving', data=btc, markers=True, palette=lines, linewidth=1)\n\n# Add region colors in the background\nfor start, end, color in regions:\n    plt.axvspan(start, end, color=color, alpha=0.05)\n\n# Title and axis\nplt.title('Bitcoin Logarithmic Trends: Analysis Since Each Halving', fontsize=16, fontweight='bold', pad=20)\nplt.xlabel('Days',  fontsize=10, fontweight='bold')\nplt.ylabel('Log Price', fontsize=10, fontweight='bold')\nplt.xlim(0, 1500)\nplt.xticks(range(0, 1501, 125), fontsize=9)\nplt.tick_params(axis='both', labelsize=8)\nplt.yticks(fontsize=9)\n\n# Custom legend\nlegend = plt.legend(title=\"Halving\", loc='lower right', fontsize=8, title_fontsize='10')\nnew_title = 'Dates:'\nlegend.set_title(new_title)\nnew_labels = ['1st Halving: 2012-11-28 to 2016-07-09', '2nd Halving: 2016-07-09 to 2020-05-11', '3rd Halving: 2020-05-11 to 2024-04-20', '4th Halving: 2024-04-20 to present'] # Adjust the number of labels according to your data\nfor text, new_label in zip(legend.texts, new_labels):\n    text.set_text(new_label)\n\n# Maximo First 750 days\nbtc1 = btc[(btc['days'] &gt;= 0) & (btc['days'] &lt;= 750)]\nfor halving, group in btc1.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='*', color='darkgoldenrod', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgoldenrod')\n\n# Min Between 500 and 1000 days\nbtc2 = btc[(btc['days'] &gt;= 500) & (btc['days'] &lt;= 1000)]\nfor halving, group in btc2.groupby('halving'):\n    min_value = group['closelog'].min()\n    min_row = group[group['closelog'] == min_value].iloc[0]\n    plt.plot(min_row['days'], min_row['closelog'] - 0.05, marker='v', color='darkred', markersize=5)\n    plt.text(min_row['days'], min_row['closelog'] -0.15, f'{min_row[\"close\"]:,.0f} ({min_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkred')\n\n# Max After 750 days \nbtc3 = btc[(btc['days'] &gt;= 750) & (btc['days'] &lt;= 1500)]\nfor halving, group in btc3.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='^', color='darkgreen', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgreen')\n\n# Custom Last Dots\nmax_vals = btc.groupby('halving').agg({'closelog': 'last', 'days': 'max'}).reset_index()\nfor index, row in max_vals.iterrows():\n    plt.plot(row['days'], row['closelog'], 'ro', markersize=2)\n\n# Custom Line labels\nfor halving, group in btc.groupby('halving'):\n    last_point = group.iloc[-1]\n    x = last_point['days']\n    y = last_point['closelog']\n    max_days = group['days'].max()\n    plt.text(x + 8, y, f'Halving {halving}\\n{max_days} days', color=lines[halving], fontsize=8, ha='left', va='center')\n    \n# Add Year Label\ncurrent_year_month = btc['year_month'].max() \nplt.text(1, 1.05, f'{current_year_month}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.065, 'Data Source: CryptoCompare', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='gray')\n\n# Adjust layout\nplt.tight_layout()\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202502-flags-inequalities-gdp/index.html",
    "href": "posts/202502-flags-inequalities-gdp/index.html",
    "title": "Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity",
    "section": "",
    "text": "A plot that shows the current Inequalities in capital productivity.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport requests\nimport plotly.graph_objects as go\nimport numpy as np\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PPPGDP', 'LP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] == 2024]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = df_imf.dropna(subset=['NGDPD', 'PPPGDP', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year', 'NGDPD', 'PPPGDP', 'LP']]\ndf = df[df['Cod_Currency'].notna()]\n\n# Calculate PPP\ndf = df.groupby(['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year'])[['NGDPD', 'PPPGDP', 'LP']].sum()\ndf = df.reset_index()\ndf['PPP'] = df['NGDPD'] / df['PPPGDP']\ndf['NGDPDPC'] = df['NGDPD'] / df['LP']\ndf['PPPPC'] = df['PPPGDP'] / df['LP']\n\n# Calculate Average Weight and Percent\ndf['AVG_Weight'] = df.groupby('Year')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\ndf['Percent'] = df['NGDPD'] / df.groupby('Year')['NGDPD'].transform('sum')\n\n# Filtering\ndf = df[df['NGDPDPC'] &lt; 115 ]\ndf = df[df['PPP'] &lt; 1.25]\ndf = df[~df['ISO2'].isin(['SZ', 'VA', 'NC', 'CI', 'MW', 'SS', 'MY'])]\n\n# Data Visualization\n# =====================================================================\nfig = go.Figure()\n\n# Tamaño de los marcadores\nmarker_size = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 4 + 0.5\n\n# Add scatter plot\nfig.add_trace(go.Scatter(\n    x=df[\"PPP\"],\n    y=df[\"NGDPDPC\"],\n    mode='markers',\n    text=df[\"Country\"],\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;GDP per Capita:&lt;/b&gt; $%{y:.2f}&lt;br&gt;\" + \n                  \"&lt;b&gt;PPP:&lt;/b&gt; $%{x:.2f}&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Add flag images to scatterplot\nfor i, row in df.iterrows():\n    country_iso = row[\"ISO2\"]\n    \n    # Calculate image size\n    image_size = marker_size[i] * 0.21\n\n    # Add the flag image\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"PPP\"],\n            y=row[\"NGDPDPC\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8,\n            layer=\"above\"\n        )\n    )\n    \n# Modeling a line trend\nz = np.polyfit(df['PPP'], df['NGDPDPC'], 2, w=df['NGDPD'])\np = np.poly1d(z)\nx_range = np.linspace(df['PPP'].min(), df['PPP'].max(), 100)\ny_range = p(x_range)\n\n# Add the line trend\nfig.add_trace(go.Scatter(\n    x=x_range,\n    y=y_range,\n    mode='lines',\n    name='Trend Line',\n    line=dict(color='darkred', width=0.5),\n    showlegend=False\n))\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=1,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=1, x1=1.2,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Global Inequalities in GDP per Capita&lt;/b&gt;\",\n    title_x=0.11,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.07,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; IMF World Economic Outlook Database, 2024\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.13,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"2024\",\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.1,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;GAP Between PPP and Market Exchange Rate&lt;/b&gt;\",\n        range=[0, 1.2],\n        tickvals=[i * 1.2 / 6 for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;GDP per Capita (US$)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",\n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;   GDP Scale&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202502-flags-inequalities-gdp/index.html#summary",
    "href": "posts/202502-flags-inequalities-gdp/index.html#summary",
    "title": "Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity",
    "section": "",
    "text": "A plot that shows the current Inequalities in capital productivity.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport requests\nimport plotly.graph_objects as go\nimport numpy as np\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PPPGDP', 'LP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] == 2024]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = df_imf.dropna(subset=['NGDPD', 'PPPGDP', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year', 'NGDPD', 'PPPGDP', 'LP']]\ndf = df[df['Cod_Currency'].notna()]\n\n# Calculate PPP\ndf = df.groupby(['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year'])[['NGDPD', 'PPPGDP', 'LP']].sum()\ndf = df.reset_index()\ndf['PPP'] = df['NGDPD'] / df['PPPGDP']\ndf['NGDPDPC'] = df['NGDPD'] / df['LP']\ndf['PPPPC'] = df['PPPGDP'] / df['LP']\n\n# Calculate Average Weight and Percent\ndf['AVG_Weight'] = df.groupby('Year')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\ndf['Percent'] = df['NGDPD'] / df.groupby('Year')['NGDPD'].transform('sum')\n\n# Filtering\ndf = df[df['NGDPDPC'] &lt; 115 ]\ndf = df[df['PPP'] &lt; 1.25]\ndf = df[~df['ISO2'].isin(['SZ', 'VA', 'NC', 'CI', 'MW', 'SS', 'MY'])]\n\n# Data Visualization\n# =====================================================================\nfig = go.Figure()\n\n# Tamaño de los marcadores\nmarker_size = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 4 + 0.5\n\n# Add scatter plot\nfig.add_trace(go.Scatter(\n    x=df[\"PPP\"],\n    y=df[\"NGDPDPC\"],\n    mode='markers',\n    text=df[\"Country\"],\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;GDP per Capita:&lt;/b&gt; $%{y:.2f}&lt;br&gt;\" + \n                  \"&lt;b&gt;PPP:&lt;/b&gt; $%{x:.2f}&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Add flag images to scatterplot\nfor i, row in df.iterrows():\n    country_iso = row[\"ISO2\"]\n    \n    # Calculate image size\n    image_size = marker_size[i] * 0.21\n\n    # Add the flag image\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"PPP\"],\n            y=row[\"NGDPDPC\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8,\n            layer=\"above\"\n        )\n    )\n    \n# Modeling a line trend\nz = np.polyfit(df['PPP'], df['NGDPDPC'], 2, w=df['NGDPD'])\np = np.poly1d(z)\nx_range = np.linspace(df['PPP'].min(), df['PPP'].max(), 100)\ny_range = p(x_range)\n\n# Add the line trend\nfig.add_trace(go.Scatter(\n    x=x_range,\n    y=y_range,\n    mode='lines',\n    name='Trend Line',\n    line=dict(color='darkred', width=0.5),\n    showlegend=False\n))\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=1,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=1, x1=1.2,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Global Inequalities in GDP per Capita&lt;/b&gt;\",\n    title_x=0.11,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.07,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; IMF World Economic Outlook Database, 2024\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.13,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"2024\",\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.1,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;GAP Between PPP and Market Exchange Rate&lt;/b&gt;\",\n        range=[0, 1.2],\n        tickvals=[i * 1.2 / 6 for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;GDP per Capita (US$)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",\n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;   GDP Scale&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202504-idealista-prices/index.html",
    "href": "posts/202504-idealista-prices/index.html",
    "title": "Alquiler de vivienda en Catalunya: Distribución de precios",
    "section": "",
    "text": "Representación de los precios de aquiler por comarca.\n\n\nCode\n# Libraries\n# ===================================\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggdist)\nlibrary(ggtext)\nlibrary(scales)\nlibrary(grid)\n\n# Extract Data\n# ===================================\n# URL GitHub\nurl &lt;- \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/Catalunya_CP.csv\"\n\n# Read CSV\ndf &lt;- read_delim(url, delim = \";\", locale = locale(encoding = \"latin1\"))\n\n# Select relevant columns and filter data\ndf &lt;- df %&gt;%\n  select(province, region, price) %&gt;%\n  filter(region %in% c(\"Barcelonès\") & price &lt; 3000) %&gt;%\n  filter(!is.na(price))\n\n# Transform Data\n# ===================================\n# Define values\nmin_price &lt;- 0\ncheaper_price &lt;- 800\nmedian_price &lt;- median(df$price, na.rm = TRUE)\nmax_price &lt;- 3000\ntotal_announcements &lt;- nrow(df)\n\n# Calculate extra label values\nmid1 &lt;- (cheaper_price + min_price) / 2\nannouncements1 &lt;- nrow(df %&gt;% filter(price &gt; min_price & price &lt;= cheaper_price))\nmid2 &lt;- (median_price + cheaper_price) / 2\nannouncements2 &lt;- nrow(df %&gt;% filter(price &gt; cheaper_price & price &lt;= median_price))\nmid3 &lt;- (max_price + median_price) / 2\nannouncements3 &lt;- nrow(df %&gt;% filter(price &gt; median_price & price &lt;= max_price))\n\n# Add color column\ndf &lt;- df %&gt;%\n  mutate(color = case_when(\n    price &lt; cheaper_price ~ \"#ffc939\",\n    price &lt; median_price ~ \"#a8c2d2\",\n    TRUE ~ \"#477794\"\n  ))\n\n# Show data\nprint(head(df))\n\n# Plot Data\n# ===================================\ngg &lt;- df %&gt;%\n  # Create ggplot\n  ggplot(aes(x = price, fill = after_stat(case_when(\n    x &lt;= cheaper_price ~ \"cheaper\",\n    x &lt;= median_price ~ \"median\",\n    TRUE ~ \"expensive\"\n  )))) +\n  # Define type of plot\n  geom_dots(\n    smooth = smooth_bounded(adjust = 0.6), \n    side = \"both\", \n    color = NA,\n    dotsize = 0.8,\n    stackratio = 1.3\n  ) +\n  # Configure XY Axis\n  scale_x_continuous(\n    limits = c(min_price, max_price),\n    breaks = seq(min_price, max_price, by = 200),\n    labels = scales::comma_format()\n  ) +\n  scale_y_continuous(breaks = NULL) +\n  # Configure Titles and Captions\n  labs(\n    title = 'Pisos ofertados en Idealista por menos de 3.000 euros',\n    subtitle = \"Anuncios en la comarca del Barcelonés\",\n    x = \"Precio (€)\",\n    caption = paste0(\n      \"**Fuente**: Idealista&lt;br&gt;\n      **Notas**: Cada bola representa un anuncio\"\n    )\n  ) +\n  # Configure elements theme\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    plot.subtitle = element_text(size = 12, face = \"plain\"),\n    axis.title.x = element_text(size = 9, face = \"bold\"),\n    axis.title.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    legend.position = \"none\",\n    plot.caption = element_markdown(size = 8, hjust = 0)\n  ) +\n # Configure fill colors after_stats\n  scale_fill_manual(values = c(\n    \"cheaper\" = \"#ffc939\",\n    \"median\" = \"#a8c2d2\",\n    \"expensive\" = \"#477794\"\n  )) +\n  # Plot Vertical And Horizontal lines\n  geom_hline(yintercept = 0, linetype = \"solid\", color = \"grey\", size = 0.5) +\n  geom_vline(xintercept = cheaper_price, color = \"#9c7a1f\", linetype = \"dotted\", size = 0.25) +\n  geom_vline(xintercept = median_price, color = \"#477794\", linetype = \"dotted\", size = 0.25) +\n  # Annotate: City and adds \n  annotate(\"text\", \n           x = 0, \n           y = 0.05, \n           label = \"Barcelonés\", \n           size = 4, \n           color = \"black\", \n           fontface = \"bold\", \n           hjust = 0) +\n  annotate(\"text\", \n           x = 0, \n           y = -0.08, \n           label = paste(\"Total anuncios:\\n\", comma(total_announcements)), \n           size = 3.5, \n           color = \"black\", \n           fontface = \"plain\", \n           hjust = 0) +\n  # Annotate G1: Cheap adds\n  annotate(geom = \"label\", \n           x = mid1, \n           y = 0.8, \n           label = paste(comma(announcements1), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"#a68221\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid1, \n           y = 0.73, \n           label = paste(\"Entre\", comma(min_price), \"y\", comma(cheaper_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Annotate G2: Median adds\n  annotate(geom = \"label\", \n           x = mid2, \n           y = 0.8, \n           label = paste(comma(announcements2), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"grey\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid2, \n           y = 0.73, \n           label = paste(\"Entre\", comma(cheaper_price), \"y\", comma(median_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Annotate G3: Expensive adds\n  annotate(geom = \"label\", \n           x = mid3, \n           y = 0.8, \n           label = paste(comma(announcements3), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"#477794\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid3, \n           y = 0.73, \n           label = paste(\"Entre\", comma(median_price), \"y\", comma(max_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Extra Annotation: @Author\n  annotation_custom(\n    grob = textGrob(\"@damnedliestats\", gp = gpar(fontsize = 8, col = \"black\")), \n    xmin = 2600, xmax = 3000, ymin = -0.73, ymax = -0.73\n  ) +\n  # Allow extra elements\n  coord_cartesian(clip = \"off\")\n\n# Saving Plot\nggsave(\"C:/Users/guill/Downloads/Barcelonés.jpeg\", \n       plot = gg, dpi = 300, width = 10, height = 6)"
  },
  {
    "objectID": "posts/202504-idealista-prices/index.html#summary",
    "href": "posts/202504-idealista-prices/index.html#summary",
    "title": "Alquiler de vivienda en Catalunya: Distribución de precios",
    "section": "",
    "text": "Representación de los precios de aquiler por comarca.\n\n\nCode\n# Libraries\n# ===================================\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggdist)\nlibrary(ggtext)\nlibrary(scales)\nlibrary(grid)\n\n# Extract Data\n# ===================================\n# URL GitHub\nurl &lt;- \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/Catalunya_CP.csv\"\n\n# Read CSV\ndf &lt;- read_delim(url, delim = \";\", locale = locale(encoding = \"latin1\"))\n\n# Select relevant columns and filter data\ndf &lt;- df %&gt;%\n  select(province, region, price) %&gt;%\n  filter(region %in% c(\"Barcelonès\") & price &lt; 3000) %&gt;%\n  filter(!is.na(price))\n\n# Transform Data\n# ===================================\n# Define values\nmin_price &lt;- 0\ncheaper_price &lt;- 800\nmedian_price &lt;- median(df$price, na.rm = TRUE)\nmax_price &lt;- 3000\ntotal_announcements &lt;- nrow(df)\n\n# Calculate extra label values\nmid1 &lt;- (cheaper_price + min_price) / 2\nannouncements1 &lt;- nrow(df %&gt;% filter(price &gt; min_price & price &lt;= cheaper_price))\nmid2 &lt;- (median_price + cheaper_price) / 2\nannouncements2 &lt;- nrow(df %&gt;% filter(price &gt; cheaper_price & price &lt;= median_price))\nmid3 &lt;- (max_price + median_price) / 2\nannouncements3 &lt;- nrow(df %&gt;% filter(price &gt; median_price & price &lt;= max_price))\n\n# Add color column\ndf &lt;- df %&gt;%\n  mutate(color = case_when(\n    price &lt; cheaper_price ~ \"#ffc939\",\n    price &lt; median_price ~ \"#a8c2d2\",\n    TRUE ~ \"#477794\"\n  ))\n\n# Show data\nprint(head(df))\n\n# Plot Data\n# ===================================\ngg &lt;- df %&gt;%\n  # Create ggplot\n  ggplot(aes(x = price, fill = after_stat(case_when(\n    x &lt;= cheaper_price ~ \"cheaper\",\n    x &lt;= median_price ~ \"median\",\n    TRUE ~ \"expensive\"\n  )))) +\n  # Define type of plot\n  geom_dots(\n    smooth = smooth_bounded(adjust = 0.6), \n    side = \"both\", \n    color = NA,\n    dotsize = 0.8,\n    stackratio = 1.3\n  ) +\n  # Configure XY Axis\n  scale_x_continuous(\n    limits = c(min_price, max_price),\n    breaks = seq(min_price, max_price, by = 200),\n    labels = scales::comma_format()\n  ) +\n  scale_y_continuous(breaks = NULL) +\n  # Configure Titles and Captions\n  labs(\n    title = 'Pisos ofertados en Idealista por menos de 3.000 euros',\n    subtitle = \"Anuncios en la comarca del Barcelonés\",\n    x = \"Precio (€)\",\n    caption = paste0(\n      \"**Fuente**: Idealista&lt;br&gt;\n      **Notas**: Cada bola representa un anuncio\"\n    )\n  ) +\n  # Configure elements theme\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    plot.subtitle = element_text(size = 12, face = \"plain\"),\n    axis.title.x = element_text(size = 9, face = \"bold\"),\n    axis.title.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    legend.position = \"none\",\n    plot.caption = element_markdown(size = 8, hjust = 0)\n  ) +\n # Configure fill colors after_stats\n  scale_fill_manual(values = c(\n    \"cheaper\" = \"#ffc939\",\n    \"median\" = \"#a8c2d2\",\n    \"expensive\" = \"#477794\"\n  )) +\n  # Plot Vertical And Horizontal lines\n  geom_hline(yintercept = 0, linetype = \"solid\", color = \"grey\", size = 0.5) +\n  geom_vline(xintercept = cheaper_price, color = \"#9c7a1f\", linetype = \"dotted\", size = 0.25) +\n  geom_vline(xintercept = median_price, color = \"#477794\", linetype = \"dotted\", size = 0.25) +\n  # Annotate: City and adds \n  annotate(\"text\", \n           x = 0, \n           y = 0.05, \n           label = \"Barcelonés\", \n           size = 4, \n           color = \"black\", \n           fontface = \"bold\", \n           hjust = 0) +\n  annotate(\"text\", \n           x = 0, \n           y = -0.08, \n           label = paste(\"Total anuncios:\\n\", comma(total_announcements)), \n           size = 3.5, \n           color = \"black\", \n           fontface = \"plain\", \n           hjust = 0) +\n  # Annotate G1: Cheap adds\n  annotate(geom = \"label\", \n           x = mid1, \n           y = 0.8, \n           label = paste(comma(announcements1), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"#a68221\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid1, \n           y = 0.73, \n           label = paste(\"Entre\", comma(min_price), \"y\", comma(cheaper_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Annotate G2: Median adds\n  annotate(geom = \"label\", \n           x = mid2, \n           y = 0.8, \n           label = paste(comma(announcements2), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"grey\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid2, \n           y = 0.73, \n           label = paste(\"Entre\", comma(cheaper_price), \"y\", comma(median_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Annotate G3: Expensive adds\n  annotate(geom = \"label\", \n           x = mid3, \n           y = 0.8, \n           label = paste(comma(announcements3), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"#477794\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid3, \n           y = 0.73, \n           label = paste(\"Entre\", comma(median_price), \"y\", comma(max_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Extra Annotation: @Author\n  annotation_custom(\n    grob = textGrob(\"@damnedliestats\", gp = gpar(fontsize = 8, col = \"black\")), \n    xmin = 2600, xmax = 3000, ymin = -0.73, ymax = -0.73\n  ) +\n  # Allow extra elements\n  coord_cartesian(clip = \"off\")\n\n# Saving Plot\nggsave(\"C:/Users/guill/Downloads/Barcelonés.jpeg\", \n       plot = gg, dpi = 300, width = 10, height = 6)"
  },
  {
    "objectID": "posts/202506-global-structure-economy/index.html",
    "href": "posts/202506-global-structure-economy/index.html",
    "title": "Global structure economy: A vision of GDP per capita and population",
    "section": "",
    "text": "This animation illustrates how the hegemony exerted by certain nations has aimed to preserve an unequal income distribution by capturing the greater share of the value chains over the past decades.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.CD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1960, 2024)\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'Year',\n    'SP.POP.TOTL': 'LP',\n    'NY.GDP.PCAP.CD': 'NGDPDPC'\n})\n\n# Adjust LP and filter before 1980\ndf_wb['LP'] = df_wb['LP'] / 1000000\ndf_wb = df_wb[df_wb['Year'] &lt; 1980]\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['LP', 'NGDPDPC']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] &gt;= 1980]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = pd.concat([df_wb, df_imf], ignore_index=True)\ndf = df.dropna(subset=['NGDPDPC', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Country', 'Year', 'LP', 'NGDPDPC', 'Analytical', 'Region']]\ndf = df[df['Region'].notna()]\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['ISO3'].unique():\n    temp_df = df[df['ISO3'] == iso3].copy()\n    temp_df['Date'] = pd.to_datetime(temp_df['Year'], format='%Y')\n    temp_df = temp_df[['Date', 'LP', 'NGDPDPC']]\n    temp_df = temp_df.set_index('Date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['ISO3'] = iso3\n    temp_df['Year'] = temp_df['Date'].dt.year \n    dfs.append(temp_df)\n    \n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Filter nulls and order\ndf = df.sort_values(by=['Year', 'NGDPDPC'])\n\n# Calculate 'left accrual widths'\ndf['LP_Cum'] = df.groupby('Date')['LP'].cumsum()\ndf['LP_Per'] = df['LP'] / df.groupby('Date')['LP'].transform('sum')\ndf['LP_Cum_Per'] = df['LP_Cum'] / df.groupby('Date')['LP_Cum'].transform('max')\ndf['Left'] = df['LP_Cum_Per'] - df['LP_Per']\n\n# Calculate GDP Average weighted by Population and partitioned by Year\ndf['AVG_Weight'] = df.groupby('Date')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\n\n# Add a total GDP column and cummulative it\ndf['GDP'] = df['NGDPDPC'] * df['LP']\ndf['GDPcum'] = df.groupby('Date')['GDP'].cumsum()\ndf['GDP_Per'] = df['GDP'] / df.groupby('Date')['GDP'].transform('sum')\ndf['NGDPDPC_Change'] = ((df['NGDPDPC'] / df.groupby('ISO3')['NGDPDPC'].transform('first')) - 1) * 100\n\n# Copy a df sample to calculate a median\ndf_sample = df.copy()\ncolumns = df.columns\ndf_sample = np.repeat(df_sample.values, df_sample['LP'].astype(int), axis=0)\ndf_sample = pd.DataFrame(df_sample, columns=columns)\ndf_sample.dropna(subset=['NGDPDPC'], inplace=True)\ndf_sample['NGDPDPC'] = pd.to_numeric(df_sample['NGDPDPC'], errors='coerce')\ndf_sample['GDPcum'] = df_sample.groupby('Date')['NGDPDPC'].transform('cumsum')\n\n# Function to get median row\ndef medianrow(group):\n    medianrow = len(group) // 2  # Índice de la mitad\n    return group.iloc[medianrow]\ndf_sample = df_sample.groupby('Date').apply(medianrow).reset_index(drop=True)\n\n# Transform columns\ndf_sample = df_sample[['Date', 'NGDPDPC', 'GDPcum']].reset_index(drop=True)\ndf_sample = df_sample.rename(columns={'NGDPDPC': 'Median', 'GDPcum': 'Median_Total'})\n\n# Merge queries\ndf = df.merge(df_sample, how='left', on='Date')\n\n# Add percentage bottom 50\ndf['Median_Total_Per'] = df['Median_Total'] / df.groupby('Date')['GDP'].transform('sum')\n\nprint(df)\n \n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(16, 9))\n\n# Create a palette\npalette = sns.color_palette(\"coolwarm\", as_cmap=True).reversed()\n\n# Function to refresh animation\ndef update(date):\n    plt.clf()\n    subset = df[df['Date'] == date]\n    subset_usa = subset[subset['ISO3'] == 'USA'].copy()\n    \n    # Normalize GDPcum in a range [0, 1]\n    gdp_min = subset['GDPcum'].min()\n    gdp_max = subset_usa['GDPcum'].max()\n    norm = plt.Normalize(gdp_min, gdp_max)\n    colors = palette(norm(subset['GDPcum']))\n    \n    # Create a Matplotlib plot\n    bars = plt.bar(subset['Left'], subset['NGDPDPC'], width=subset['LP_Per'], \n            color=colors, alpha=1, align='edge', edgecolor='grey', linewidth=0.1)\n    \n    # Configuration grid and labels\n    plt.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    plt.text(0, 1.02, 'Evolution of Countries from 1960 to 2029', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    plt.xlim(0, subset['LP_Cum_Per'].max())\n    plt.ylim(0, subset_usa['NGDPDPC'].max() * 1.05)\n    plt.grid(axis='x')\n    plt.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    plt.xlabel('Cumulative Global Population (%)', fontsize=10, fontweight='bold')\n    plt.ylabel('GDP per capita (US$)', fontsize=10, fontweight='bold')\n    plt.tick_params(axis='x', labelsize=9)\n    plt.tick_params(axis='y', labelsize=9)\n    plt.gca().xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x*100):,}%'))\n    plt.gca().yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(round(x, -3)):,}'))\n    plt.xticks(np.linspace(0, subset['LP_Cum_Per'].max(), 5))\n    plt.yticks(np.linspace(0, subset_usa['NGDPDPC'].max() * 1.05, 8))\n        \n    # Add Labels to relevant countries\n    for bar, value, country in zip(bars, subset['GDP'], subset['ISO3']):\n        if country in ['CHN', 'IND', 'USA', 'IDN', 'PAK', 'NGA', 'BRA', 'BGD', 'RUS', 'MEX', 'JPN', 'VNM', 'DEU', 'GBR']:\n            plt.gca().text(bar.get_x() + bar.get_width()/2, bar.get_height(),\n                        f'{country}\\n{''}', ha='center', va='bottom', fontsize=7, color='grey')\n\n    # Add Median Line and Label\n    median = subset['Median'].max()\n    median_total = subset.iloc[0]['Median_Total']\n    median_total_per = subset.iloc[0]['Median_Total_Per']\n    maxis = subset_usa['NGDPDPC'].max()\n    \n    plt.axhline(\n        y=median,\n        color='darkred', \n        linestyle='--', \n        linewidth=0.5)\n\n    plt.text(\n        x=subset['Left'].max() * 0.02,\n        y=median + (maxis * 0.06),\n        s=f'GDP Capita Median: {median:,.0f}',\n        color='darkred',\n        verticalalignment='bottom',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold') \n\n    plt.gca().text(\n                subset['Left'].max() * 0.02,\n                median + (maxis * 0.04),\n                f'Bottom 50 - Total GDP: {median_total:,.0f} MM ({median_total_per * 100:.2f}%)', \n                ha='left', va='center', \n                fontsize=9, \n                color='#737373')\n    \n    # Add USA Line and Label\n    pibc_usa = subset_usa.iloc[0]['NGDPDPC']\n    pib_usa = subset_usa.iloc[0]['GDP']\n    pib_usa_per = subset_usa.iloc[0]['GDP_Per']\n    \n    plt.axhline(\n        y=pibc_usa, \n        color='darkblue', \n        linestyle='--', \n        linewidth=0.5)\n    \n    plt.text(\n        x=subset['Left'].max() * 0.02,\n        y=pibc_usa * 0.95,\n        s=f'GDP Capita USA: {pibc_usa:,.0f}',\n        color='darkblue',\n        fontsize=10,\n        verticalalignment='bottom',\n        horizontalalignment='left',\n        weight='bold')\n\n    plt.gca().text(\n                subset['Left'].max() * 0.02,\n                pibc_usa * 0.93,\n                f'USA - Total GDP: {pib_usa:,.0f} MM ({pib_usa_per * 100:.2f}%)', \n                ha='left', va='center', \n                fontsize=9, \n                color='#737373')\n\n    # Cover countries going outside plot\n    formatted_date = date.strftime('%Y-%m') \n    plt.text(1, 1.15, f'{formatted_date}',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='white',\n             bbox=dict(facecolor='white', edgecolor='none', boxstyle='square,pad=1'))\n\n    # Add Year label\n    plt.text(1, 1.06, f'{formatted_date}',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='#D3D3D3',\n             bbox=dict(facecolor='white', edgecolor='none', boxstyle='square,pad=0.3'))\n    \n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: IMF World Economic Outlook Database, 2024 | World Bank national accounts data, and OECD National Accounts data files.', \n            transform=plt.gca().transAxes, \n            fontsize=8, \n            color='gray')\n    \n    # Add author\n    plt.text(1, -0.1, '@guillemmaya.com', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='#212121', \n         ha='right')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n             transform=ax.transAxes,\n             fontsize=12, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n             transform=ax.transAxes,\n             fontsize=12, fontweight='bold', color='darkblue', va='center')\n\n# Configurate animation\ndates = sorted(df['Date'].unique())\nani = animation.FuncAnimation(fig, update, frames=dates, repeat=False, interval=500, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guill/Downloads/FIG_GDP_Capita_Bars_1960.webp', writer='imagemagick', fps=15)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202506-global-structure-economy/index.html#summary",
    "href": "posts/202506-global-structure-economy/index.html#summary",
    "title": "Global structure economy: A vision of GDP per capita and population",
    "section": "",
    "text": "This animation illustrates how the hegemony exerted by certain nations has aimed to preserve an unequal income distribution by capturing the greater share of the value chains over the past decades.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.CD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1960, 2024)\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'Year',\n    'SP.POP.TOTL': 'LP',\n    'NY.GDP.PCAP.CD': 'NGDPDPC'\n})\n\n# Adjust LP and filter before 1980\ndf_wb['LP'] = df_wb['LP'] / 1000000\ndf_wb = df_wb[df_wb['Year'] &lt; 1980]\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['LP', 'NGDPDPC']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] &gt;= 1980]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = pd.concat([df_wb, df_imf], ignore_index=True)\ndf = df.dropna(subset=['NGDPDPC', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Country', 'Year', 'LP', 'NGDPDPC', 'Analytical', 'Region']]\ndf = df[df['Region'].notna()]\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['ISO3'].unique():\n    temp_df = df[df['ISO3'] == iso3].copy()\n    temp_df['Date'] = pd.to_datetime(temp_df['Year'], format='%Y')\n    temp_df = temp_df[['Date', 'LP', 'NGDPDPC']]\n    temp_df = temp_df.set_index('Date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['ISO3'] = iso3\n    temp_df['Year'] = temp_df['Date'].dt.year \n    dfs.append(temp_df)\n    \n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Filter nulls and order\ndf = df.sort_values(by=['Year', 'NGDPDPC'])\n\n# Calculate 'left accrual widths'\ndf['LP_Cum'] = df.groupby('Date')['LP'].cumsum()\ndf['LP_Per'] = df['LP'] / df.groupby('Date')['LP'].transform('sum')\ndf['LP_Cum_Per'] = df['LP_Cum'] / df.groupby('Date')['LP_Cum'].transform('max')\ndf['Left'] = df['LP_Cum_Per'] - df['LP_Per']\n\n# Calculate GDP Average weighted by Population and partitioned by Year\ndf['AVG_Weight'] = df.groupby('Date')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\n\n# Add a total GDP column and cummulative it\ndf['GDP'] = df['NGDPDPC'] * df['LP']\ndf['GDPcum'] = df.groupby('Date')['GDP'].cumsum()\ndf['GDP_Per'] = df['GDP'] / df.groupby('Date')['GDP'].transform('sum')\ndf['NGDPDPC_Change'] = ((df['NGDPDPC'] / df.groupby('ISO3')['NGDPDPC'].transform('first')) - 1) * 100\n\n# Copy a df sample to calculate a median\ndf_sample = df.copy()\ncolumns = df.columns\ndf_sample = np.repeat(df_sample.values, df_sample['LP'].astype(int), axis=0)\ndf_sample = pd.DataFrame(df_sample, columns=columns)\ndf_sample.dropna(subset=['NGDPDPC'], inplace=True)\ndf_sample['NGDPDPC'] = pd.to_numeric(df_sample['NGDPDPC'], errors='coerce')\ndf_sample['GDPcum'] = df_sample.groupby('Date')['NGDPDPC'].transform('cumsum')\n\n# Function to get median row\ndef medianrow(group):\n    medianrow = len(group) // 2  # Índice de la mitad\n    return group.iloc[medianrow]\ndf_sample = df_sample.groupby('Date').apply(medianrow).reset_index(drop=True)\n\n# Transform columns\ndf_sample = df_sample[['Date', 'NGDPDPC', 'GDPcum']].reset_index(drop=True)\ndf_sample = df_sample.rename(columns={'NGDPDPC': 'Median', 'GDPcum': 'Median_Total'})\n\n# Merge queries\ndf = df.merge(df_sample, how='left', on='Date')\n\n# Add percentage bottom 50\ndf['Median_Total_Per'] = df['Median_Total'] / df.groupby('Date')['GDP'].transform('sum')\n\nprint(df)\n \n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(16, 9))\n\n# Create a palette\npalette = sns.color_palette(\"coolwarm\", as_cmap=True).reversed()\n\n# Function to refresh animation\ndef update(date):\n    plt.clf()\n    subset = df[df['Date'] == date]\n    subset_usa = subset[subset['ISO3'] == 'USA'].copy()\n    \n    # Normalize GDPcum in a range [0, 1]\n    gdp_min = subset['GDPcum'].min()\n    gdp_max = subset_usa['GDPcum'].max()\n    norm = plt.Normalize(gdp_min, gdp_max)\n    colors = palette(norm(subset['GDPcum']))\n    \n    # Create a Matplotlib plot\n    bars = plt.bar(subset['Left'], subset['NGDPDPC'], width=subset['LP_Per'], \n            color=colors, alpha=1, align='edge', edgecolor='grey', linewidth=0.1)\n    \n    # Configuration grid and labels\n    plt.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    plt.text(0, 1.02, 'Evolution of Countries from 1960 to 2029', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    plt.xlim(0, subset['LP_Cum_Per'].max())\n    plt.ylim(0, subset_usa['NGDPDPC'].max() * 1.05)\n    plt.grid(axis='x')\n    plt.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    plt.xlabel('Cumulative Global Population (%)', fontsize=10, fontweight='bold')\n    plt.ylabel('GDP per capita (US$)', fontsize=10, fontweight='bold')\n    plt.tick_params(axis='x', labelsize=9)\n    plt.tick_params(axis='y', labelsize=9)\n    plt.gca().xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x*100):,}%'))\n    plt.gca().yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(round(x, -3)):,}'))\n    plt.xticks(np.linspace(0, subset['LP_Cum_Per'].max(), 5))\n    plt.yticks(np.linspace(0, subset_usa['NGDPDPC'].max() * 1.05, 8))\n        \n    # Add Labels to relevant countries\n    for bar, value, country in zip(bars, subset['GDP'], subset['ISO3']):\n        if country in ['CHN', 'IND', 'USA', 'IDN', 'PAK', 'NGA', 'BRA', 'BGD', 'RUS', 'MEX', 'JPN', 'VNM', 'DEU', 'GBR']:\n            plt.gca().text(bar.get_x() + bar.get_width()/2, bar.get_height(),\n                        f'{country}\\n{''}', ha='center', va='bottom', fontsize=7, color='grey')\n\n    # Add Median Line and Label\n    median = subset['Median'].max()\n    median_total = subset.iloc[0]['Median_Total']\n    median_total_per = subset.iloc[0]['Median_Total_Per']\n    maxis = subset_usa['NGDPDPC'].max()\n    \n    plt.axhline(\n        y=median,\n        color='darkred', \n        linestyle='--', \n        linewidth=0.5)\n\n    plt.text(\n        x=subset['Left'].max() * 0.02,\n        y=median + (maxis * 0.06),\n        s=f'GDP Capita Median: {median:,.0f}',\n        color='darkred',\n        verticalalignment='bottom',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold') \n\n    plt.gca().text(\n                subset['Left'].max() * 0.02,\n                median + (maxis * 0.04),\n                f'Bottom 50 - Total GDP: {median_total:,.0f} MM ({median_total_per * 100:.2f}%)', \n                ha='left', va='center', \n                fontsize=9, \n                color='#737373')\n    \n    # Add USA Line and Label\n    pibc_usa = subset_usa.iloc[0]['NGDPDPC']\n    pib_usa = subset_usa.iloc[0]['GDP']\n    pib_usa_per = subset_usa.iloc[0]['GDP_Per']\n    \n    plt.axhline(\n        y=pibc_usa, \n        color='darkblue', \n        linestyle='--', \n        linewidth=0.5)\n    \n    plt.text(\n        x=subset['Left'].max() * 0.02,\n        y=pibc_usa * 0.95,\n        s=f'GDP Capita USA: {pibc_usa:,.0f}',\n        color='darkblue',\n        fontsize=10,\n        verticalalignment='bottom',\n        horizontalalignment='left',\n        weight='bold')\n\n    plt.gca().text(\n                subset['Left'].max() * 0.02,\n                pibc_usa * 0.93,\n                f'USA - Total GDP: {pib_usa:,.0f} MM ({pib_usa_per * 100:.2f}%)', \n                ha='left', va='center', \n                fontsize=9, \n                color='#737373')\n\n    # Cover countries going outside plot\n    formatted_date = date.strftime('%Y-%m') \n    plt.text(1, 1.15, f'{formatted_date}',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='white',\n             bbox=dict(facecolor='white', edgecolor='none', boxstyle='square,pad=1'))\n\n    # Add Year label\n    plt.text(1, 1.06, f'{formatted_date}',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='#D3D3D3',\n             bbox=dict(facecolor='white', edgecolor='none', boxstyle='square,pad=0.3'))\n    \n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: IMF World Economic Outlook Database, 2024 | World Bank national accounts data, and OECD National Accounts data files.', \n            transform=plt.gca().transAxes, \n            fontsize=8, \n            color='gray')\n    \n    # Add author\n    plt.text(1, -0.1, '@guillemmaya.com', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='#212121', \n         ha='right')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n             transform=ax.transAxes,\n             fontsize=12, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n             transform=ax.transAxes,\n             fontsize=12, fontweight='bold', color='darkblue', va='center')\n\n# Configurate animation\ndates = sorted(df['Date'].unique())\nani = animation.FuncAnimation(fig, update, frames=dates, repeat=False, interval=500, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guill/Downloads/FIG_GDP_Capita_Bars_1960.webp', writer='imagemagick', fps=15)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202508-wid-beta-evolution/index.html",
    "href": "posts/202508-wid-beta-evolution/index.html",
    "title": "Capital is Back: From Labor to Capital in the Modern Economy",
    "section": "",
    "text": "The chart illustration the evolution of thel wealth-income ratio from 1980 to 2023 highlights the interplay between wealth accumulation and income generation over last five decades. It reveals a clear upward trend, reflecting the disproportionate growth of wealth relative to income, particularly in recent decades. This relationship is largely determined by the growth of the economy relative to the growth of capital. When capital grows at a faster rate than the economy, wealth concentrates disproportionately, amplifying disparities and altering the balance of economic power.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patheffects as patheffects\nimport matplotlib.font_manager as fm\nimport matplotlib.image as mpimg\nfrom io import BytesIO\n\n# Extract Data (Countries)\n# ===================================================\n# Extract JSON to dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Extract Data (WID)\n# ===================================================\n# Extract PARQUET to dataframe\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/master/Data/WID_Values.parquet\"\ndf = pd.read_parquet(url, engine=\"pyarrow\")\n\n# Transform Data\n# ===================================================\n# Filter nulls and countries\ndf = df[df['wiratio'].notna()]\ndf = pd.merge(df, df_countries, left_on='country', right_on='ISO2', how='inner')\n\n# Rename columns\ndf = df.rename(\n        columns={\n            'Country_Abr': 'country_name',\n            'wiratio': 'beta'\n        }\n    )\n\n# Filter countries have data post 1980\ndfx = df.loc[df['year'] == 1980, 'country']\ndf = df[df['country'].isin(dfx)]\ndf = df[df['year'] &gt;= 1980]\ndf = df[df['Analytical'] == 'Advanced Economies']\n\n# Dataframe countries\ndfc = df[df['country'].isin(['CN', 'US', 'FR', 'DE', 'ES'])]\n\n# Select columns and order\ndf = df[['year', 'country', 'country_name', 'beta']]\n\nprint(df)\n\n# Visualization Data\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create color dictionaire \npalette = {'CN': '#ffc2c2', 'US': '#c2d2ff', 'FR': '#c2ffcb', 'DE': '#e5c2ff', 'ES': '#fffac2'}\n\n# Create line plots\nplt.figure(figsize=(12, 8))\nsns.lineplot(data=df, x='year', y='beta', hue='country', linewidth=0.3, alpha=0.5, palette=['gray'], legend=False)\nsns.lineplot(data=dfc, x='year', y='beta', hue='country', linewidth=2.25, palette=['black'], legend=False)\nsns.lineplot(data=dfc, x='year', y='beta', hue='country', linewidth=1.5, palette=palette, legend=False)\n\n# Custom plot\nplt.text(0, 1.08, 'Capital is back', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, 'Wealth-Income Ratios in Advanced Economies 1980-2023', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlabel('Year', fontsize=10, fontweight='bold')\nplt.ylabel('Wealth-Income Ratio', fontsize=10, fontweight='bold')\nplt.grid(axis='x', alpha=0.7, linestyle=':')\nplt.ylim(0, 12)\nplt.xlim(1980, 2026)\nplt.xticks(range(1980, 2026, 10))\nplt.tight_layout()\n\n# Delete spines\nfor spine in [\"top\", \"right\"]:\n    plt.gca().spines[spine].set_visible(False)\n\n# Add Data Source\nplt.text(0, -0.08, 'Data Source: World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.1, 'Notes: Wealth-Income Ratio is the division of national wealth by national income.', \n    transform=plt.gca().transAxes, \n    fontsize=7,\n    fontstyle='italic',\n    color='gray')\n\n # Add Year label\nformatted_date = 2023\nplt.text(1, 1.08, f'{formatted_date}',\n    transform=plt.gca().transAxes,\n    fontsize=20, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Legend values\nbeta_cn = round(df[(df['country'] == 'CN') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_de = round(df[(df['country'] == 'DE') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_es = round(df[(df['country'] == 'ES') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_fr = round(df[(df['country'] == 'FR') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_us = round(df[(df['country'] == 'US') & (df['year'] == 2023)]['beta'].values[0], 1)\n\n# Legend lines\nline1 = mlines.Line2D([], [], color=palette['CN'], label=f'China: {beta_cn}', linewidth=2)\nline2 = mlines.Line2D([], [], color=palette['DE'], label=f'Germany: {beta_de}', linewidth=2)\nline3 = mlines.Line2D([], [], color=palette['ES'], label=f'Spain: {beta_es}', linewidth=2)\nline4 = mlines.Line2D([], [], color=palette['FR'], label=f'France: {beta_fr}', linewidth=2)\nline5 = mlines.Line2D([], [], color=palette['US'], label=f'USA: {beta_us}', linewidth=2)\nline6 = mlines.Line2D([], [], color='grey', label=f'Advanced economies', linewidth=1)\nline1.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline2.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline3.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline4.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline5.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\n\n# Legend plot\nplt.legend(handles=[line1, line2, line3, line4, line5, line6], title='Countries', fontsize=9, title_fontproperties=fm.FontProperties(weight='bold'))\n\n# Define flags\nflag_urls = {\n    'CN': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/CN.png',\n    'US': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/US.png',\n    'FR': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/FR.png',\n    'ES': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/ES.png',\n    'DE': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/DE.png'\n}\n\n# Load flags\nflags = {country: mpimg.imread(BytesIO(requests.get(url).content)) for country, url in flag_urls.items()}\n\n# Add flags\nyear = 2023\n# Adjust flags items\nfor country, flag in flags.items():\n    # Find beta for each country\n    beta_value = df[(df['country'] == country) & (df['year'] == year)]['beta'].values[0]\n    \n    if country == 'CN':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'DE':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'ES':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'FR':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.4, beta_value + 0], alpha=0.7)\n    elif country == 'US':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.4, beta_value + 0], alpha=0.7)\n\n# Save the animation :)\nplt.savefig(\"C:/Users/guill/Downloads/FIG_WID_Beta_Evolution.png\", dpi=300, bbox_inches='tight') \n\n# Show plot\nplt.show()"
  },
  {
    "objectID": "posts/202508-wid-beta-evolution/index.html#summary",
    "href": "posts/202508-wid-beta-evolution/index.html#summary",
    "title": "Capital is Back: From Labor to Capital in the Modern Economy",
    "section": "",
    "text": "The chart illustration the evolution of thel wealth-income ratio from 1980 to 2023 highlights the interplay between wealth accumulation and income generation over last five decades. It reveals a clear upward trend, reflecting the disproportionate growth of wealth relative to income, particularly in recent decades. This relationship is largely determined by the growth of the economy relative to the growth of capital. When capital grows at a faster rate than the economy, wealth concentrates disproportionately, amplifying disparities and altering the balance of economic power.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patheffects as patheffects\nimport matplotlib.font_manager as fm\nimport matplotlib.image as mpimg\nfrom io import BytesIO\n\n# Extract Data (Countries)\n# ===================================================\n# Extract JSON to dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Extract Data (WID)\n# ===================================================\n# Extract PARQUET to dataframe\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/master/Data/WID_Values.parquet\"\ndf = pd.read_parquet(url, engine=\"pyarrow\")\n\n# Transform Data\n# ===================================================\n# Filter nulls and countries\ndf = df[df['wiratio'].notna()]\ndf = pd.merge(df, df_countries, left_on='country', right_on='ISO2', how='inner')\n\n# Rename columns\ndf = df.rename(\n        columns={\n            'Country_Abr': 'country_name',\n            'wiratio': 'beta'\n        }\n    )\n\n# Filter countries have data post 1980\ndfx = df.loc[df['year'] == 1980, 'country']\ndf = df[df['country'].isin(dfx)]\ndf = df[df['year'] &gt;= 1980]\ndf = df[df['Analytical'] == 'Advanced Economies']\n\n# Dataframe countries\ndfc = df[df['country'].isin(['CN', 'US', 'FR', 'DE', 'ES'])]\n\n# Select columns and order\ndf = df[['year', 'country', 'country_name', 'beta']]\n\nprint(df)\n\n# Visualization Data\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create color dictionaire \npalette = {'CN': '#ffc2c2', 'US': '#c2d2ff', 'FR': '#c2ffcb', 'DE': '#e5c2ff', 'ES': '#fffac2'}\n\n# Create line plots\nplt.figure(figsize=(12, 8))\nsns.lineplot(data=df, x='year', y='beta', hue='country', linewidth=0.3, alpha=0.5, palette=['gray'], legend=False)\nsns.lineplot(data=dfc, x='year', y='beta', hue='country', linewidth=2.25, palette=['black'], legend=False)\nsns.lineplot(data=dfc, x='year', y='beta', hue='country', linewidth=1.5, palette=palette, legend=False)\n\n# Custom plot\nplt.text(0, 1.08, 'Capital is back', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, 'Wealth-Income Ratios in Advanced Economies 1980-2023', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlabel('Year', fontsize=10, fontweight='bold')\nplt.ylabel('Wealth-Income Ratio', fontsize=10, fontweight='bold')\nplt.grid(axis='x', alpha=0.7, linestyle=':')\nplt.ylim(0, 12)\nplt.xlim(1980, 2026)\nplt.xticks(range(1980, 2026, 10))\nplt.tight_layout()\n\n# Delete spines\nfor spine in [\"top\", \"right\"]:\n    plt.gca().spines[spine].set_visible(False)\n\n# Add Data Source\nplt.text(0, -0.08, 'Data Source: World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.1, 'Notes: Wealth-Income Ratio is the division of national wealth by national income.', \n    transform=plt.gca().transAxes, \n    fontsize=7,\n    fontstyle='italic',\n    color='gray')\n\n # Add Year label\nformatted_date = 2023\nplt.text(1, 1.08, f'{formatted_date}',\n    transform=plt.gca().transAxes,\n    fontsize=20, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Legend values\nbeta_cn = round(df[(df['country'] == 'CN') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_de = round(df[(df['country'] == 'DE') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_es = round(df[(df['country'] == 'ES') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_fr = round(df[(df['country'] == 'FR') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_us = round(df[(df['country'] == 'US') & (df['year'] == 2023)]['beta'].values[0], 1)\n\n# Legend lines\nline1 = mlines.Line2D([], [], color=palette['CN'], label=f'China: {beta_cn}', linewidth=2)\nline2 = mlines.Line2D([], [], color=palette['DE'], label=f'Germany: {beta_de}', linewidth=2)\nline3 = mlines.Line2D([], [], color=palette['ES'], label=f'Spain: {beta_es}', linewidth=2)\nline4 = mlines.Line2D([], [], color=palette['FR'], label=f'France: {beta_fr}', linewidth=2)\nline5 = mlines.Line2D([], [], color=palette['US'], label=f'USA: {beta_us}', linewidth=2)\nline6 = mlines.Line2D([], [], color='grey', label=f'Advanced economies', linewidth=1)\nline1.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline2.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline3.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline4.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline5.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\n\n# Legend plot\nplt.legend(handles=[line1, line2, line3, line4, line5, line6], title='Countries', fontsize=9, title_fontproperties=fm.FontProperties(weight='bold'))\n\n# Define flags\nflag_urls = {\n    'CN': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/CN.png',\n    'US': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/US.png',\n    'FR': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/FR.png',\n    'ES': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/ES.png',\n    'DE': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/DE.png'\n}\n\n# Load flags\nflags = {country: mpimg.imread(BytesIO(requests.get(url).content)) for country, url in flag_urls.items()}\n\n# Add flags\nyear = 2023\n# Adjust flags items\nfor country, flag in flags.items():\n    # Find beta for each country\n    beta_value = df[(df['country'] == country) & (df['year'] == year)]['beta'].values[0]\n    \n    if country == 'CN':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'DE':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'ES':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'FR':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.4, beta_value + 0], alpha=0.7)\n    elif country == 'US':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.4, beta_value + 0], alpha=0.7)\n\n# Save the animation :)\nplt.savefig(\"C:/Users/guill/Downloads/FIG_WID_Beta_Evolution.png\", dpi=300, bbox_inches='tight') \n\n# Show plot\nplt.show()"
  },
  {
    "objectID": "posts/202510-globalization-eras/index.html",
    "href": "posts/202510-globalization-eras/index.html",
    "title": "Globalization Eras",
    "section": "",
    "text": "The chart illustrates the level of openness in global trade since the onset of globalization, with each period marked by unique economic conditions and distinct international relations.\n\n\nCode\n# Libraries\n# ============================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport wbgapi as wb\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Extraction Data OURWORLDINDATA\n# ============================================\n# Get data\ndfo = pd.read_csv(\"https://ourworldindata.org/grapher/globalization-over-5-centuries.csv?v=1&csvType=full&useColumnShortNames=true\", storage_options = {'User-Agent': 'Our World In Data data fetch/1.0'})\ndfo = dfo[dfo['Code'] == 'OWID_WRL']\n\n# Rename columns\ndfo = dfo.rename(columns={\n    'Year': 'year',\n    ' World trade based on Maddison (% of GDP) (Klasing and Milionis (2014)) ': 'trade_klasing',\n    'World trade based on own estimates (% of GDP) (Klasing and Milionis (2014)) ': 'trade_klasing_madisson',\n    'ne_trd_gnfs_zs': 'trade_penn',\n    'trade_openness': 'trade_openness_index'\n})\n\n# Trade priority data\ndfo = dfo[['year', 'trade_klasing', 'trade_klasing_madisson', 'trade_penn', 'trade_openness_index']]\ndfo['trade'] = np.where(dfo['trade_openness_index'].notnull(), dfo['trade_openness_index'], \n                        np.where(dfo['trade_penn'].notnull(), dfo['trade_penn'], \n                        np.where(dfo['trade_klasing_madisson'].notnull(), dfo['trade_klasing_madisson'], \n                        dfo['trade_klasing'])))\n\n# Prepare dfo\ndfo = dfo[['year', 'trade']]\ndfo = dfo[dfo['trade'].notnull()]\ndfo = dfo.sort_values(by='year').reset_index(drop=True)\n\n# Extraction Data COUNTRIES\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndfc = pd.DataFrame(data)\ndfc = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = dfc.rename(columns={'index': 'ISO3'})\n\n# Extraction Data WORLDBANK\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.MKTP.CD', 'NE.EXP.GNFS.CD', 'NE.IMP.GNFS.CD']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1970, 2024)\ndata = wb.data.DataFrame(indicator, 'WLD', data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndfw = data.rename(columns={\n    'time': 'year',\n    'economy': 'iso',\n    'NY.GDP.MKTP.CD': 'gdp',\n    'NE.EXP.GNFS.CD': 'exports',\n    'NE.IMP.GNFS.CD': 'imports'\n})\n\ndfw['comerce'] = dfw['imports'] + dfw['exports']\ndfw = dfw[['year', 'gdp', 'comerce']].groupby('year', as_index=False).sum()\ndfw['trade'] = dfw['comerce'] / dfw['gdp'] * 100\ndfw = dfw[['year', 'trade']]\n\n# Unify DF\n# ========================================================\n# Filter dataframes\ndfo = dfo[dfo['year'] &lt; 1970]\ndfw = dfw[dfw['year'] &gt; 1970]\n\n# Filter dataframes\ndf = pd.concat([dfo, dfw], ignore_index=True)\n\n# Divide dataframes\ndf_1870_1914 = df[(df['year'] &gt;= 1870) & (df['year'] &lt;= 1915)]\ndf_1915_1945 = df[(df['year'] &gt;= 1915) & (df['year'] &lt;= 1945)]\ndf_1945_1980 = df[(df['year'] &gt;= 1945) & (df['year'] &lt;= 1980)]\ndf_1980_2008 = df[(df['year'] &gt;= 1980) & (df['year'] &lt;= 2008)]\ndf_2008_2023 = df[(df['year'] &gt;= 2008) & (df['year'] &lt;= 2023)]\n\nprint(df)\n\n# Visualization Data\n# ============================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Create a figure\nax = plt.figure(figsize=(10, 6))\n\n# Stackplot for each dataframe\nplt.stackplot(df_1870_1914['year'], df_1870_1914['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_1915_1945['year'], df_1915_1945['trade'], color='#d92724', alpha=1)\nplt.stackplot(df_1945_1980['year'], df_1945_1980['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_1980_2008['year'], df_1980_2008['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_2008_2023['year'], df_2008_2023['trade'], color='#d92724', alpha=1)\n\n# Add vertical lines\nplt.axvline(x=1915, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=1945, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=1980, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=2008, color='white', linestyle='--', linewidth=0.75)\n\n# Add title and labels\nplt.text(0, 1.08, f'Eras of globalization', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, 'Trade openess slowed following the global financial crisis.', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.01, '(sum of exports and imports as percent of GDP)', fontsize=9, fontweight='light', color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlim(1871, 2023)\nplt.ylim(0, 65)\nplt.xticks([1870, 1915, 1945, 1980, 2008])\nplt.gca().yaxis.grid(True, linestyle='-', alpha=0.4)\n\n# Delete spines\nfor spine in [\"top\", \"left\", \"right\"]:\n    plt.gca().spines[spine].set_visible(False)\n\n# Industrialization\nplt.text(\n    x=df_1870_1914['year'].mean(),\n    y=3,\n    s=\"1870-1914\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1870_1914['year'].mean(),\n    y=1,\n    s=\"Industrialization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Wars and proteccionism\nplt.text(\n    x=df_1915_1945['year'].mean(),\n    y=3,\n    s=\"1915-1945\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1915_1945['year'].mean(),\n    y=1,\n    s=\"Wars, proteccionism\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Fixed exchanges rates\nplt.text(\n    x=df_1945_1980['year'].mean(),\n    y=3,\n    s=\"1945-1980\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1945_1980['year'].mean(),\n    y=1,\n    s=\"Fixed exchanges rates\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Liberization\nplt.text(\n    x=df_1980_2008['year'].mean(),\n    y=3,\n    s=\"1980-2008\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1980_2008['year'].mean(),\n    y=1,\n    s=\"Liberization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Slowbalization\nplt.text(\n    x=df_2008_2023['year'].mean() +2,\n    y=3,\n    s=\"2008-current\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom',\n    rotation=90\n)\nplt.text(\n    x=df_2008_2023['year'].mean() +5,\n    y=1,\n    s=\"Slowbalization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom',\n    rotation=90\n)\n\n# Add Data Source\nplt.text(0, -0.12, 'Data Source: PIIE, Jorda-Schularick-Taylor Macrohistory Database, Penn World Data (10.0), World Bank, and IMF staff calculations.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Show plot!\nplt.show()"
  },
  {
    "objectID": "posts/202510-globalization-eras/index.html#summary",
    "href": "posts/202510-globalization-eras/index.html#summary",
    "title": "Globalization Eras",
    "section": "",
    "text": "The chart illustrates the level of openness in global trade since the onset of globalization, with each period marked by unique economic conditions and distinct international relations.\n\n\nCode\n# Libraries\n# ============================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport wbgapi as wb\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Extraction Data OURWORLDINDATA\n# ============================================\n# Get data\ndfo = pd.read_csv(\"https://ourworldindata.org/grapher/globalization-over-5-centuries.csv?v=1&csvType=full&useColumnShortNames=true\", storage_options = {'User-Agent': 'Our World In Data data fetch/1.0'})\ndfo = dfo[dfo['Code'] == 'OWID_WRL']\n\n# Rename columns\ndfo = dfo.rename(columns={\n    'Year': 'year',\n    ' World trade based on Maddison (% of GDP) (Klasing and Milionis (2014)) ': 'trade_klasing',\n    'World trade based on own estimates (% of GDP) (Klasing and Milionis (2014)) ': 'trade_klasing_madisson',\n    'ne_trd_gnfs_zs': 'trade_penn',\n    'trade_openness': 'trade_openness_index'\n})\n\n# Trade priority data\ndfo = dfo[['year', 'trade_klasing', 'trade_klasing_madisson', 'trade_penn', 'trade_openness_index']]\ndfo['trade'] = np.where(dfo['trade_openness_index'].notnull(), dfo['trade_openness_index'], \n                        np.where(dfo['trade_penn'].notnull(), dfo['trade_penn'], \n                        np.where(dfo['trade_klasing_madisson'].notnull(), dfo['trade_klasing_madisson'], \n                        dfo['trade_klasing'])))\n\n# Prepare dfo\ndfo = dfo[['year', 'trade']]\ndfo = dfo[dfo['trade'].notnull()]\ndfo = dfo.sort_values(by='year').reset_index(drop=True)\n\n# Extraction Data COUNTRIES\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndfc = pd.DataFrame(data)\ndfc = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = dfc.rename(columns={'index': 'ISO3'})\n\n# Extraction Data WORLDBANK\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.MKTP.CD', 'NE.EXP.GNFS.CD', 'NE.IMP.GNFS.CD']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1970, 2024)\ndata = wb.data.DataFrame(indicator, 'WLD', data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndfw = data.rename(columns={\n    'time': 'year',\n    'economy': 'iso',\n    'NY.GDP.MKTP.CD': 'gdp',\n    'NE.EXP.GNFS.CD': 'exports',\n    'NE.IMP.GNFS.CD': 'imports'\n})\n\ndfw['comerce'] = dfw['imports'] + dfw['exports']\ndfw = dfw[['year', 'gdp', 'comerce']].groupby('year', as_index=False).sum()\ndfw['trade'] = dfw['comerce'] / dfw['gdp'] * 100\ndfw = dfw[['year', 'trade']]\n\n# Unify DF\n# ========================================================\n# Filter dataframes\ndfo = dfo[dfo['year'] &lt; 1970]\ndfw = dfw[dfw['year'] &gt; 1970]\n\n# Filter dataframes\ndf = pd.concat([dfo, dfw], ignore_index=True)\n\n# Divide dataframes\ndf_1870_1914 = df[(df['year'] &gt;= 1870) & (df['year'] &lt;= 1915)]\ndf_1915_1945 = df[(df['year'] &gt;= 1915) & (df['year'] &lt;= 1945)]\ndf_1945_1980 = df[(df['year'] &gt;= 1945) & (df['year'] &lt;= 1980)]\ndf_1980_2008 = df[(df['year'] &gt;= 1980) & (df['year'] &lt;= 2008)]\ndf_2008_2023 = df[(df['year'] &gt;= 2008) & (df['year'] &lt;= 2023)]\n\nprint(df)\n\n# Visualization Data\n# ============================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Create a figure\nax = plt.figure(figsize=(10, 6))\n\n# Stackplot for each dataframe\nplt.stackplot(df_1870_1914['year'], df_1870_1914['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_1915_1945['year'], df_1915_1945['trade'], color='#d92724', alpha=1)\nplt.stackplot(df_1945_1980['year'], df_1945_1980['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_1980_2008['year'], df_1980_2008['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_2008_2023['year'], df_2008_2023['trade'], color='#d92724', alpha=1)\n\n# Add vertical lines\nplt.axvline(x=1915, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=1945, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=1980, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=2008, color='white', linestyle='--', linewidth=0.75)\n\n# Add title and labels\nplt.text(0, 1.08, f'Eras of globalization', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, 'Trade openess slowed following the global financial crisis.', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.01, '(sum of exports and imports as percent of GDP)', fontsize=9, fontweight='light', color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlim(1871, 2023)\nplt.ylim(0, 65)\nplt.xticks([1870, 1915, 1945, 1980, 2008])\nplt.gca().yaxis.grid(True, linestyle='-', alpha=0.4)\n\n# Delete spines\nfor spine in [\"top\", \"left\", \"right\"]:\n    plt.gca().spines[spine].set_visible(False)\n\n# Industrialization\nplt.text(\n    x=df_1870_1914['year'].mean(),\n    y=3,\n    s=\"1870-1914\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1870_1914['year'].mean(),\n    y=1,\n    s=\"Industrialization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Wars and proteccionism\nplt.text(\n    x=df_1915_1945['year'].mean(),\n    y=3,\n    s=\"1915-1945\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1915_1945['year'].mean(),\n    y=1,\n    s=\"Wars, proteccionism\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Fixed exchanges rates\nplt.text(\n    x=df_1945_1980['year'].mean(),\n    y=3,\n    s=\"1945-1980\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1945_1980['year'].mean(),\n    y=1,\n    s=\"Fixed exchanges rates\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Liberization\nplt.text(\n    x=df_1980_2008['year'].mean(),\n    y=3,\n    s=\"1980-2008\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1980_2008['year'].mean(),\n    y=1,\n    s=\"Liberization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Slowbalization\nplt.text(\n    x=df_2008_2023['year'].mean() +2,\n    y=3,\n    s=\"2008-current\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom',\n    rotation=90\n)\nplt.text(\n    x=df_2008_2023['year'].mean() +5,\n    y=1,\n    s=\"Slowbalization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom',\n    rotation=90\n)\n\n# Add Data Source\nplt.text(0, -0.12, 'Data Source: PIIE, Jorda-Schularick-Taylor Macrohistory Database, Penn World Data (10.0), World Bank, and IMF staff calculations.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Show plot!\nplt.show()"
  },
  {
    "objectID": "posts/202512-temperature-anomalies/index.html",
    "href": "posts/202512-temperature-anomalies/index.html",
    "title": "Global temperature anomalies",
    "section": "",
    "text": "Global temperature anomalies indicate how Earth’s surface temperature deviates from a historical average, providing crucial insights into climate change. Persistent positive anomalies signal a warming trend driven by greenhouse gas emissions, while negative anomalies are less frequent in recent decades. By tracking these variations, scientists can assess long-term climate patterns, identify extreme weather risks, and evaluate the impact of human activities on global temperatures.\n\n\nCode\n# Libraries\n# =========================================\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib.ticker as ticker\nimport os\n\n# Data Extraction (temperature)\n# =========================================\n# URL NASA GISS global temperature\nurl = \"https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv\"\ndft = pd.read_csv(url, skiprows=1)\n\n# Data Extraction (co2)\n# =========================================\n# URL del archivo CSV\nurl = \"https://zenodo.org/records/13981696/files/GCB2024v17_MtCO2_flat.csv?download=1\"\ndfc = pd.read_csv(url)\n\n# Data Manipulation (temperature)\n# =========================================\n# Select columns\ndft = dft[[\"Year\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"J-D\"]]\n\n# Rename columns\ndft.columns = dft.columns.str.lower()\ndft = dft.rename(columns=lambda x: x.lower())\n\n# Unpivot columns\ndft = dft.melt(id_vars=[\"year\"], var_name=\"month\", value_name=\"value\")\ndft = dft[dft[\"month\"] == \"j-d\"]\n\n# Data Manipulation (co2)\n# =========================================\n# Transform Data\ndfc = dfc[dfc['ISO 3166-1 alpha-3'] == 'WLD']\ndfc.rename(columns={'Year': 'year', 'ISO 3166-1 alpha-3': 'iso', 'Total': 'co2'}, inplace=True)\ndfc = dfc[['year', 'iso', 'co2']]\n\n# Merge dataframes\n# =========================================\ndf = dft.merge(dfc, on='year', how='left')\ndf['value'] = pd.to_numeric(df['value'], errors='coerce')\ndf = df[df['value'].notna()]\n\nprint(df)\n\n# Data Visualization\n# =========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Define a color map\ncmap = plt.get_cmap('coolwarm')\nnorm = plt.Normalize(-0.5, 1)\n\n# Create figure and plot\nfig, ax1 = plt.subplots(figsize=(10, 5))\nax2 = ax1.twinx()\nbars =ax1.bar(df['year'], df['value'], color=cmap(norm(df['value'])), width=1, edgecolor='none')\nline = ax2.plot(df['year'], df['co2'], label='CO2', color='#262626', linestyle=':', linewidth=1)\n\n# Add title and labels\nax1.text(0, 1.12, f'Global Temperature Anomaly', fontsize=16, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.07, 'Compared with mid -20th century (°C)', fontsize=11, color='#262626', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.02, r'(In contrast with CO$_2$ emissions)', fontsize=9, fontweight='light', color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlim(1877, 2027)\nax1.axhline(y=0, color='black', linestyle='-', linewidth=0.75)\nyticks = [-0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25]\nytick_labels = [f'{y:+.2f}' if y != 0 else '0' for y in yticks]\nax1.set_yticks(yticks, ytick_labels)\nax1.set_yticklabels(ytick_labels, fontsize=9)\nax1.set_xticks([1880, 1890, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020])\nax1.tick_params(axis='x', labelsize=9)\nax1.yaxis.set_ticks_position('none')\nax1.grid(axis='y', linestyle='-', color='#262626', linewidth=0.1, alpha=0.6)\nax2.set_ylim(0, 40000)\nymin, ymax = ax2.get_ylim()\nyticks = np.linspace(ymin, ymax, 8)\nax2.set_yticks(yticks)\nyticks_rounded = np.round(yticks / 5000) * 5000\nyticks_k = [f\"{int(tick / 1000)}Mt\" for tick in yticks_rounded]\nax2.set_yticklabels(yticks_k)\nax2.tick_params(axis='y', labelsize=9)\nax2.yaxis.set_ticks_position('none')\n\n# Add column labels\nfor i, year in enumerate(df['year']):\n    if year in [1973, 1990, 1998, 2010, 2016, 2024]:\n        # Check positive and negative values\n        symbol = \"+\" if df['value'].iloc[i] &gt;= 0 else \"-\"\n        value_text = f\"{symbol}{abs(df['value'].iloc[i]):,.2f}\"\n        \n        # Recent value bold\n        fontweight = 'bold' if year == df['year'].max() else 'normal'\n\n        # Set the offset based on the year\n        offset = 0.11 if year in [1973, 1990] else 0.05\n\n        # Add label\n        ax1.text(year, df['value'].iloc[i] + offset, value_text,\n                 ha='center', va='bottom', fontsize=7, color='#363636', fontweight=fontweight)\n\n# Remove spines\nfor ax in [ax1, ax2]:\n    for spine in [\"top\", \"bottom\"]:\n        ax.spines[spine].set_visible(False)\n\n# Add Data Source\nspaces = ' ' * 23\nax1.text(0, -0.16, f'{spaces}NASA Goddard Institute for Space Studies\\nThe Global Carbon Project\\'s fossil CO2 emissions dataset', \n         transform=ax1.transAxes, \n         fontsize=8, \n         color='gray', \n         ha='left', \n         family='sans-serif')\n\n# Add Data Source bold\nax1.text(0, -0.16, 'Data Source:\\n ', \n         transform=ax1.transAxes, \n         fontsize=8, \n         color='gray', \n         ha='left', \n         family='sans-serif', \n         fontweight='bold')\n\n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.12, f'{formatted_date}',\n    transform=ax1.transAxes, \n    fontsize=18, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Celsius\nax1.text(-0.04, -0.08, '°C', \n    transform=ax1.transAxes, \n    fontsize=10, \n    fontweight='bold',\n    color='black')\n\n# Add CO2\nax1.text(1.01, -0.08, r'CO$_2$', \n    transform=ax1.transAxes, \n    fontsize=10, \n    fontweight='bold',\n    color='black')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_NASA_Temperature_Anomalies\")\nplt.savefig(filename + \".png\", format='png', bbox_inches='tight')\n\n# Show the plot!\nplt.show()"
  },
  {
    "objectID": "posts/202512-temperature-anomalies/index.html#summary",
    "href": "posts/202512-temperature-anomalies/index.html#summary",
    "title": "Global temperature anomalies",
    "section": "",
    "text": "Global temperature anomalies indicate how Earth’s surface temperature deviates from a historical average, providing crucial insights into climate change. Persistent positive anomalies signal a warming trend driven by greenhouse gas emissions, while negative anomalies are less frequent in recent decades. By tracking these variations, scientists can assess long-term climate patterns, identify extreme weather risks, and evaluate the impact of human activities on global temperatures.\n\n\nCode\n# Libraries\n# =========================================\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib.ticker as ticker\nimport os\n\n# Data Extraction (temperature)\n# =========================================\n# URL NASA GISS global temperature\nurl = \"https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv\"\ndft = pd.read_csv(url, skiprows=1)\n\n# Data Extraction (co2)\n# =========================================\n# URL del archivo CSV\nurl = \"https://zenodo.org/records/13981696/files/GCB2024v17_MtCO2_flat.csv?download=1\"\ndfc = pd.read_csv(url)\n\n# Data Manipulation (temperature)\n# =========================================\n# Select columns\ndft = dft[[\"Year\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"J-D\"]]\n\n# Rename columns\ndft.columns = dft.columns.str.lower()\ndft = dft.rename(columns=lambda x: x.lower())\n\n# Unpivot columns\ndft = dft.melt(id_vars=[\"year\"], var_name=\"month\", value_name=\"value\")\ndft = dft[dft[\"month\"] == \"j-d\"]\n\n# Data Manipulation (co2)\n# =========================================\n# Transform Data\ndfc = dfc[dfc['ISO 3166-1 alpha-3'] == 'WLD']\ndfc.rename(columns={'Year': 'year', 'ISO 3166-1 alpha-3': 'iso', 'Total': 'co2'}, inplace=True)\ndfc = dfc[['year', 'iso', 'co2']]\n\n# Merge dataframes\n# =========================================\ndf = dft.merge(dfc, on='year', how='left')\ndf['value'] = pd.to_numeric(df['value'], errors='coerce')\ndf = df[df['value'].notna()]\n\nprint(df)\n\n# Data Visualization\n# =========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Define a color map\ncmap = plt.get_cmap('coolwarm')\nnorm = plt.Normalize(-0.5, 1)\n\n# Create figure and plot\nfig, ax1 = plt.subplots(figsize=(10, 5))\nax2 = ax1.twinx()\nbars =ax1.bar(df['year'], df['value'], color=cmap(norm(df['value'])), width=1, edgecolor='none')\nline = ax2.plot(df['year'], df['co2'], label='CO2', color='#262626', linestyle=':', linewidth=1)\n\n# Add title and labels\nax1.text(0, 1.12, f'Global Temperature Anomaly', fontsize=16, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.07, 'Compared with mid -20th century (°C)', fontsize=11, color='#262626', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.02, r'(In contrast with CO$_2$ emissions)', fontsize=9, fontweight='light', color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlim(1877, 2027)\nax1.axhline(y=0, color='black', linestyle='-', linewidth=0.75)\nyticks = [-0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25]\nytick_labels = [f'{y:+.2f}' if y != 0 else '0' for y in yticks]\nax1.set_yticks(yticks, ytick_labels)\nax1.set_yticklabels(ytick_labels, fontsize=9)\nax1.set_xticks([1880, 1890, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020])\nax1.tick_params(axis='x', labelsize=9)\nax1.yaxis.set_ticks_position('none')\nax1.grid(axis='y', linestyle='-', color='#262626', linewidth=0.1, alpha=0.6)\nax2.set_ylim(0, 40000)\nymin, ymax = ax2.get_ylim()\nyticks = np.linspace(ymin, ymax, 8)\nax2.set_yticks(yticks)\nyticks_rounded = np.round(yticks / 5000) * 5000\nyticks_k = [f\"{int(tick / 1000)}Mt\" for tick in yticks_rounded]\nax2.set_yticklabels(yticks_k)\nax2.tick_params(axis='y', labelsize=9)\nax2.yaxis.set_ticks_position('none')\n\n# Add column labels\nfor i, year in enumerate(df['year']):\n    if year in [1973, 1990, 1998, 2010, 2016, 2024]:\n        # Check positive and negative values\n        symbol = \"+\" if df['value'].iloc[i] &gt;= 0 else \"-\"\n        value_text = f\"{symbol}{abs(df['value'].iloc[i]):,.2f}\"\n        \n        # Recent value bold\n        fontweight = 'bold' if year == df['year'].max() else 'normal'\n\n        # Set the offset based on the year\n        offset = 0.11 if year in [1973, 1990] else 0.05\n\n        # Add label\n        ax1.text(year, df['value'].iloc[i] + offset, value_text,\n                 ha='center', va='bottom', fontsize=7, color='#363636', fontweight=fontweight)\n\n# Remove spines\nfor ax in [ax1, ax2]:\n    for spine in [\"top\", \"bottom\"]:\n        ax.spines[spine].set_visible(False)\n\n# Add Data Source\nspaces = ' ' * 23\nax1.text(0, -0.16, f'{spaces}NASA Goddard Institute for Space Studies\\nThe Global Carbon Project\\'s fossil CO2 emissions dataset', \n         transform=ax1.transAxes, \n         fontsize=8, \n         color='gray', \n         ha='left', \n         family='sans-serif')\n\n# Add Data Source bold\nax1.text(0, -0.16, 'Data Source:\\n ', \n         transform=ax1.transAxes, \n         fontsize=8, \n         color='gray', \n         ha='left', \n         family='sans-serif', \n         fontweight='bold')\n\n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.12, f'{formatted_date}',\n    transform=ax1.transAxes, \n    fontsize=18, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Celsius\nax1.text(-0.04, -0.08, '°C', \n    transform=ax1.transAxes, \n    fontsize=10, \n    fontweight='bold',\n    color='black')\n\n# Add CO2\nax1.text(1.01, -0.08, r'CO$_2$', \n    transform=ax1.transAxes, \n    fontsize=10, \n    fontweight='bold',\n    color='black')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_NASA_Temperature_Anomalies\")\nplt.savefig(filename + \".png\", format='png', bbox_inches='tight')\n\n# Show the plot!\nplt.show()"
  },
  {
    "objectID": "posts/202602-wid-distribution-countries/index.html",
    "href": "posts/202602-wid-distribution-countries/index.html",
    "title": "Where is the income/wealth distribution concentrated?",
    "section": "",
    "text": "This study analyzes income and wealth distribution data sourced from the World Inequality Database (WID), segmented by country. It highlights the concentration of wealth and income within different nations, providing insights into global economic disparities.\n\n\n\n\n\n\nDistributions blocks 1\n\n\n\n\n\nThe distribution of “Income” and “Wealth” chart is split into two blocks [50-50]:\n     • Bottom 50      • Top 50\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3', 'Country_Abr': 'name'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Carga del archivo Parquet\ndf = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndf = df[df['country'].isin([\"NO\", \"DK\", \"ES\", \"FR\", \"DE\", \"UK\", \"US\", \"IN\", \"CN\", \"JA\", \"AR\", \"RU\", \"QA\", \"CL\", \"BR\", \"CA\", \"AU\", \"KR\", \"MX\"])]\ndf = df[df['year'] == 2021]\ndf['value'] = df['income']\n\n# Grouping by percentiles\ndf[\"group\"] = pd.cut(\n    df[\"percentile\"],\n    bins=[0, 50, 89, 99, 100],\n    labels=[\"bottom50\", \"50-90\", \"90-99\", \"top1\"],\n    include_lowest=True\n)\n\n# Calculate percents\ndf['side'] = np.where(df['group'].isin(['bottom50']), 'left', 'right')\ndf['value'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Select columns\ndf = df[['country', 'group', 'value']]\ndf = df.groupby([\"country\", \"group\"], as_index=False)[\"value\"].sum()\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"group\", values=\"value\").fillna(0).reset_index()\n\n# Merge names\ndf_pivot = df_pivot.merge(df_countries[['ISO2', 'name']], left_on='country', right_on='ISO2', how='inner')\ndf_pivot = df_pivot.drop(columns=['ISO2'])\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['bottom50']\ndf_pivot['total_right'] = df_pivot['50-90'] + df_pivot['90-99'] + df_pivot['top1']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"name\", \"bottom50\", \"50-90\", \"90-99\", \"top1\"]\ndfplot = df_pivot[order]\ndfplot.set_index('name', inplace=True)\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#f15b4c\", \"#537c78\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Where is income distribution concentrated?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07 , f'Income Percentile Breakdown by Country', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Bottom 50', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#f15b4c\")\nplt.text(0.75, 1.02, 'Top 50', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#537c78\")\n\n# Add strict regulation zone\nynum = 5\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.4, 'Countries with progressive tax systems', fontsize=6, fontweight='bold', color=\"gray\")\n\n# Add values for total bottom50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for total top50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for individual bars (top1)\nfor i, (city, center, top9, top1) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"], df_pivot[\"top1\"])):\n    ax.text(center+top9+(top1/2), i, f'{abs(top1):.0f}', va='center', ha='center', fontsize=7, color='grey')\n\n# Add values for individual bars (top9)\nfor i, (city, center, top9) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"])):\n    ax.text(center+(top9/2), i, f'{abs(top9):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, center) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"])):\n    ax.text(center / 2, i, f'{abs(center):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Legend configuration\nplt.plot([], [], label=\"Percentiles: \", color='white')\nplt.legend(\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=7,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.2\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n # Adjust layout\nplt.tight_layout()\n\n# Plot it! :)\nplt.show()\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3', 'Country_Abr': 'name'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Carga del archivo Parquet\ndf = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndf = df[df['country'].isin([\"NO\", \"DK\", \"ES\", \"FR\", \"DE\", \"UK\", \"US\", \"IN\", \"CN\", \"JA\", \"AR\", \"RU\", \"QA\", \"CL\", \"BR\", \"CA\", \"AU\", \"KR\", \"MX\"])]\ndf = df[df['year'] == 2021]\ndf['value'] = df['wealth']\n\n# Grouping by percentiles\ndf[\"group\"] = pd.cut(\n    df[\"percentile\"],\n    bins=[0, 50, 89, 99, 100],\n    labels=[\"bottom50\", \"50-90\", \"90-99\", \"top1\"],\n    include_lowest=True\n)\n\n# Calculate percents\ndf['side'] = np.where(df['group'].isin(['bottom50']), 'left', 'right')\ndf['value'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Select columns\ndf = df[['country', 'group', 'value']]\ndf = df.groupby([\"country\", \"group\"], as_index=False)[\"value\"].sum()\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"group\", values=\"value\").fillna(0).reset_index()\n\n# Merge names\ndf_pivot = df_pivot.merge(df_countries[['ISO2', 'name']], left_on='country', right_on='ISO2', how='inner')\ndf_pivot = df_pivot.drop(columns=['ISO2'])\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['bottom50']\ndf_pivot['total_right'] = df_pivot['50-90'] + df_pivot['90-99'] + df_pivot['top1']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"name\", \"bottom50\", \"50-90\", \"90-99\", \"top1\"]\ndfplot = df_pivot[order]\ndfplot.set_index('name', inplace=True)\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#f15b4c\", \"#537c78\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Where is wealth distribution concentrated?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07 , f'Wealth Percentile Breakdown by Country', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Bottom 50', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#f15b4c\")\nplt.text(0.75, 1.02, 'Top 50', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#537c78\")\n\n# Add strict regulation zone\nynum = 0\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.4, 'Countries with fair distribution on wealth (indeed, no one...)', fontsize=6, fontweight='bold', color=\"gray\")\n\n# Add values for total bottom50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for total top50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for individual bars (top1)\nfor i, (city, center, top9, top1) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"], df_pivot[\"top1\"])):\n    ax.text(center+top9+(top1/2), i, f'{abs(top1):.0f}', va='center', ha='center', fontsize=7, color='grey')\n\n# Add values for individual bars (top9)\nfor i, (city, center, top9) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"])):\n    ax.text(center+(top9/2), i, f'{abs(top9):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, center) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"])):\n    ax.text(center / 2, i, f'{abs(center):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Legend configuration\nplt.plot([], [], label=\"Percentiles: \", color='white')\nplt.legend(\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=7,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.2\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n # Adjust layout\nplt.tight_layout()\n\n# Plot it! :)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDistributions blocks 2\n\n\n\n\n\nThe distribution of “Income” and “Wealth” chart is split into two blocks [90-10]:\n     • Bottom 90      • Top 10\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3', 'Country_Abr': 'name'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Carga del archivo Parquet\ndf = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndf = df[df['country'].isin([\"NO\", \"DK\", \"ES\", \"FR\", \"DE\", \"UK\", \"US\", \"IN\", \"CN\", \"JA\", \"AR\", \"RU\", \"QA\", \"CL\", \"BR\", \"CA\", \"AU\", \"KR\", \"MX\", \"ZA\"])]\ndf = df[df['year'] == 2021]\ndf['value'] = df['income']\n\n# Grouping by percentiles\ndf[\"group\"] = pd.cut(\n    df[\"percentile\"],\n    bins=[0, 50, 89, 99, 100],\n    labels=[\"bottom50\", \"50-90\", \"90-99\", \"top1\"],\n    include_lowest=True\n)\n\n# Calculate percents\ndf['side'] = np.where(df['group'].isin(['bottom50', '50-90']), 'left', 'right')\ndf['value'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Select columns\ndf = df[['country', 'group', 'value']]\ndf = df.groupby([\"country\", \"group\"], as_index=False)[\"value\"].sum()\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"group\", values=\"value\").fillna(0).reset_index()\n\n# Merge names\ndf_pivot = df_pivot.merge(df_countries[['ISO2', 'name']], left_on='country', right_on='ISO2', how='inner')\ndf_pivot = df_pivot.drop(columns=['ISO2'])\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['bottom50'] + df_pivot['50-90']\ndf_pivot['total_right'] = df_pivot['90-99'] + df_pivot['top1']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"name\", \"50-90\", \"bottom50\", \"90-99\", \"top1\"]\ndfplot = df_pivot[order]\ndfplot.set_index('name', inplace=True)\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#537c78\", \"#f15b4c\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Where is income distribution concentrated?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07 , f'Income Percentile Breakdown by Country', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Bottom 90', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#526b69\")\nplt.text(0.75, 1.02, 'Top 10', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#b58231\")\n\n# Add strict regulation zone\nynum = 7\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(+100, ynum-0.4, 'Countries with progressive tax systems', fontsize=6, fontweight='bold', color=\"gray\", ha=\"right\")\n\n# Add values for total bottom50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for total top50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for individual bars (top1)\nfor i, (city, center, top9, top1) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"], df_pivot[\"top1\"])):\n    ax.text(top9+(top1/2), i, f'{abs(top1):.0f}', va='center', ha='center', fontsize=7, color='grey')\n\n# Add values for individual bars (top9)\nfor i, (city, center, top9) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"])):\n    ax.text((top9/2), i, f'{abs(top9):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, bottom50, center) in enumerate(zip(dfplot.index, df_pivot[\"bottom50\"], df_pivot[\"50-90\"])):\n    ax.text(center+(bottom50/2), i, f'{abs(bottom50):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, center) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"])):\n    ax.text((center/2), i, f'{abs(center):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Configurar la leyenda manualmente con cuadrados\nhandles = [\n    mpatches.Patch(color=palette[1], label=\"Bottom 50\", linewidth=2),\n    mpatches.Patch(color=palette[0], label=\"(50-90]\", linewidth=2),\n    mpatches.Patch(color=palette[2], label=\"(90-99]\", linewidth=2),\n    mpatches.Patch(color=palette[3], label=\"Top 1\", linewidth=2)\n]\n\n# Configuración de la leyenda\nplt.legend(\n    handles=handles,\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=4,  # Para que los elementos queden en una fila\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n # Adjust layout\nplt.tight_layout()\n\n# Plot it! :)\nplt.show()\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3', 'Country_Abr': 'name'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Carga del archivo Parquet\ndf = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndf = df[df['country'].isin([\"NO\", \"DK\", \"ES\", \"FR\", \"DE\", \"UK\", \"US\", \"IN\", \"CN\", \"JA\", \"AR\", \"RU\", \"QA\", \"CL\", \"BR\", \"CA\", \"AU\", \"KR\", \"MX\", \"ZA\"])]\ndf = df[df['year'] == 2021]\ndf['value'] = df['wealth']\n\n# Grouping by percentiles\ndf[\"group\"] = pd.cut(\n    df[\"percentile\"],\n    bins=[0, 50, 89, 99, 100],\n    labels=[\"bottom50\", \"50-90\", \"90-99\", \"top1\"],\n    include_lowest=True\n)\n\n# Calculate percents\ndf['side'] = np.where(df['group'].isin(['bottom50', '50-90']), 'left', 'right')\ndf['value'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Select columns\ndf = df[['country', 'group', 'value']]\ndf = df.groupby([\"country\", \"group\"], as_index=False)[\"value\"].sum()\ndf['value'] = np.where((df['group'] == 'bottom50') & (df['value'] &gt;= 0), np.nan, df['value'])\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"group\", values=\"value\").fillna(0).reset_index()\n\n# Merge names\ndf_pivot = df_pivot.merge(df_countries[['ISO2', 'name']], left_on='country', right_on='ISO2', how='inner')\ndf_pivot = df_pivot.drop(columns=['ISO2'])\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['bottom50'] + df_pivot['50-90']\ndf_pivot['total_right'] = df_pivot['90-99'] + df_pivot['top1']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"name\", \"50-90\", \"bottom50\", \"90-99\", \"top1\"]\ndfplot = df_pivot[order]\ndfplot.set_index('name', inplace=True)\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#537c78\", \"#f15b4c\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Where is income distribution concentrated?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07 , f'Income Percentile Breakdown by Country', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Bottom 90', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#526b69\")\nplt.text(0.75, 1.02, 'Top 10', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#b58231\")\n\n# Add strict regulation zone\nynum = 0\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.4, 'Countries with fair distribution on wealth (indeed, no one...)', fontsize=5, fontweight='bold', color=\"gray\", ha=\"left\")\n\n# Add values for total bottom50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for total top50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for individual bars (top1)\nfor i, (city, center, top9, top1) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"], df_pivot[\"top1\"])):\n    ax.text(top9+(top1/2), i, f'{abs(top1):.0f}', va='center', ha='center', fontsize=7, color='grey')\n\n# Add values for individual bars (top9)\nfor i, (city, center, top9) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"])):\n    ax.text((top9/2), i, f'{abs(top9):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (bottom50)\nfor i, (city, bottom50, center) in enumerate(zip(dfplot.index, df_pivot[\"bottom50\"], df_pivot[\"50-90\"])):\n    value = abs(bottom50)\n    if round(value) != 0:  # Solo muestra el texto si el valor redondeado no es cero\n        ax.text(center + (bottom50 / 2), i, f'{value:.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, center) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"])):\n    ax.text((center/2), i, f'{abs(center):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Configurar la leyenda manualmente con cuadrados\nhandles = [\n    mpatches.Patch(color=palette[1], label=\"Bottom 50\", linewidth=2),\n    mpatches.Patch(color=palette[0], label=\"(50-90]\", linewidth=2),\n    mpatches.Patch(color=palette[2], label=\"(90-99]\", linewidth=2),\n    mpatches.Patch(color=palette[3], label=\"Top 1\", linewidth=2)\n]\n\n# Configuración de la leyenda\nplt.legend(\n    handles=handles,\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=4,  # Para que los elementos queden en una fila\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n # Adjust layout\nplt.tight_layout()\n\n# Plot it! :)\nplt.show()"
  },
  {
    "objectID": "posts/202602-wid-distribution-countries/index.html#summary",
    "href": "posts/202602-wid-distribution-countries/index.html#summary",
    "title": "Where is the income/wealth distribution concentrated?",
    "section": "",
    "text": "This study analyzes income and wealth distribution data sourced from the World Inequality Database (WID), segmented by country. It highlights the concentration of wealth and income within different nations, providing insights into global economic disparities.\n\n\n\n\n\n\nDistributions blocks 1\n\n\n\n\n\nThe distribution of “Income” and “Wealth” chart is split into two blocks [50-50]:\n     • Bottom 50      • Top 50\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3', 'Country_Abr': 'name'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Carga del archivo Parquet\ndf = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndf = df[df['country'].isin([\"NO\", \"DK\", \"ES\", \"FR\", \"DE\", \"UK\", \"US\", \"IN\", \"CN\", \"JA\", \"AR\", \"RU\", \"QA\", \"CL\", \"BR\", \"CA\", \"AU\", \"KR\", \"MX\"])]\ndf = df[df['year'] == 2021]\ndf['value'] = df['income']\n\n# Grouping by percentiles\ndf[\"group\"] = pd.cut(\n    df[\"percentile\"],\n    bins=[0, 50, 89, 99, 100],\n    labels=[\"bottom50\", \"50-90\", \"90-99\", \"top1\"],\n    include_lowest=True\n)\n\n# Calculate percents\ndf['side'] = np.where(df['group'].isin(['bottom50']), 'left', 'right')\ndf['value'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Select columns\ndf = df[['country', 'group', 'value']]\ndf = df.groupby([\"country\", \"group\"], as_index=False)[\"value\"].sum()\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"group\", values=\"value\").fillna(0).reset_index()\n\n# Merge names\ndf_pivot = df_pivot.merge(df_countries[['ISO2', 'name']], left_on='country', right_on='ISO2', how='inner')\ndf_pivot = df_pivot.drop(columns=['ISO2'])\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['bottom50']\ndf_pivot['total_right'] = df_pivot['50-90'] + df_pivot['90-99'] + df_pivot['top1']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"name\", \"bottom50\", \"50-90\", \"90-99\", \"top1\"]\ndfplot = df_pivot[order]\ndfplot.set_index('name', inplace=True)\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#f15b4c\", \"#537c78\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Where is income distribution concentrated?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07 , f'Income Percentile Breakdown by Country', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Bottom 50', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#f15b4c\")\nplt.text(0.75, 1.02, 'Top 50', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#537c78\")\n\n# Add strict regulation zone\nynum = 5\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.4, 'Countries with progressive tax systems', fontsize=6, fontweight='bold', color=\"gray\")\n\n# Add values for total bottom50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for total top50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for individual bars (top1)\nfor i, (city, center, top9, top1) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"], df_pivot[\"top1\"])):\n    ax.text(center+top9+(top1/2), i, f'{abs(top1):.0f}', va='center', ha='center', fontsize=7, color='grey')\n\n# Add values for individual bars (top9)\nfor i, (city, center, top9) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"])):\n    ax.text(center+(top9/2), i, f'{abs(top9):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, center) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"])):\n    ax.text(center / 2, i, f'{abs(center):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Legend configuration\nplt.plot([], [], label=\"Percentiles: \", color='white')\nplt.legend(\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=7,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.2\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n # Adjust layout\nplt.tight_layout()\n\n# Plot it! :)\nplt.show()\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3', 'Country_Abr': 'name'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Carga del archivo Parquet\ndf = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndf = df[df['country'].isin([\"NO\", \"DK\", \"ES\", \"FR\", \"DE\", \"UK\", \"US\", \"IN\", \"CN\", \"JA\", \"AR\", \"RU\", \"QA\", \"CL\", \"BR\", \"CA\", \"AU\", \"KR\", \"MX\"])]\ndf = df[df['year'] == 2021]\ndf['value'] = df['wealth']\n\n# Grouping by percentiles\ndf[\"group\"] = pd.cut(\n    df[\"percentile\"],\n    bins=[0, 50, 89, 99, 100],\n    labels=[\"bottom50\", \"50-90\", \"90-99\", \"top1\"],\n    include_lowest=True\n)\n\n# Calculate percents\ndf['side'] = np.where(df['group'].isin(['bottom50']), 'left', 'right')\ndf['value'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Select columns\ndf = df[['country', 'group', 'value']]\ndf = df.groupby([\"country\", \"group\"], as_index=False)[\"value\"].sum()\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"group\", values=\"value\").fillna(0).reset_index()\n\n# Merge names\ndf_pivot = df_pivot.merge(df_countries[['ISO2', 'name']], left_on='country', right_on='ISO2', how='inner')\ndf_pivot = df_pivot.drop(columns=['ISO2'])\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['bottom50']\ndf_pivot['total_right'] = df_pivot['50-90'] + df_pivot['90-99'] + df_pivot['top1']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"name\", \"bottom50\", \"50-90\", \"90-99\", \"top1\"]\ndfplot = df_pivot[order]\ndfplot.set_index('name', inplace=True)\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#f15b4c\", \"#537c78\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Where is wealth distribution concentrated?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07 , f'Wealth Percentile Breakdown by Country', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Bottom 50', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#f15b4c\")\nplt.text(0.75, 1.02, 'Top 50', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#537c78\")\n\n# Add strict regulation zone\nynum = 0\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.4, 'Countries with fair distribution on wealth (indeed, no one...)', fontsize=6, fontweight='bold', color=\"gray\")\n\n# Add values for total bottom50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for total top50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for individual bars (top1)\nfor i, (city, center, top9, top1) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"], df_pivot[\"top1\"])):\n    ax.text(center+top9+(top1/2), i, f'{abs(top1):.0f}', va='center', ha='center', fontsize=7, color='grey')\n\n# Add values for individual bars (top9)\nfor i, (city, center, top9) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"])):\n    ax.text(center+(top9/2), i, f'{abs(top9):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, center) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"])):\n    ax.text(center / 2, i, f'{abs(center):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Legend configuration\nplt.plot([], [], label=\"Percentiles: \", color='white')\nplt.legend(\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=7,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.2\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n # Adjust layout\nplt.tight_layout()\n\n# Plot it! :)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDistributions blocks 2\n\n\n\n\n\nThe distribution of “Income” and “Wealth” chart is split into two blocks [90-10]:\n     • Bottom 90      • Top 10\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3', 'Country_Abr': 'name'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Carga del archivo Parquet\ndf = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndf = df[df['country'].isin([\"NO\", \"DK\", \"ES\", \"FR\", \"DE\", \"UK\", \"US\", \"IN\", \"CN\", \"JA\", \"AR\", \"RU\", \"QA\", \"CL\", \"BR\", \"CA\", \"AU\", \"KR\", \"MX\", \"ZA\"])]\ndf = df[df['year'] == 2021]\ndf['value'] = df['income']\n\n# Grouping by percentiles\ndf[\"group\"] = pd.cut(\n    df[\"percentile\"],\n    bins=[0, 50, 89, 99, 100],\n    labels=[\"bottom50\", \"50-90\", \"90-99\", \"top1\"],\n    include_lowest=True\n)\n\n# Calculate percents\ndf['side'] = np.where(df['group'].isin(['bottom50', '50-90']), 'left', 'right')\ndf['value'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Select columns\ndf = df[['country', 'group', 'value']]\ndf = df.groupby([\"country\", \"group\"], as_index=False)[\"value\"].sum()\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"group\", values=\"value\").fillna(0).reset_index()\n\n# Merge names\ndf_pivot = df_pivot.merge(df_countries[['ISO2', 'name']], left_on='country', right_on='ISO2', how='inner')\ndf_pivot = df_pivot.drop(columns=['ISO2'])\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['bottom50'] + df_pivot['50-90']\ndf_pivot['total_right'] = df_pivot['90-99'] + df_pivot['top1']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"name\", \"50-90\", \"bottom50\", \"90-99\", \"top1\"]\ndfplot = df_pivot[order]\ndfplot.set_index('name', inplace=True)\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#537c78\", \"#f15b4c\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Where is income distribution concentrated?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07 , f'Income Percentile Breakdown by Country', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Bottom 90', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#526b69\")\nplt.text(0.75, 1.02, 'Top 10', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#b58231\")\n\n# Add strict regulation zone\nynum = 7\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(+100, ynum-0.4, 'Countries with progressive tax systems', fontsize=6, fontweight='bold', color=\"gray\", ha=\"right\")\n\n# Add values for total bottom50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for total top50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for individual bars (top1)\nfor i, (city, center, top9, top1) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"], df_pivot[\"top1\"])):\n    ax.text(top9+(top1/2), i, f'{abs(top1):.0f}', va='center', ha='center', fontsize=7, color='grey')\n\n# Add values for individual bars (top9)\nfor i, (city, center, top9) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"])):\n    ax.text((top9/2), i, f'{abs(top9):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, bottom50, center) in enumerate(zip(dfplot.index, df_pivot[\"bottom50\"], df_pivot[\"50-90\"])):\n    ax.text(center+(bottom50/2), i, f'{abs(bottom50):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, center) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"])):\n    ax.text((center/2), i, f'{abs(center):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Configurar la leyenda manualmente con cuadrados\nhandles = [\n    mpatches.Patch(color=palette[1], label=\"Bottom 50\", linewidth=2),\n    mpatches.Patch(color=palette[0], label=\"(50-90]\", linewidth=2),\n    mpatches.Patch(color=palette[2], label=\"(90-99]\", linewidth=2),\n    mpatches.Patch(color=palette[3], label=\"Top 1\", linewidth=2)\n]\n\n# Configuración de la leyenda\nplt.legend(\n    handles=handles,\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=4,  # Para que los elementos queden en una fila\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n # Adjust layout\nplt.tight_layout()\n\n# Plot it! :)\nplt.show()\n\n\n\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3', 'Country_Abr': 'name'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Carga del archivo Parquet\ndf = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndf = df[df['country'].isin([\"NO\", \"DK\", \"ES\", \"FR\", \"DE\", \"UK\", \"US\", \"IN\", \"CN\", \"JA\", \"AR\", \"RU\", \"QA\", \"CL\", \"BR\", \"CA\", \"AU\", \"KR\", \"MX\", \"ZA\"])]\ndf = df[df['year'] == 2021]\ndf['value'] = df['wealth']\n\n# Grouping by percentiles\ndf[\"group\"] = pd.cut(\n    df[\"percentile\"],\n    bins=[0, 50, 89, 99, 100],\n    labels=[\"bottom50\", \"50-90\", \"90-99\", \"top1\"],\n    include_lowest=True\n)\n\n# Calculate percents\ndf['side'] = np.where(df['group'].isin(['bottom50', '50-90']), 'left', 'right')\ndf['value'] *= df['side'].eq('left').map({True: -1, False: 1})\n\n# Select columns\ndf = df[['country', 'group', 'value']]\ndf = df.groupby([\"country\", \"group\"], as_index=False)[\"value\"].sum()\ndf['value'] = np.where((df['group'] == 'bottom50') & (df['value'] &gt;= 0), np.nan, df['value'])\n\n# Pivot columns\ndf_pivot = df.pivot(index=\"country\", columns=\"group\", values=\"value\").fillna(0).reset_index()\n\n# Merge names\ndf_pivot = df_pivot.merge(df_countries[['ISO2', 'name']], left_on='country', right_on='ISO2', how='inner')\ndf_pivot = df_pivot.drop(columns=['ISO2'])\n\n# Define column with values for individuals and professionals\ndf_pivot['total_left'] = df_pivot['bottom50'] + df_pivot['50-90']\ndf_pivot['total_right'] = df_pivot['90-99'] + df_pivot['top1']\ndf_pivot = df_pivot.sort_values(by='total_left', ascending=True)\n\n# Select and order columns\norder = [\"name\", \"50-90\", \"bottom50\", \"90-99\", \"top1\"]\ndfplot = df_pivot[order]\ndfplot.set_index('name', inplace=True)\n\nprint(dfplot)\n\n# Data Visualization\n# ==========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette color\npalette = [\"#537c78\", \"#f15b4c\", \"#faa41b\", \"#ffd45b\"]\n\n# Create horizontal stack bar plot\nax = dfplot.plot(kind=\"barh\", stacked=True, figsize=(10, 6), width=0.7, color=palette)\n\n# Add title and labels\nax.text(0, 1.12, f'Where is income distribution concentrated?', fontsize=16, fontweight='bold', ha='left', transform=ax.transAxes)\nax.text(0, 1.07 , f'Income Percentile Breakdown by Country', fontsize=11, color='#262626', ha='left', transform=ax.transAxes)\nax.set_xlim(-100, 100)\nxticks = np.linspace(-75, 75, 7)\nplt.xticks(xticks, labels=[f\"{abs(int(i))}%\" for i in xticks], fontsize=8)\nplt.gca().set_ylabel('')\nplt.yticks(fontsize=9, color='#282828', fontweight='bold')\nplt.grid(axis='x', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\nplt.axvline(x=0, color='#282828', linestyle='-', linewidth=1.5, alpha=0.7)\n\n# Add individual and professional text\nplt.text(0.25, 1.02, 'Bottom 90', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#526b69\")\nplt.text(0.75, 1.02, 'Top 10', fontsize=9.5, fontweight='bold', va='center', ha='center', transform=ax.transAxes, color=\"#b58231\")\n\n# Add strict regulation zone\nynum = 0\nax.axvspan(-100, 100, ymin=0, ymax=ynum/len(dfplot), color='gray', alpha=0.1)\nplt.axhline(y=ynum-0.5, color='#282828', linestyle='--', linewidth=0.5, alpha=0.3)\nplt.text(-100, ynum-0.4, 'Countries with fair distribution on wealth (indeed, no one...)', fontsize=5, fontweight='bold', color=\"gray\", ha=\"left\")\n\n# Add values for total bottom50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_left'])):\n    ax.text(total - 1, i, f'{abs(total):.0f}', va='center', ha='right', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for total top50 bars\nfor i, (city, total) in enumerate(zip(dfplot.index, df_pivot['total_right'])):\n    ax.text(total + 1, i, f'{total:.0f} ', va='center', ha='left', fontsize=7, color='grey', fontweight='bold')\n\n# Add values for individual bars (top1)\nfor i, (city, center, top9, top1) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"], df_pivot[\"top1\"])):\n    ax.text(top9+(top1/2), i, f'{abs(top1):.0f}', va='center', ha='center', fontsize=7, color='grey')\n\n# Add values for individual bars (top9)\nfor i, (city, center, top9) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"], df_pivot[\"90-99\"])):\n    ax.text((top9/2), i, f'{abs(top9):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (bottom50)\nfor i, (city, bottom50, center) in enumerate(zip(dfplot.index, df_pivot[\"bottom50\"], df_pivot[\"50-90\"])):\n    value = abs(bottom50)\n    if round(value) != 0:  # Solo muestra el texto si el valor redondeado no es cero\n        ax.text(center + (bottom50 / 2), i, f'{value:.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Add values for individual bars (center)\nfor i, (city, center) in enumerate(zip(dfplot.index, df_pivot[\"50-90\"])):\n    ax.text((center/2), i, f'{abs(center):.0f}', va='center', ha='center', fontsize=7, color='white')\n\n# Configurar la leyenda manualmente con cuadrados\nhandles = [\n    mpatches.Patch(color=palette[1], label=\"Bottom 50\", linewidth=2),\n    mpatches.Patch(color=palette[0], label=\"(50-90]\", linewidth=2),\n    mpatches.Patch(color=palette[2], label=\"(90-99]\", linewidth=2),\n    mpatches.Patch(color=palette[3], label=\"Top 1\", linewidth=2)\n]\n\n# Configuración de la leyenda\nplt.legend(\n    handles=handles,\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=4,  # Para que los elementos queden en una fila\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n\n# Add Data Source\nplt.text(0, -0.135, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.135, space + 'World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n # Adjust layout\nplt.tight_layout()\n\n# Plot it! :)\nplt.show()"
  },
  {
    "objectID": "posts/202604-wid-income-wealth-distribution/index.html",
    "href": "posts/202604-wid-income-wealth-distribution/index.html",
    "title": "Intrapercentile Analysis of Economic Inequalities",
    "section": "",
    "text": "It highlights variations inside each percentile, revealing patterns of concentration, dispersion, and economic inequality in greater detail.\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport matplotlib.patches as patches\nimport os\n\n# Variables\n# ==========================================\nvalue = 'wealth' #income or wealth\nyear = 2023 # year\ncountry = 'ES' #iso2 or WO (world)\ncurrency = 'eur' #local, usd, eur\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'ISO2': 'country', 'Country_Abr': 'name', 'Cod_Currency': 'currency', 'Symbol': 'symbol'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Extract percentiles\ndfp = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Extract values\ndfv = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Values.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndfp = dfp[dfp['country'].isin([country])]\ndfp = dfp[dfp['year'] == year]\ndfp['percentage'] = dfp[value]\n\n# Merge dataframes\ndf = pd.merge(dfp, dfv, on=['country', 'year'], how='inner')\ndf = pd.merge(df, df_countries, on=['country'], how='left')\n\n# Select columns\ndf['value'] = df['percentage'] * (df['tincome2'] if value == 'income' else df['twealth2']) / (df['xusd'] if currency == 'usd' else df['xeur'] if currency == 'eur' else 1)\ndf['currency'] = ('USD' if currency == 'usd' else df['currency'])\ndf['symbol'] = ('€' if currency == 'eur' else ('$' if currency == 'usd' else df['symbol']))\ndf = df[['country', 'name', 'currency', 'symbol', 'year', 'percentile', 'value']]\n\n# If country == WO\ndf['name'] = df.apply(lambda row: 'World' if row['country'] == 'WO' else row['name'], axis=1)\ndf['symbol'] = df.apply(lambda row: '$' if row['country'] == 'WO' and currency == 'usd' \n                        else '€' if row['country'] == 'WO' and currency != 'usd' \n                        else row['symbol'], axis=1)\n\n# Grouping by 10\ndf['percentile2'] = pd.cut(\n    df['percentile'], \n    bins=range(1, 111, 10), \n    right=False, \n    labels=[i + 9 for i in range(1, 101, 10)]\n).astype(int)\n\n# Define palette\ncolor_palette = {\n    10: \"#050407\",\n    20: \"#07111e\",\n    30: \"#15334b\",\n    40: \"#2b5778\",\n    50: \"#417da1\",\n    60: \"#5593bb\",\n    70: \"#5a7aa3\",\n    80: \"#6d5e86\",\n    90: \"#a2425c\",\n    100: \"#D21E00\"\n}\n\n# Map palette color\ndf['color'] = df['percentile2'].map(color_palette)\n\n# Percentiles dataframe\ndf2 = df.copy()\ndf2 = df.groupby(['percentile2', 'color'], as_index=False)['value'].sum()\ndf2['valueper'] = df2['value'] / (df2['value']).sum()\ndf2['count'] = 10\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create the figure and suplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [10, 0.5]})\n\n# Calculated values\nper99 = round(df.loc[df['percentile'] == 99, 'value'].iloc[0], -4) * 1.25\nper100 = round(df.loc[df['percentile'] == 100, 'value'].iloc[0], -4)\narea99 = round(df.loc[df['percentile'] == 99, 'value'].iloc[0], -4) * 1.18\narea100 = round(df.loc[df['percentile'] == 99, 'value'].iloc[0], -4) * 1.20\ncapital_value = value.capitalize()\nsymbol = df.loc[df['percentile'] == 99, 'symbol'].iloc[0]\ncountry = df.loc[df['percentile'] == 99, 'name'].iloc[0]\nyear = df.loc[df['percentile'] == 99, 'year'].iloc[0]\n\nif value == \"wealth\":\n    note = \"Net national wealth is the total value of assets (cash, housing, bonds, equities, etc.) owned by the national economy, minus its debts.\"\nelse:\n    note = \"National income measures the total income available to a country's residents. It equals GDP minus capital depreciation plus net foreign income.\"\n\n# First Plot\n# ==================\n# Plot Bars\nbars = ax1.bar(df['percentile'], df['value'], color=df['color'], edgecolor='darkgrey', linewidth=0.5, zorder=2)\n\n# Title and labels\nfig.add_artist(plt.Line2D([0.07, 0.07], [0.93, 1], linewidth=6, color='#203764'))\nax1.text(0.02, 1.1, f'{capital_value} Distribution in {country}', fontsize=16, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0.02, 1.06, f'Intrapercentile Analysis of Economic Inequalities and {capital_value} Concentration', fontsize=11, color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlabel('% Population', fontsize=10, weight='bold')\nax1.set_ylabel(f'{capital_value} ({symbol})', fontsize=10, weight='bold')\n\n# Configuration\nax1.grid(axis='x', linestyle='-', alpha=0.5, zorder=1)\nax1.set_xlim(0, 101)\nax1.set_ylim(0, per99)\nax1.set_xticks(np.arange(0, 101, step=10))\nax1.set_yticks(np.arange(0, per99+1, step=per99/10))\nax1.tick_params(axis='x', labelsize=10)\nax1.tick_params(axis='y', labelsize=10)\nax1.spines['top'].set_visible(False)\nax1.spines['right'].set_visible(False)\n\n# Function to format Y axis\ndef format_func(value, tick_number=None):\n    if abs(value) &gt;= 1e6:\n        return '{:,.1f}M'.format(round(value / 1e5) / 10) \n    elif abs(value) &gt;= 1e5:\n        return '{:,.0f}K'.format(round(value / 1e3, -2))\n    elif abs(value) &gt;= 1e4:\n        return '{:,.0f}K'.format(round(value / 1e3, -1))\n    elif abs(value) &gt;= 1e3:\n        return '{:,.0f}K'.format(round(value / 1e3))\n    else:\n        return str(round(value))\n    \n# Function to format label bars\ndef format_func2(value, tick_number=None):\n    if abs(value) &gt;= 1e6:\n        return '{:,.1f} M'.format(round(value / 1e5) / 10) \n    elif abs(value) &gt;= 1e5:\n        return '{:,.0f} K'.format(round(value / 1e3, -1))\n    elif abs(value) &gt;= 1e4:\n        return '{:,.0f} K'.format(round(value / 1e3))\n    elif abs(value) &gt;= 1e3:\n        return '{:,.0f} K'.format(round(value / 1e3))\n    else:\n        return str(round(value))\n\n# Formatting x and y axis\nax1.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{x:.0f}%'))\nax1.yaxis.set_major_formatter(FuncFormatter(format_func))\n\n# Lines and area to separate outliers\nax1.axhline(y=area100, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.axhline(y=area99, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.add_patch(patches.Rectangle((0, area99), 105, area100-area99, linewidth=0, edgecolor='none', facecolor='white', zorder=3))\n\n# Y Axis modify the outlier value\nlabels = [item.get_text() for item in ax1.get_yticklabels()]\nlabels[-1] = format_func(per100)\nax1.set_yticklabels(labels)\n\n# Show labels each 10 percentile\nfor i, (bar, value) in enumerate(zip(bars, df['value'])):\n    if i % 10 == 0 and i != 0 and value &gt; 1000:\n        ax1.text(bar.get_x() + bar.get_width() / 2, \n                 abs(bar.get_height()) + per99 / 30,\n                 format_func2(value), \n                 ha='center', \n                 va='bottom', \n                 fontsize=8,\n                 color='black', \n                 rotation=90)\n\n# Second Plot\n# ==================\n# Plot Bars\nax2.barh([0] * len(df2), df2['count'], left=df2['percentile2'] - df2['count'], color=df2['color'])\n\n# Configuration\nax2.grid(axis='x', linestyle='-', color='white', alpha=1, linewidth=0.5)\nax2.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)\nax2.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)\nax2.spines['top'].set_visible(False)\nax2.spines['right'].set_visible(False)\nax2.spines['left'].set_visible(False)\nax2.spines['bottom'].set_visible(False)\nx_ticks = np.linspace(df2['percentile2'].min(), df2['percentile2'].max(), 10)\nax2.set_xticks(x_ticks)\nax2.set_xlim(0, 101)\n\n# Add label values\nfor i, row in df2.iterrows():\n    plt.text(row['percentile2'] - row['count'] + row['count'] / 2, 0, \n             f'{row[\"valueper\"] * 100:.1f}%', ha='center', va='center', color='white', fontweight='bold')\n    \n # Add Year label\nax1.text(1, 1.1, f'{year}',\n    transform=ax1.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nax2.text(0, -0.5, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 26\nax2.text(0, -0.5, space + 'World Inequality Database (WID)', \n    transform=ax2.transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Notes\nax2.text(0, -0.99, f'{capital_value}:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 16\nax2.text(0, -0.99, space + f'{note}', \n    transform=ax2.transAxes, \n    fontsize=8, \n    color='gray')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_WID_{country}_{capital_value}_Distribution.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Plot it!\nplt.show()\n\n\n\n\n\n\n\n\nWorld\n\n\n\n\n\nExamining income and wealth distribution across the entire world population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpain\n\n\n\n\n\nExamining income and wealth distribution across Spain population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFrance\n\n\n\n\n\nExamining income and wealth distribution across France population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGermany\n\n\n\n\n\nExamining income and wealth distribution across Germany population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSwitzerland\n\n\n\n\n\nExamining income and wealth distribution across Switzerland population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNorway\n\n\n\n\n\nExamining income and wealth distribution across Norway population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChina\n\n\n\n\n\nExamining income and wealth distribution across China population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnited States\n\n\n\n\n\nExamining income and wealth distribution across United States population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCanada\n\n\n\n\n\nExamining income and wealth distribution across Canada population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAustralia\n\n\n\n\n\nExamining income and wealth distribution across Australia population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRussia\n\n\n\n\n\nExamining income and wealth distribution across Russia population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMexico\n\n\n\n\n\nExamining income and wealth distribution across Mexico population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChile\n\n\n\n\n\nExamining income and wealth distribution across Chile population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSouth Africa\n\n\n\n\n\nExamining income and wealth distribution across United States population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQatar\n\n\n\n\n\nExamining income and wealth distribution across United States population in USD ($)."
  },
  {
    "objectID": "posts/202604-wid-income-wealth-distribution/index.html#summary",
    "href": "posts/202604-wid-income-wealth-distribution/index.html#summary",
    "title": "Intrapercentile Analysis of Economic Inequalities",
    "section": "",
    "text": "It highlights variations inside each percentile, revealing patterns of concentration, dispersion, and economic inequality in greater detail.\n\n\nCode\n# Libraries\n# ==========================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport matplotlib.patches as patches\nimport os\n\n# Variables\n# ==========================================\nvalue = 'wealth' #income or wealth\nyear = 2023 # year\ncountry = 'ES' #iso2 or WO (world)\ncurrency = 'eur' #local, usd, eur\n\n# Data Extraction - GITHUB (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'ISO2': 'country', 'Country_Abr': 'name', 'Cod_Currency': 'currency', 'Symbol': 'symbol'})\n\n# Data Extraction - WID (Percentiles)\n# ==========================================\n# Extract percentiles\ndfp = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Percentiles.parquet\")\n\n# Extract values\ndfv = pd.read_parquet(\"https://github.com/guillemmaya92/Analytics/raw/refs/heads/master/Data/WID_Values.parquet\")\n\n# Data Manipulation\n# =====================================================================\n# Filter a year and select measure\ndfp = dfp[dfp['country'].isin([country])]\ndfp = dfp[dfp['year'] == year]\ndfp['percentage'] = dfp[value]\n\n# Merge dataframes\ndf = pd.merge(dfp, dfv, on=['country', 'year'], how='inner')\ndf = pd.merge(df, df_countries, on=['country'], how='left')\n\n# Select columns\ndf['value'] = df['percentage'] * (df['tincome2'] if value == 'income' else df['twealth2']) / (df['xusd'] if currency == 'usd' else df['xeur'] if currency == 'eur' else 1)\ndf['currency'] = ('USD' if currency == 'usd' else df['currency'])\ndf['symbol'] = ('€' if currency == 'eur' else ('$' if currency == 'usd' else df['symbol']))\ndf = df[['country', 'name', 'currency', 'symbol', 'year', 'percentile', 'value']]\n\n# If country == WO\ndf['name'] = df.apply(lambda row: 'World' if row['country'] == 'WO' else row['name'], axis=1)\ndf['symbol'] = df.apply(lambda row: '$' if row['country'] == 'WO' and currency == 'usd' \n                        else '€' if row['country'] == 'WO' and currency != 'usd' \n                        else row['symbol'], axis=1)\n\n# Grouping by 10\ndf['percentile2'] = pd.cut(\n    df['percentile'], \n    bins=range(1, 111, 10), \n    right=False, \n    labels=[i + 9 for i in range(1, 101, 10)]\n).astype(int)\n\n# Define palette\ncolor_palette = {\n    10: \"#050407\",\n    20: \"#07111e\",\n    30: \"#15334b\",\n    40: \"#2b5778\",\n    50: \"#417da1\",\n    60: \"#5593bb\",\n    70: \"#5a7aa3\",\n    80: \"#6d5e86\",\n    90: \"#a2425c\",\n    100: \"#D21E00\"\n}\n\n# Map palette color\ndf['color'] = df['percentile2'].map(color_palette)\n\n# Percentiles dataframe\ndf2 = df.copy()\ndf2 = df.groupby(['percentile2', 'color'], as_index=False)['value'].sum()\ndf2['valueper'] = df2['value'] / (df2['value']).sum()\ndf2['count'] = 10\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create the figure and suplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [10, 0.5]})\n\n# Calculated values\nper99 = round(df.loc[df['percentile'] == 99, 'value'].iloc[0], -4) * 1.25\nper100 = round(df.loc[df['percentile'] == 100, 'value'].iloc[0], -4)\narea99 = round(df.loc[df['percentile'] == 99, 'value'].iloc[0], -4) * 1.18\narea100 = round(df.loc[df['percentile'] == 99, 'value'].iloc[0], -4) * 1.20\ncapital_value = value.capitalize()\nsymbol = df.loc[df['percentile'] == 99, 'symbol'].iloc[0]\ncountry = df.loc[df['percentile'] == 99, 'name'].iloc[0]\nyear = df.loc[df['percentile'] == 99, 'year'].iloc[0]\n\nif value == \"wealth\":\n    note = \"Net national wealth is the total value of assets (cash, housing, bonds, equities, etc.) owned by the national economy, minus its debts.\"\nelse:\n    note = \"National income measures the total income available to a country's residents. It equals GDP minus capital depreciation plus net foreign income.\"\n\n# First Plot\n# ==================\n# Plot Bars\nbars = ax1.bar(df['percentile'], df['value'], color=df['color'], edgecolor='darkgrey', linewidth=0.5, zorder=2)\n\n# Title and labels\nfig.add_artist(plt.Line2D([0.07, 0.07], [0.93, 1], linewidth=6, color='#203764'))\nax1.text(0.02, 1.1, f'{capital_value} Distribution in {country}', fontsize=16, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0.02, 1.06, f'Intrapercentile Analysis of Economic Inequalities and {capital_value} Concentration', fontsize=11, color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlabel('% Population', fontsize=10, weight='bold')\nax1.set_ylabel(f'{capital_value} ({symbol})', fontsize=10, weight='bold')\n\n# Configuration\nax1.grid(axis='x', linestyle='-', alpha=0.5, zorder=1)\nax1.set_xlim(0, 101)\nax1.set_ylim(0, per99)\nax1.set_xticks(np.arange(0, 101, step=10))\nax1.set_yticks(np.arange(0, per99+1, step=per99/10))\nax1.tick_params(axis='x', labelsize=10)\nax1.tick_params(axis='y', labelsize=10)\nax1.spines['top'].set_visible(False)\nax1.spines['right'].set_visible(False)\n\n# Function to format Y axis\ndef format_func(value, tick_number=None):\n    if abs(value) &gt;= 1e6:\n        return '{:,.1f}M'.format(round(value / 1e5) / 10) \n    elif abs(value) &gt;= 1e5:\n        return '{:,.0f}K'.format(round(value / 1e3, -2))\n    elif abs(value) &gt;= 1e4:\n        return '{:,.0f}K'.format(round(value / 1e3, -1))\n    elif abs(value) &gt;= 1e3:\n        return '{:,.0f}K'.format(round(value / 1e3))\n    else:\n        return str(round(value))\n    \n# Function to format label bars\ndef format_func2(value, tick_number=None):\n    if abs(value) &gt;= 1e6:\n        return '{:,.1f} M'.format(round(value / 1e5) / 10) \n    elif abs(value) &gt;= 1e5:\n        return '{:,.0f} K'.format(round(value / 1e3, -1))\n    elif abs(value) &gt;= 1e4:\n        return '{:,.0f} K'.format(round(value / 1e3))\n    elif abs(value) &gt;= 1e3:\n        return '{:,.0f} K'.format(round(value / 1e3))\n    else:\n        return str(round(value))\n\n# Formatting x and y axis\nax1.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{x:.0f}%'))\nax1.yaxis.set_major_formatter(FuncFormatter(format_func))\n\n# Lines and area to separate outliers\nax1.axhline(y=area100, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.axhline(y=area99, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.add_patch(patches.Rectangle((0, area99), 105, area100-area99, linewidth=0, edgecolor='none', facecolor='white', zorder=3))\n\n# Y Axis modify the outlier value\nlabels = [item.get_text() for item in ax1.get_yticklabels()]\nlabels[-1] = format_func(per100)\nax1.set_yticklabels(labels)\n\n# Show labels each 10 percentile\nfor i, (bar, value) in enumerate(zip(bars, df['value'])):\n    if i % 10 == 0 and i != 0 and value &gt; 1000:\n        ax1.text(bar.get_x() + bar.get_width() / 2, \n                 abs(bar.get_height()) + per99 / 30,\n                 format_func2(value), \n                 ha='center', \n                 va='bottom', \n                 fontsize=8,\n                 color='black', \n                 rotation=90)\n\n# Second Plot\n# ==================\n# Plot Bars\nax2.barh([0] * len(df2), df2['count'], left=df2['percentile2'] - df2['count'], color=df2['color'])\n\n# Configuration\nax2.grid(axis='x', linestyle='-', color='white', alpha=1, linewidth=0.5)\nax2.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)\nax2.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)\nax2.spines['top'].set_visible(False)\nax2.spines['right'].set_visible(False)\nax2.spines['left'].set_visible(False)\nax2.spines['bottom'].set_visible(False)\nx_ticks = np.linspace(df2['percentile2'].min(), df2['percentile2'].max(), 10)\nax2.set_xticks(x_ticks)\nax2.set_xlim(0, 101)\n\n# Add label values\nfor i, row in df2.iterrows():\n    plt.text(row['percentile2'] - row['count'] + row['count'] / 2, 0, \n             f'{row[\"valueper\"] * 100:.1f}%', ha='center', va='center', color='white', fontweight='bold')\n    \n # Add Year label\nax1.text(1, 1.1, f'{year}',\n    transform=ax1.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nax2.text(0, -0.5, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 26\nax2.text(0, -0.5, space + 'World Inequality Database (WID)', \n    transform=ax2.transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Notes\nax2.text(0, -0.99, f'{capital_value}:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 16\nax2.text(0, -0.99, space + f'{note}', \n    transform=ax2.transAxes, \n    fontsize=8, \n    color='gray')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_WID_{country}_{capital_value}_Distribution.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Plot it!\nplt.show()\n\n\n\n\n\n\n\n\nWorld\n\n\n\n\n\nExamining income and wealth distribution across the entire world population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpain\n\n\n\n\n\nExamining income and wealth distribution across Spain population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFrance\n\n\n\n\n\nExamining income and wealth distribution across France population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGermany\n\n\n\n\n\nExamining income and wealth distribution across Germany population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSwitzerland\n\n\n\n\n\nExamining income and wealth distribution across Switzerland population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNorway\n\n\n\n\n\nExamining income and wealth distribution across Norway population in EUR (€).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChina\n\n\n\n\n\nExamining income and wealth distribution across China population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnited States\n\n\n\n\n\nExamining income and wealth distribution across United States population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCanada\n\n\n\n\n\nExamining income and wealth distribution across Canada population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAustralia\n\n\n\n\n\nExamining income and wealth distribution across Australia population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRussia\n\n\n\n\n\nExamining income and wealth distribution across Russia population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMexico\n\n\n\n\n\nExamining income and wealth distribution across Mexico population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChile\n\n\n\n\n\nExamining income and wealth distribution across Chile population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSouth Africa\n\n\n\n\n\nExamining income and wealth distribution across United States population in USD ($).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQatar\n\n\n\n\n\nExamining income and wealth distribution across United States population in USD ($)."
  },
  {
    "objectID": "posts/202605-global-debt/index.html",
    "href": "posts/202605-global-debt/index.html",
    "title": "A history of global debt",
    "section": "",
    "text": "The chart shows the evolution of global debt over time, highlighting its structural composition. It provides insights into how debt levels have changed reached record levels during last years.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport matplotlib.ticker as ticker\nimport matplotlib.ticker as mticker\nimport os\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.KD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1960, 1980)\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'Year',\n    'SP.POP.TOTL': 'pop',\n    'NY.GDP.PCAP.KD': 'gdpc'\n})\n\n# Filter nulls and create total\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_wb['Value'] = df_wb['gdpc'] * df_wb['pop']\ndf_wb['Parameter'] = 'NGDPD'\ndf_wb = df_wb[['Parameter', 'ISO3', 'Year', 'Value']]\n\n# Data Extraction (IMF)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PVD_LS', 'HH_LS', 'NFC_LS', 'CG_DEBT_GDP', 'GG_DEBT_GDP', 'NFPS_DEBT_GDP', 'PS_DEBT_GDP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Data Manipulation\n# =====================================================================\n# Merge IMF and WBD\ndf = pd.concat([df_imf, df_wb], ignore_index=True)\n\n# Pivot Parameter to columns and filter nulls\ndf = df.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\ndf = df.dropna(subset=['PVD_LS', 'HH_LS', 'NFC_LS', 'CG_DEBT_GDP', 'GG_DEBT_GDP', 'NFPS_DEBT_GDP', 'PS_DEBT_GDP'], how='all')\n\n# Calculate Totals\ndf['GDP'] = df['NGDPD']\ndf['Public'] = df['GG_DEBT_GDP'].fillna(df['CG_DEBT_GDP']).fillna(df['NFPS_DEBT_GDP']) * df['GDP']\ndf['HH'] =  df['HH_LS'] * df['GDP']\ndf['NFC'] = df['NFC_LS'].fillna(df['PVD_LS']) * df['GDP']\n\n# Merge countries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Country', 'Year', 'GDP', 'NFC', 'HH', 'Public']]\ndf = df[df['Country'].notna()]\n\n# Groupping data\ndf = df.groupby('Year', as_index=False)[['GDP', 'NFC', 'HH', 'Public']].sum()\n\n# Percent\ndf['NFC'] = df['NFC'] / df['GDP']\ndf['HH'] = df['HH'] / df['GDP']\ndf['Public'] = df['Public'] / df['GDP']\n\n# Adjust table\ndf.drop(columns=['GDP'], inplace=True)\ndf = df[df['Year'] &gt;= 1960]\ndf.set_index('Year', inplace=True)\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette\npalette = [\"#004b96\", \"#009bde\", \"#f1a900\"]\n\n# Create figure\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Crear figure and plot\ndf.plot(kind=\"bar\", stacked=True, width=0.9, color=palette, legend=False, ax=ax)\n\n# Add title and labels\nfig.add_artist(plt.Line2D([0.07, 0.07], [0.87, 0.97], linewidth=6, color='#203764', solid_capstyle='butt'))\nplt.text(0.02, 1.13, f'A history of debt', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.09, f'While global debt has risen dramatically since 1980', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.05, f'(debt as percent of GDP)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n\n# Adjust ticks and grid\nplt.ylim(0, 250)\nax.yaxis.set_major_formatter(mticker.FuncFormatter(lambda x, pos: f'{int(x):,}'.replace(\",\", \".\")))\nax.xaxis.set_major_locator(ticker.MultipleLocator(10))\nplt.gca().set_xlabel('')\nplt.yticks(fontsize=9, color='#282828')\nplt.xticks(fontsize=9, rotation=0)\nplt.grid(axis='y', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\n\n# Custom legend values\nhandles = [\n    mpatches.Patch(color=palette[2], label=\"Public debt\", linewidth=2),\n    mpatches.Patch(color=palette[1], label=\"Household debt (HH)\", linewidth=2),\n    mpatches.Patch(color=palette[0], label=\"Nonfinancial Corporate debt (NFC)\", linewidth=2)\n]\n\n# Legend\nplt.legend(\n    handles=handles,\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=4,\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n\n# Add Data Source\nplt.text(0, -0.15, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.15, space + 'IMF World Economic Outlook Database, World Bank Data', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n# Add text\npublic = df.loc[2023, 'Public']\nhousehold = df.loc[2023, 'HH']\nnonfinancial = df.loc[2023, 'NFC']\n\nplt.text(len(df)+1.5, nonfinancial/2, f\"NFC\\n← {nonfinancial:.0f}%\", fontsize=7, ha='center', va='bottom', color='#004b96')\nplt.text(len(df)+1.5, nonfinancial + (household/2), f\"HH\\n← {household:.0f}%\", fontsize=7, ha='center', va='bottom', color='#009bde')\nplt.text(len(df)+1.5, nonfinancial + household + (public/2), f\"Public\\n← {public:.0f}%\", fontsize=7, ha='center', va='bottom', color='#f1a900')\nplt.text(len(df)+1.5, nonfinancial + household + public, f\"Total\\n← {nonfinancial+household+public:.0f}%\", fontsize=7, ha='center', va='bottom', fontweight='bold', color='black')\n\n# Añadir el texto estirado\nplt.text(len(df)+5, (nonfinancial + household) / 2, \"}\", fontsize=40, ha='center', va='bottom', color='#ffffff')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_IMF_Global_Debt.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show :)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport matplotlib.ticker as ticker\nimport matplotlib.ticker as mticker\nimport os\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.KD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1960, 1980)\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'Year',\n    'SP.POP.TOTL': 'pop',\n    'NY.GDP.PCAP.KD': 'gdpc'\n})\n\n# Filter nulls and create total\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_wb['Value'] = df_wb['gdpc'] * df_wb['pop']\ndf_wb['Parameter'] = 'NGDPD'\ndf_wb = df_wb[['Parameter', 'ISO3', 'Year', 'Value']]\n\n# Data Extraction (IMF)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PVD_LS', 'HH_LS', 'NFC_LS', 'CG_DEBT_GDP', 'GG_DEBT_GDP', 'NFPS_DEBT_GDP', 'PS_DEBT_GDP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Data Manipulation\n# =====================================================================\n# Merge IMF and WBD\ndf = pd.concat([df_imf, df_wb], ignore_index=True)\n\n# Pivot Parameter to columns and filter nulls\ndf = df.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\ndf = df.dropna(subset=['PVD_LS', 'HH_LS', 'NFC_LS', 'CG_DEBT_GDP', 'GG_DEBT_GDP', 'NFPS_DEBT_GDP', 'PS_DEBT_GDP'], how='all')\n\n# Calculate Totals\ndf['GDP'] = df['NGDPD']\ndf['Public'] = df['GG_DEBT_GDP'].fillna(df['CG_DEBT_GDP']).fillna(df['NFPS_DEBT_GDP']) * df['GDP']\ndf['HH'] =  df['HH_LS'] * df['GDP']\ndf['NFC'] = df['NFC_LS'].fillna(df['PVD_LS']) * df['GDP']\ndf['Total'] = df['Public'].fillna(0) + df['HH'].fillna(0) + df['NFC'].fillna(0)\n\n# Merge countries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Cod_Currency', 'Year', 'Total', 'GDP']]\ndf = df[df['Cod_Currency'].notna()]\ndf['Region'] = np.where(df['Cod_Currency'] == 'EUR', 'EUR', np.where(df['ISO3'].isin(['USA', 'CHN', 'JPN', 'AUS', 'IND', 'KOR', 'CAN']), df['ISO3'], 'OTH'))\n\n# Groupping data\ndf = df.groupby(['Year', 'Region'], as_index=False)[['GDP', 'Total']].sum()\n\n# Percent\ndf['Total'] = df['Total'] / df.groupby('Year')['GDP'].transform('sum')\n\n# Adjust table\ndf.drop(columns=['GDP'], inplace=True)\ndf = df[df['Year'] &gt;= 1960]\ndf = df.pivot_table(index='Year', columns='Region', values='Total', aggfunc='sum', fill_value=0)\ndf = df[['OTH', 'AUS', 'CAN', 'CHN', 'IND', 'JPN', 'KOR', 'EUR', 'USA']]\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\ndf = df[['OTH', 'IND', 'KOR', 'CHN', 'JPN', 'CAN', 'AUS', 'EUR', 'USA']]\n\n# Palette\npalette = [\n    \"#004b96\",  # OTH\n    \"#0068b8\",  # IND\n    \"#0080d6\",  # KOR\n    \"#009bde\",  # CHN\n    \"#4bb1e1\",  # JPN\n    \"#88c7e4\",  # CAN\n    \"#f1a900\",  # AUS\n    \"#f3b433\",  # EUR\n    \"#f7c863\"   # USA\n]\n\n# Create figure\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Crear figure and plot\ndf.plot(kind=\"area\", stacked=True, color=palette, legend=False, ax=ax)\n\n# Add title and labels\nfig.add_artist(plt.Line2D([0.07, 0.07], [0.87, 0.97], linewidth=6, color='#203764', solid_capstyle='butt'))\nplt.text(0.02, 1.13, f'A history of debt', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.09, f'Global debt across common currency areas', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.05, f'(debt as percent of GDP)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n\n# Adjust ticks and grid\nplt.ylim(0, 260)\nplt.xlim(1960, 2023)\nax.yaxis.set_major_formatter(mticker.FuncFormatter(lambda x, pos: f'{int(x):,}'.replace(\",\", \".\")))\nax.xaxis.set_major_locator(ticker.MultipleLocator(10))\nplt.gca().set_xlabel('')\nplt.yticks(fontsize=9, color='#282828')\nplt.xticks(fontsize=9, rotation=0)\nplt.grid(axis='y', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\n\n# Custom legend values\nhandles = [\n    mpatches.Patch(color=palette[0], label=\"Rest of Wolrd\", linewidth=2),\n    mpatches.Patch(color=palette[1], label=\"India\", linewidth=2),\n    mpatches.Patch(color=palette[2], label=\"South Korea\", linewidth=2),\n    mpatches.Patch(color=palette[3], label=\"China\", linewidth=2),\n    mpatches.Patch(color=palette[4], label=\"Australia\", linewidth=2),\n    mpatches.Patch(color=palette[5], label=\"Japan\", linewidth=2),\n    mpatches.Patch(color=palette[6], label=\"Canada\", linewidth=2),\n    mpatches.Patch(color=palette[7], label=\"Eurozone\", linewidth=2),\n    mpatches.Patch(color=palette[8], label=\"United States\", linewidth=2)\n]\n\n# Legend\nplt.legend(\n    handles=handles,\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=9,\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n\ndf = df[['OTH', 'IND', 'KOR', 'CHN', 'JPN', 'AUS', 'CAN', 'EUR', 'USA']]\n\n# Add text\noth = df.loc[2023, 'OTH']\nind = df.loc[2023, 'IND']\nkor = df.loc[2023, 'KOR']\nchn = df.loc[2023, 'CHN']\njpn = df.loc[2023, 'JPN']\ncan = df.loc[2023, 'AUS']\naus = df.loc[2023, 'CAN']\neur = df.loc[2023, 'EUR']\nusd = df.loc[2023, 'USA']\n\nplt.text(1.01, 0.07, f\"OTH ←{oth:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[0], transform=plt.gca().transAxes)\nplt.text(1.01, 0.14, f\"IND ←{ind:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[1], transform=plt.gca().transAxes)\nplt.text(1.01, 0.17, f\"KOR ←{kor:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[2], transform=plt.gca().transAxes)\nplt.text(1.01, 0.27, f\"CHN ←{chn:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[3], transform=plt.gca().transAxes)\nplt.text(1.01, 0.4, f\"JPN ←{jpn:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[4], transform=plt.gca().transAxes)\nplt.text(1.01, 0.44, f\"AUS ←{aus:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[5], transform=plt.gca().transAxes)\nplt.text(1.01, 0.48, f\"CAN ←{can:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[6], transform=plt.gca().transAxes)\nplt.text(1.01, 0.55, f\"EUR ←{eur:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[7], transform=plt.gca().transAxes)\nplt.text(1.01, 0.75, f\"USA ←{usd:.0f}%\", fontsize=7, ha='left', va='bottom', fontweight='bold', color=palette[8], transform=plt.gca().transAxes)\nplt.text(1.01, 0.88, f\"Total ← {oth+ind+kor+chn+jpn+can+aus+eur+usd:.0f}%\", fontsize=7, ha='left', va='bottom', fontweight='bold', color='black', transform=plt.gca().transAxes)\n\n# Add Data Source\nplt.text(0, -0.15, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.15, space + 'IMF World Economic Outlook Database, World Bank Data', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_IMF_Global_Debt_Countries.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show it :)\nplt.show()"
  },
  {
    "objectID": "posts/202605-global-debt/index.html#summary",
    "href": "posts/202605-global-debt/index.html#summary",
    "title": "A history of global debt",
    "section": "",
    "text": "The chart shows the evolution of global debt over time, highlighting its structural composition. It provides insights into how debt levels have changed reached record levels during last years.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport matplotlib.ticker as ticker\nimport matplotlib.ticker as mticker\nimport os\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.KD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1960, 1980)\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'Year',\n    'SP.POP.TOTL': 'pop',\n    'NY.GDP.PCAP.KD': 'gdpc'\n})\n\n# Filter nulls and create total\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_wb['Value'] = df_wb['gdpc'] * df_wb['pop']\ndf_wb['Parameter'] = 'NGDPD'\ndf_wb = df_wb[['Parameter', 'ISO3', 'Year', 'Value']]\n\n# Data Extraction (IMF)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PVD_LS', 'HH_LS', 'NFC_LS', 'CG_DEBT_GDP', 'GG_DEBT_GDP', 'NFPS_DEBT_GDP', 'PS_DEBT_GDP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Data Manipulation\n# =====================================================================\n# Merge IMF and WBD\ndf = pd.concat([df_imf, df_wb], ignore_index=True)\n\n# Pivot Parameter to columns and filter nulls\ndf = df.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\ndf = df.dropna(subset=['PVD_LS', 'HH_LS', 'NFC_LS', 'CG_DEBT_GDP', 'GG_DEBT_GDP', 'NFPS_DEBT_GDP', 'PS_DEBT_GDP'], how='all')\n\n# Calculate Totals\ndf['GDP'] = df['NGDPD']\ndf['Public'] = df['GG_DEBT_GDP'].fillna(df['CG_DEBT_GDP']).fillna(df['NFPS_DEBT_GDP']) * df['GDP']\ndf['HH'] =  df['HH_LS'] * df['GDP']\ndf['NFC'] = df['NFC_LS'].fillna(df['PVD_LS']) * df['GDP']\n\n# Merge countries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Country', 'Year', 'GDP', 'NFC', 'HH', 'Public']]\ndf = df[df['Country'].notna()]\n\n# Groupping data\ndf = df.groupby('Year', as_index=False)[['GDP', 'NFC', 'HH', 'Public']].sum()\n\n# Percent\ndf['NFC'] = df['NFC'] / df['GDP']\ndf['HH'] = df['HH'] / df['GDP']\ndf['Public'] = df['Public'] / df['GDP']\n\n# Adjust table\ndf.drop(columns=['GDP'], inplace=True)\ndf = df[df['Year'] &gt;= 1960]\ndf.set_index('Year', inplace=True)\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Palette\npalette = [\"#004b96\", \"#009bde\", \"#f1a900\"]\n\n# Create figure\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Crear figure and plot\ndf.plot(kind=\"bar\", stacked=True, width=0.9, color=palette, legend=False, ax=ax)\n\n# Add title and labels\nfig.add_artist(plt.Line2D([0.07, 0.07], [0.87, 0.97], linewidth=6, color='#203764', solid_capstyle='butt'))\nplt.text(0.02, 1.13, f'A history of debt', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.09, f'While global debt has risen dramatically since 1980', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.05, f'(debt as percent of GDP)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n\n# Adjust ticks and grid\nplt.ylim(0, 250)\nax.yaxis.set_major_formatter(mticker.FuncFormatter(lambda x, pos: f'{int(x):,}'.replace(\",\", \".\")))\nax.xaxis.set_major_locator(ticker.MultipleLocator(10))\nplt.gca().set_xlabel('')\nplt.yticks(fontsize=9, color='#282828')\nplt.xticks(fontsize=9, rotation=0)\nplt.grid(axis='y', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\n\n# Custom legend values\nhandles = [\n    mpatches.Patch(color=palette[2], label=\"Public debt\", linewidth=2),\n    mpatches.Patch(color=palette[1], label=\"Household debt (HH)\", linewidth=2),\n    mpatches.Patch(color=palette[0], label=\"Nonfinancial Corporate debt (NFC)\", linewidth=2)\n]\n\n# Legend\nplt.legend(\n    handles=handles,\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=4,\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n\n# Add Data Source\nplt.text(0, -0.15, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.15, space + 'IMF World Economic Outlook Database, World Bank Data', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n# Add text\npublic = df.loc[2023, 'Public']\nhousehold = df.loc[2023, 'HH']\nnonfinancial = df.loc[2023, 'NFC']\n\nplt.text(len(df)+1.5, nonfinancial/2, f\"NFC\\n← {nonfinancial:.0f}%\", fontsize=7, ha='center', va='bottom', color='#004b96')\nplt.text(len(df)+1.5, nonfinancial + (household/2), f\"HH\\n← {household:.0f}%\", fontsize=7, ha='center', va='bottom', color='#009bde')\nplt.text(len(df)+1.5, nonfinancial + household + (public/2), f\"Public\\n← {public:.0f}%\", fontsize=7, ha='center', va='bottom', color='#f1a900')\nplt.text(len(df)+1.5, nonfinancial + household + public, f\"Total\\n← {nonfinancial+household+public:.0f}%\", fontsize=7, ha='center', va='bottom', fontweight='bold', color='black')\n\n# Añadir el texto estirado\nplt.text(len(df)+5, (nonfinancial + household) / 2, \"}\", fontsize=40, ha='center', va='bottom', color='#ffffff')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_IMF_Global_Debt.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show :)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport matplotlib.ticker as ticker\nimport matplotlib.ticker as mticker\nimport os\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.KD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1960, 1980)\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'Year',\n    'SP.POP.TOTL': 'pop',\n    'NY.GDP.PCAP.KD': 'gdpc'\n})\n\n# Filter nulls and create total\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_wb['Value'] = df_wb['gdpc'] * df_wb['pop']\ndf_wb['Parameter'] = 'NGDPD'\ndf_wb = df_wb[['Parameter', 'ISO3', 'Year', 'Value']]\n\n# Data Extraction (IMF)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PVD_LS', 'HH_LS', 'NFC_LS', 'CG_DEBT_GDP', 'GG_DEBT_GDP', 'NFPS_DEBT_GDP', 'PS_DEBT_GDP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Data Manipulation\n# =====================================================================\n# Merge IMF and WBD\ndf = pd.concat([df_imf, df_wb], ignore_index=True)\n\n# Pivot Parameter to columns and filter nulls\ndf = df.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\ndf = df.dropna(subset=['PVD_LS', 'HH_LS', 'NFC_LS', 'CG_DEBT_GDP', 'GG_DEBT_GDP', 'NFPS_DEBT_GDP', 'PS_DEBT_GDP'], how='all')\n\n# Calculate Totals\ndf['GDP'] = df['NGDPD']\ndf['Public'] = df['GG_DEBT_GDP'].fillna(df['CG_DEBT_GDP']).fillna(df['NFPS_DEBT_GDP']) * df['GDP']\ndf['HH'] =  df['HH_LS'] * df['GDP']\ndf['NFC'] = df['NFC_LS'].fillna(df['PVD_LS']) * df['GDP']\ndf['Total'] = df['Public'].fillna(0) + df['HH'].fillna(0) + df['NFC'].fillna(0)\n\n# Merge countries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Cod_Currency', 'Year', 'Total', 'GDP']]\ndf = df[df['Cod_Currency'].notna()]\ndf['Region'] = np.where(df['Cod_Currency'] == 'EUR', 'EUR', np.where(df['ISO3'].isin(['USA', 'CHN', 'JPN', 'AUS', 'IND', 'KOR', 'CAN']), df['ISO3'], 'OTH'))\n\n# Groupping data\ndf = df.groupby(['Year', 'Region'], as_index=False)[['GDP', 'Total']].sum()\n\n# Percent\ndf['Total'] = df['Total'] / df.groupby('Year')['GDP'].transform('sum')\n\n# Adjust table\ndf.drop(columns=['GDP'], inplace=True)\ndf = df[df['Year'] &gt;= 1960]\ndf = df.pivot_table(index='Year', columns='Region', values='Total', aggfunc='sum', fill_value=0)\ndf = df[['OTH', 'AUS', 'CAN', 'CHN', 'IND', 'JPN', 'KOR', 'EUR', 'USA']]\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\ndf = df[['OTH', 'IND', 'KOR', 'CHN', 'JPN', 'CAN', 'AUS', 'EUR', 'USA']]\n\n# Palette\npalette = [\n    \"#004b96\",  # OTH\n    \"#0068b8\",  # IND\n    \"#0080d6\",  # KOR\n    \"#009bde\",  # CHN\n    \"#4bb1e1\",  # JPN\n    \"#88c7e4\",  # CAN\n    \"#f1a900\",  # AUS\n    \"#f3b433\",  # EUR\n    \"#f7c863\"   # USA\n]\n\n# Create figure\nfig, ax = plt.subplots(figsize=(8, 6))\n\n# Crear figure and plot\ndf.plot(kind=\"area\", stacked=True, color=palette, legend=False, ax=ax)\n\n# Add title and labels\nfig.add_artist(plt.Line2D([0.07, 0.07], [0.87, 0.97], linewidth=6, color='#203764', solid_capstyle='butt'))\nplt.text(0.02, 1.13, f'A history of debt', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.09, f'Global debt across common currency areas', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.05, f'(debt as percent of GDP)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n\n# Adjust ticks and grid\nplt.ylim(0, 260)\nplt.xlim(1960, 2023)\nax.yaxis.set_major_formatter(mticker.FuncFormatter(lambda x, pos: f'{int(x):,}'.replace(\",\", \".\")))\nax.xaxis.set_major_locator(ticker.MultipleLocator(10))\nplt.gca().set_xlabel('')\nplt.yticks(fontsize=9, color='#282828')\nplt.xticks(fontsize=9, rotation=0)\nplt.grid(axis='y', linestyle='--', color='gray', linewidth=0.5, alpha=0.3)\n\n# Custom legend values\nhandles = [\n    mpatches.Patch(color=palette[0], label=\"Rest of Wolrd\", linewidth=2),\n    mpatches.Patch(color=palette[1], label=\"India\", linewidth=2),\n    mpatches.Patch(color=palette[2], label=\"South Korea\", linewidth=2),\n    mpatches.Patch(color=palette[3], label=\"China\", linewidth=2),\n    mpatches.Patch(color=palette[4], label=\"Australia\", linewidth=2),\n    mpatches.Patch(color=palette[5], label=\"Japan\", linewidth=2),\n    mpatches.Patch(color=palette[6], label=\"Canada\", linewidth=2),\n    mpatches.Patch(color=palette[7], label=\"Eurozone\", linewidth=2),\n    mpatches.Patch(color=palette[8], label=\"United States\", linewidth=2)\n]\n\n# Legend\nplt.legend(\n    handles=handles,\n    loc='lower center', \n    bbox_to_anchor=(0.5, -0.12),\n    ncol=9,\n    fontsize=8,\n    frameon=False,\n    handlelength=0.5,\n    handleheight=0.5,\n    borderpad=0.2,\n    columnspacing=0.4\n)\n\ndf = df[['OTH', 'IND', 'KOR', 'CHN', 'JPN', 'AUS', 'CAN', 'EUR', 'USA']]\n\n# Add text\noth = df.loc[2023, 'OTH']\nind = df.loc[2023, 'IND']\nkor = df.loc[2023, 'KOR']\nchn = df.loc[2023, 'CHN']\njpn = df.loc[2023, 'JPN']\ncan = df.loc[2023, 'AUS']\naus = df.loc[2023, 'CAN']\neur = df.loc[2023, 'EUR']\nusd = df.loc[2023, 'USA']\n\nplt.text(1.01, 0.07, f\"OTH ←{oth:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[0], transform=plt.gca().transAxes)\nplt.text(1.01, 0.14, f\"IND ←{ind:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[1], transform=plt.gca().transAxes)\nplt.text(1.01, 0.17, f\"KOR ←{kor:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[2], transform=plt.gca().transAxes)\nplt.text(1.01, 0.27, f\"CHN ←{chn:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[3], transform=plt.gca().transAxes)\nplt.text(1.01, 0.4, f\"JPN ←{jpn:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[4], transform=plt.gca().transAxes)\nplt.text(1.01, 0.44, f\"AUS ←{aus:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[5], transform=plt.gca().transAxes)\nplt.text(1.01, 0.48, f\"CAN ←{can:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[6], transform=plt.gca().transAxes)\nplt.text(1.01, 0.55, f\"EUR ←{eur:.0f}%\", fontsize=7, ha='left', va='bottom', color=palette[7], transform=plt.gca().transAxes)\nplt.text(1.01, 0.75, f\"USA ←{usd:.0f}%\", fontsize=7, ha='left', va='bottom', fontweight='bold', color=palette[8], transform=plt.gca().transAxes)\nplt.text(1.01, 0.88, f\"Total ← {oth+ind+kor+chn+jpn+can+aus+eur+usd:.0f}%\", fontsize=7, ha='left', va='bottom', fontweight='bold', color='black', transform=plt.gca().transAxes)\n\n# Add Data Source\nplt.text(0, -0.15, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.15, space + 'IMF World Economic Outlook Database, World Bank Data', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Remove spines\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_IMF_Global_Debt_Countries.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show it :)\nplt.show()"
  },
  {
    "objectID": "posts/202606-china-rural-urban/index.html",
    "href": "posts/202606-china-rural-urban/index.html",
    "title": "China: From rural to urban",
    "section": "",
    "text": "The charts show the income distribution scale across cities in China and the evolution of income inequality between the rural and urban populations.\n\n\nCode\n# Libraries\n# =====================================================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nimport os\n\n# Data (China) \n# =====================================================================\n# Read wikipedia data\nurl = \"https://en.wikipedia.org/wiki/List_of_prefecture-level_divisions_of_China_by_GDP\"\ntables = pd.read_html(url)\ndf = tables[0]\ndf.columns = ['region', '1', '2', '3', 'gdp', '4', 'gdpc', '5']\ndf['population'] = df['gdp'] / df['gdpc'] * 1000\ndf = df[['region', 'gdpc', 'population']]\ndf['region'] = df['region'].str.replace('*', '', regex=False)\n\ndata = pd.DataFrame({\n    'region': ['Beijing', 'Shangai', 'Chongqing', 'Tianjin', 'Hong Kong', 'Macao'],\n    'gdpc': [28294, 26747, 12350, 17727, 48800, 36909],\n    'population': [21.8, 24.7, 32.0, 13.9, 7.5, 0.68],\n})\n\ndf = pd.concat([df, data], ignore_index=True)\n\n# Data Manipulation\n# =====================================================================\n# Order dataframe\ndf = df.sort_values(by=['gdpc'])\n\n# Calculate 'left accrual widths'\ndf['population_cum'] = df['population'].cumsum()\ndf['left'] = df['population'].cumsum() - df['population']\n\n# Pondered Gini Function\ndef gini(x, weights=None):\n    if weights is None:\n        weights = np.ones_like(x)\n    count = np.multiply.outer(weights, weights)\n    mad = np.abs(np.subtract.outer(x, x) * count).sum() / count.sum()\n    rmad = mad / np.average(x, weights=weights)\n    return 0.5 * rmad\n\n# Calculate gini and median\ngini_index = gini(df['gdpc'].values, df['population'].values)\n\n# Calculate weighted median\ndf.sort_values('gdpc', inplace=True)\ncumsum = df['population'].cumsum()\ncutoff = df['population'].sum() / 2.0\nmedian = df.loc[cumsum &gt;= cutoff, 'gdpc'].iloc[0]\n\n# Show dataframe, gini and median\nprint(df)\nprint(gini_index)\nprint(median)\n\n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 8))\n\n# Create a palette\nnorm = plt.Normalize(df[\"gdpc\"].min(), 25000)\ncolors = plt.cm.coolwarm_r(norm(df[\"gdpc\"]))\n\n# Create a Matplotlib plot\nbars = plt.bar(df['left'], df['gdpc'], width=df['population'], \n        color=colors, alpha=1, align='edge', edgecolor='grey', linewidth=0.1)\n\n# Title\nfig.add_artist(plt.Line2D([0.08, 0.08], [0.90, 0.99], linewidth=6, color='#203764', solid_capstyle='butt'))\nax.text(0.02, 1.09, f'Regional GDP Distribution of China', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nax.text(0.02, 1.06, f'From rural to urban, the role of location in income inequality', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nax.text(0.02, 1.03, f'(GDP per capita in $US)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n\n# Configuration grid and labels\nax.set_xlim(0, df['population_cum'].max()) \nax.set_ylim(0, df['gdpc'].max() * 1.093)\nax.set_xlabel('Cumulative Population (M)', fontsize=10, fontweight='bold')\nax.set_ylabel('GDP per capita ($USD)', fontsize=10, fontweight='bold')\nax.grid(axis='x')\nax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\nax.tick_params(axis='x', labelsize=9)\nax.tick_params(axis='y', labelsize=9) \nax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x):,}'))\nax.xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x):,}'))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.axhline(y=median, color='red', linestyle='--', linewidth=0.5, zorder=0, alpha=0.4)\nax.text(75, median + 100, f\"Median: {median:,.0f}$\", color='darkred', fontweight='bold', fontsize=9, ha='center', va='bottom', zorder=2)\n\n# Add text each region except Ávila and Segovia\nfor i, bar in enumerate(bars):\n    region_name = df['region'].iloc[i]\n    \n    top_cities = [\n        'Beijing', 'Shangai', 'Chongqing', 'Tianjin', 'Hong Kong',\n        'Ordos', 'Suzhou, Jiangsu', 'Zhenjiang', 'Jieyang', 'Kashgar', 'Shangrao', 'Qujing',\n        'Shenzhen', 'Guangzhou', 'Suzhou', 'Chengdu', 'Wuhan', 'Hangzhou', 'Nanjing',\n        'Ningbo', 'Qingdao', 'Wuxi', 'Changsha', 'Zhengzhou', 'Fuzhou', 'Quanzhou',\n        'Jinan', 'Dongguan', 'Foshan', \"Xi'an\", 'Dalian', 'Wenzhou', 'Shenyang',\n        'Kunming', 'Baoding', 'Shijiazhuang', 'Linyi', 'Harbin', 'Nanyang',\n        'Weifang', 'Handan', 'Changchun', 'Xuzhou', 'Ganzhou', 'Zhoukou', 'Nanning',\n        'Heze', 'Fujian', 'Jining', 'Shaoyang', 'Hefei', 'Nantong', 'Shangqiu',\n        'Tangshan', 'Hengyang', 'Cangzhou', 'Jinhua', 'Luoyang', 'Xingtai',\n        'Zhanjiang', 'Zhumadian', 'Bijie'\n    ]\n    \n    # Add labels\n    if region_name in top_cities:\n        x = bar.get_x() + bar.get_width() / 2\n        y = bar.get_height()\n        \n        # Special position\n        if region_name in [\"Ordos\", \"Jinan\", \"Foshan\", \"Qingdao\"]:\n            x -= 5\n            y += 1000\n        else:\n            y += 1000\n\n        ax.text(\n            x, y,\n            region_name,\n            ha='center', va='bottom', color='#363636', fontsize=7, rotation=90,\n        )\n\n# Add Year label \nax.text(1, 1.12, f'2022',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='#D3D3D3')\n    \n# Add Data Source\nax.text(0, -0.1, 'Data Source: National Bureau of Statistics of China', \n            transform=plt.gca().transAxes, \n            fontsize=8, \n            color='gray')\n\n# Show GINI Index\nax.text(\n    0.09, 0.97, f\"Gini Index: {gini_index:.2f}\", \n    transform=ax.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='right',\n    va='top', \n    bbox=dict(boxstyle=\"round,pad=0.3\", edgecolor='gray', facecolor='white')\n)\n\n# Add Gini Index\nax.text(0, -0.12, 'Notes: The Gini coefficient has been calculated using population weights for each region.', \n            transform=plt.gca().transAxes, \n            fontsize=8, \n            color='gray')\n\n# Add label \"poorest\" and \"richest\"\nax.text(0, -0.065, 'Low Income',\n             transform=ax.transAxes,\n             fontsize=11, fontweight='bold', color='darkred', ha='left', va='center')\nax.text(0.915, -0.065, 'High Income',\n             transform=ax.transAxes,\n             fontsize=11, fontweight='bold', color='darkblue', va='center')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_BUREAU_Region_Distribution_China_Prefecture.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show :)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Libraries\n# =====================================================\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\n\n# Get Data (NBS and WID)\n# =====================================================\ndata = {\n    \"year\": list(range(1980, 2024)),\n    \"urban_population\": [\n        19140, 20171, 21480, 22274, 24017, 25094, 26366, 27674, 28661, 29540, 30195, 31203, 32175,\n        33173, 34169, 35174, 37304, 39449, 41608, 43748, 45906, 48064, 50212, 52376, 54283, 56212,\n        58288, 60633, 62403, 64512, 66978, 69927, 72175, 74502, 76738, 79302, 81924, 84343, 86433,\n        88426, 90220, 91425, 92071, 93267\n    ],\n    \"rural_population\": [\n        79565, 79901, 80174, 80734, 80340, 80757, 81141, 81626, 82365, 83164, 84138, 84620, 84996,\n        85344, 85681, 85947, 85085, 84177, 83153, 82038, 80837, 79563, 78241, 76851, 75705, 74544,\n        73160, 71496, 70399, 68938, 67113, 64989, 63747, 62224, 60908, 59024, 57308, 55668, 54108,\n        52582, 50992, 49835, 49104, 47700\n    ],\n    \"urban_consumption\": [\n        490, 517, 504, 547, 621, 750, 847, 953, 1200, 1345, 1404, 1623, 2017, 2676, 3671, 4810,\n        5437, 5705, 5977, 6429, 7083, 7409, 7826, 8166, 8942, 9900, 10820, 12582, 14147, 15161,\n        17119, 19853, 21563, 23386, 25264, 27039, 29324, 31454, 33700, 35841, 34823, 39205, 40066,\n        43797\n    ],\n    \"rural_consumption\": [\n        178, 202, 227, 252, 280, 346, 385, 427, 506, 588, 627, 661, 701, 822, 1073, 1344, 1655, 1768,\n        1778, 1793, 1917, 2032, 2157, 2292, 2521, 2784, 3066, 3538, 3981, 4295, 4782, 5880, 6573,\n        7397, 8365, 9409, 10609, 12145, 13985, 15460, 16209, 18720, 19929, 21953\n    ],\n    \"gini_pre\": [\n        0.38, 0.39, 0.39, 0.39, 0.4, 0.4, 0.42, 0.42, 0.43, 0.44, 0.43, 0.45, 0.46, 0.48, 0.48,\n        0.48, 0.47, 0.47, 0.47, 0.48, 0.5, 0.51, 0.53, 0.54, 0.55, 0.56, 0.56, 0.56, 0.56, 0.56,\n        0.57, 0.56, 0.55, 0.56, 0.55, 0.56, 0.55, 0.56, 0.56, 0.56, 0.56, 0.57, 0.57, 0.57\n    ],\n    \"gini_pos\": [\n        0.37678, 0.38164, 0.38878, 0.38653, 0.39165, 0.39926, 0.41379, 0.41783, 0.42156, 0.43046,\n        0.4264, 0.44225, 0.45711, 0.47219, 0.47823, 0.47116, 0.46628, 0.46659, 0.46798, 0.4751,\n        0.49029, 0.49467, 0.52002, 0.52932, 0.53136, 0.54142, 0.53733, 0.53991, 0.53665, 0.53439,\n        0.53852, 0.53215, 0.51823, 0.5256, 0.51737, 0.51879, 0.51648, 0.52329, 0.51837, 0.5174,\n        0.52289, 0.52394, 0.52394, 0.52394\n    ],\n   \"gini_urb\": [\n        0.2415, 0.243, 0.2424, 0.2463, 0.2606, 0.2886, 0.2711, 0.2576, 0.267, 0.2738,\n        0.2709, 0.2643, 0.2848, 0.3021, 0.3103, 0.3074, 0.3151, 0.3239, 0.3316, 0.3372,\n        0.3456, 0.3589, 0.4127, 0.4245, 0.4383, 0.4464, 0.4492, 0.452, 0.456, 0.4516,\n        0.4569, 0.4802, 0.4412, 0.474, 0.4466, 0.4474,\n        None, None, None, None, None, None, None, None\n    ],\n    \"gini_rur\": [\n        0.3329, 0.3422, 0.349, 0.3542, 0.3584, 0.3619, 0.3707, 0.3774, 0.3827, 0.387,\n        0.3907, 0.4043, 0.4128, 0.4201, 0.4262, 0.4275, 0.43, 0.4315, 0.4267, 0.4311,\n        0.4531, 0.4608, 0.4665, 0.4677, 0.4601, 0.4886, 0.483, 0.4921, 0.4903, 0.4963,\n        0.5239, 0.5292, 0.5259, 0.524, 0.5232, 0.524, \n        None, None, None, None, None, None, None, None\n    ]\n}\n\ndf = pd.DataFrame(data)\ndf['var_consumption'] = df['urban_consumption'] / df['rural_consumption']\ndf['var_population'] = df['urban_population'] / df['rural_population']\ndf['gini'] = df['gini_pos']\ndf = df[['year', 'gini', 'var_consumption', 'var_population', 'gini_urb', 'gini_rur']]\n\n# Data Visualization\n# =====================================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Create figure and axis\nfig, ax1 = plt.subplots(figsize=(8, 6))\n\n# Axis 1 DISPARITY\nax1.set_ylabel('Gini coefficient', fontsize=10)\nline1, = ax1.plot(df['year'], df['gini'], color='#C00000', linewidth=2)\nax1.tick_params(axis='y')\nax1.set_xlim(1980, 2024)\nax1.set_ylim(0, 0.6)\nax1.tick_params(axis='x', labelsize=9)\nax1.tick_params(axis='y', labelsize=8)\n\n# Axis 2 GINI\nax2 = ax1.twinx()\nax2.set_ylabel('Urban-rural ratio', fontsize=10)\nline2, = ax2.plot(df['year'], df['var_consumption'], color='#215C98', linewidth=2)\nline3, = ax2.plot(df['year'], df['var_population'], color='#282828', linewidth=1, linestyle=\":\")\nax2.tick_params(axis='y')\nax2.set_ylim(0, 4)\nax2.tick_params(axis='y', labelsize=8)\n\n# Title and grid\nplt.text(0.02, 1.13, f'Inequality Trends in China', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.08, f'Urban-Rural Consumption Ratio and Gini Coefficient since 1980', fontsize=11, color=\"#3A3A3A\", ha='left', transform=plt.gca().transAxes)\nax1.grid(axis='y', linestyle='-', alpha=0.5)\n\n# Remove spines\nfor ax in (ax1, ax2):\n    for spine_name, spine in ax.spines.items():\n        if spine_name == 'bottom':\n            spine.set_visible(True)\n            spine.set_linewidth(0.5)\n        else:\n            spine.set_visible(False)\n\n# Legend at bottom center\nplt.plot([], [], color='#C00000', label='Gini coefficient')\nplt.plot([], [], color='#215C98', label='Consumption ratio')\nplt.plot([], [], color='#282828', label='Population ratio', linestyle=':')\nplt.legend(\n    loc='lower center',\n    bbox_to_anchor=(0.5, -0.15),\n    ncol=3,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.5\n)\n\n# Add Data Source\nplt.text(0, -0.18, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.18, space + 'National Bureau of Statistics of China (NBS), World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.21, 'Ratio:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 11\nplt.text(0, -0.21, space + 'Urban-Rural Ratio measures the relative size between urban and rural for population and consumption', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.24, 'Gini:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 9\nplt.text(0, -0.24, space + 'Gini coefficient is calculated using post-tax national income to measure income inequality', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Adjust\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_NBS_Inequality_China.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show it :)\nplt.show()"
  },
  {
    "objectID": "posts/202606-china-rural-urban/index.html#summary",
    "href": "posts/202606-china-rural-urban/index.html#summary",
    "title": "China: From rural to urban",
    "section": "",
    "text": "The charts show the income distribution scale across cities in China and the evolution of income inequality between the rural and urban populations.\n\n\nCode\n# Libraries\n# =====================================================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nimport os\n\n# Data (China) \n# =====================================================================\n# Read wikipedia data\nurl = \"https://en.wikipedia.org/wiki/List_of_prefecture-level_divisions_of_China_by_GDP\"\ntables = pd.read_html(url)\ndf = tables[0]\ndf.columns = ['region', '1', '2', '3', 'gdp', '4', 'gdpc', '5']\ndf['population'] = df['gdp'] / df['gdpc'] * 1000\ndf = df[['region', 'gdpc', 'population']]\ndf['region'] = df['region'].str.replace('*', '', regex=False)\n\ndata = pd.DataFrame({\n    'region': ['Beijing', 'Shangai', 'Chongqing', 'Tianjin', 'Hong Kong', 'Macao'],\n    'gdpc': [28294, 26747, 12350, 17727, 48800, 36909],\n    'population': [21.8, 24.7, 32.0, 13.9, 7.5, 0.68],\n})\n\ndf = pd.concat([df, data], ignore_index=True)\n\n# Data Manipulation\n# =====================================================================\n# Order dataframe\ndf = df.sort_values(by=['gdpc'])\n\n# Calculate 'left accrual widths'\ndf['population_cum'] = df['population'].cumsum()\ndf['left'] = df['population'].cumsum() - df['population']\n\n# Pondered Gini Function\ndef gini(x, weights=None):\n    if weights is None:\n        weights = np.ones_like(x)\n    count = np.multiply.outer(weights, weights)\n    mad = np.abs(np.subtract.outer(x, x) * count).sum() / count.sum()\n    rmad = mad / np.average(x, weights=weights)\n    return 0.5 * rmad\n\n# Calculate gini and median\ngini_index = gini(df['gdpc'].values, df['population'].values)\n\n# Calculate weighted median\ndf.sort_values('gdpc', inplace=True)\ncumsum = df['population'].cumsum()\ncutoff = df['population'].sum() / 2.0\nmedian = df.loc[cumsum &gt;= cutoff, 'gdpc'].iloc[0]\n\n# Show dataframe, gini and median\nprint(df)\nprint(gini_index)\nprint(median)\n\n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(12, 8))\n\n# Create a palette\nnorm = plt.Normalize(df[\"gdpc\"].min(), 25000)\ncolors = plt.cm.coolwarm_r(norm(df[\"gdpc\"]))\n\n# Create a Matplotlib plot\nbars = plt.bar(df['left'], df['gdpc'], width=df['population'], \n        color=colors, alpha=1, align='edge', edgecolor='grey', linewidth=0.1)\n\n# Title\nfig.add_artist(plt.Line2D([0.08, 0.08], [0.90, 0.99], linewidth=6, color='#203764', solid_capstyle='butt'))\nax.text(0.02, 1.09, f'Regional GDP Distribution of China', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nax.text(0.02, 1.06, f'From rural to urban, the role of location in income inequality', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nax.text(0.02, 1.03, f'(GDP per capita in $US)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n\n# Configuration grid and labels\nax.set_xlim(0, df['population_cum'].max()) \nax.set_ylim(0, df['gdpc'].max() * 1.093)\nax.set_xlabel('Cumulative Population (M)', fontsize=10, fontweight='bold')\nax.set_ylabel('GDP per capita ($USD)', fontsize=10, fontweight='bold')\nax.grid(axis='x')\nax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\nax.tick_params(axis='x', labelsize=9)\nax.tick_params(axis='y', labelsize=9) \nax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x):,}'))\nax.xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x):,}'))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\nax.axhline(y=median, color='red', linestyle='--', linewidth=0.5, zorder=0, alpha=0.4)\nax.text(75, median + 100, f\"Median: {median:,.0f}$\", color='darkred', fontweight='bold', fontsize=9, ha='center', va='bottom', zorder=2)\n\n# Add text each region except Ávila and Segovia\nfor i, bar in enumerate(bars):\n    region_name = df['region'].iloc[i]\n    \n    top_cities = [\n        'Beijing', 'Shangai', 'Chongqing', 'Tianjin', 'Hong Kong',\n        'Ordos', 'Suzhou, Jiangsu', 'Zhenjiang', 'Jieyang', 'Kashgar', 'Shangrao', 'Qujing',\n        'Shenzhen', 'Guangzhou', 'Suzhou', 'Chengdu', 'Wuhan', 'Hangzhou', 'Nanjing',\n        'Ningbo', 'Qingdao', 'Wuxi', 'Changsha', 'Zhengzhou', 'Fuzhou', 'Quanzhou',\n        'Jinan', 'Dongguan', 'Foshan', \"Xi'an\", 'Dalian', 'Wenzhou', 'Shenyang',\n        'Kunming', 'Baoding', 'Shijiazhuang', 'Linyi', 'Harbin', 'Nanyang',\n        'Weifang', 'Handan', 'Changchun', 'Xuzhou', 'Ganzhou', 'Zhoukou', 'Nanning',\n        'Heze', 'Fujian', 'Jining', 'Shaoyang', 'Hefei', 'Nantong', 'Shangqiu',\n        'Tangshan', 'Hengyang', 'Cangzhou', 'Jinhua', 'Luoyang', 'Xingtai',\n        'Zhanjiang', 'Zhumadian', 'Bijie'\n    ]\n    \n    # Add labels\n    if region_name in top_cities:\n        x = bar.get_x() + bar.get_width() / 2\n        y = bar.get_height()\n        \n        # Special position\n        if region_name in [\"Ordos\", \"Jinan\", \"Foshan\", \"Qingdao\"]:\n            x -= 5\n            y += 1000\n        else:\n            y += 1000\n\n        ax.text(\n            x, y,\n            region_name,\n            ha='center', va='bottom', color='#363636', fontsize=7, rotation=90,\n        )\n\n# Add Year label \nax.text(1, 1.12, f'2022',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='#D3D3D3')\n    \n# Add Data Source\nax.text(0, -0.1, 'Data Source: National Bureau of Statistics of China', \n            transform=plt.gca().transAxes, \n            fontsize=8, \n            color='gray')\n\n# Show GINI Index\nax.text(\n    0.09, 0.97, f\"Gini Index: {gini_index:.2f}\", \n    transform=ax.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='right',\n    va='top', \n    bbox=dict(boxstyle=\"round,pad=0.3\", edgecolor='gray', facecolor='white')\n)\n\n# Add Gini Index\nax.text(0, -0.12, 'Notes: The Gini coefficient has been calculated using population weights for each region.', \n            transform=plt.gca().transAxes, \n            fontsize=8, \n            color='gray')\n\n# Add label \"poorest\" and \"richest\"\nax.text(0, -0.065, 'Low Income',\n             transform=ax.transAxes,\n             fontsize=11, fontweight='bold', color='darkred', ha='left', va='center')\nax.text(0.915, -0.065, 'High Income',\n             transform=ax.transAxes,\n             fontsize=11, fontweight='bold', color='darkblue', va='center')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_BUREAU_Region_Distribution_China_Prefecture.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show :)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Libraries\n# =====================================================\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\n\n# Get Data (NBS and WID)\n# =====================================================\ndata = {\n    \"year\": list(range(1980, 2024)),\n    \"urban_population\": [\n        19140, 20171, 21480, 22274, 24017, 25094, 26366, 27674, 28661, 29540, 30195, 31203, 32175,\n        33173, 34169, 35174, 37304, 39449, 41608, 43748, 45906, 48064, 50212, 52376, 54283, 56212,\n        58288, 60633, 62403, 64512, 66978, 69927, 72175, 74502, 76738, 79302, 81924, 84343, 86433,\n        88426, 90220, 91425, 92071, 93267\n    ],\n    \"rural_population\": [\n        79565, 79901, 80174, 80734, 80340, 80757, 81141, 81626, 82365, 83164, 84138, 84620, 84996,\n        85344, 85681, 85947, 85085, 84177, 83153, 82038, 80837, 79563, 78241, 76851, 75705, 74544,\n        73160, 71496, 70399, 68938, 67113, 64989, 63747, 62224, 60908, 59024, 57308, 55668, 54108,\n        52582, 50992, 49835, 49104, 47700\n    ],\n    \"urban_consumption\": [\n        490, 517, 504, 547, 621, 750, 847, 953, 1200, 1345, 1404, 1623, 2017, 2676, 3671, 4810,\n        5437, 5705, 5977, 6429, 7083, 7409, 7826, 8166, 8942, 9900, 10820, 12582, 14147, 15161,\n        17119, 19853, 21563, 23386, 25264, 27039, 29324, 31454, 33700, 35841, 34823, 39205, 40066,\n        43797\n    ],\n    \"rural_consumption\": [\n        178, 202, 227, 252, 280, 346, 385, 427, 506, 588, 627, 661, 701, 822, 1073, 1344, 1655, 1768,\n        1778, 1793, 1917, 2032, 2157, 2292, 2521, 2784, 3066, 3538, 3981, 4295, 4782, 5880, 6573,\n        7397, 8365, 9409, 10609, 12145, 13985, 15460, 16209, 18720, 19929, 21953\n    ],\n    \"gini_pre\": [\n        0.38, 0.39, 0.39, 0.39, 0.4, 0.4, 0.42, 0.42, 0.43, 0.44, 0.43, 0.45, 0.46, 0.48, 0.48,\n        0.48, 0.47, 0.47, 0.47, 0.48, 0.5, 0.51, 0.53, 0.54, 0.55, 0.56, 0.56, 0.56, 0.56, 0.56,\n        0.57, 0.56, 0.55, 0.56, 0.55, 0.56, 0.55, 0.56, 0.56, 0.56, 0.56, 0.57, 0.57, 0.57\n    ],\n    \"gini_pos\": [\n        0.37678, 0.38164, 0.38878, 0.38653, 0.39165, 0.39926, 0.41379, 0.41783, 0.42156, 0.43046,\n        0.4264, 0.44225, 0.45711, 0.47219, 0.47823, 0.47116, 0.46628, 0.46659, 0.46798, 0.4751,\n        0.49029, 0.49467, 0.52002, 0.52932, 0.53136, 0.54142, 0.53733, 0.53991, 0.53665, 0.53439,\n        0.53852, 0.53215, 0.51823, 0.5256, 0.51737, 0.51879, 0.51648, 0.52329, 0.51837, 0.5174,\n        0.52289, 0.52394, 0.52394, 0.52394\n    ],\n   \"gini_urb\": [\n        0.2415, 0.243, 0.2424, 0.2463, 0.2606, 0.2886, 0.2711, 0.2576, 0.267, 0.2738,\n        0.2709, 0.2643, 0.2848, 0.3021, 0.3103, 0.3074, 0.3151, 0.3239, 0.3316, 0.3372,\n        0.3456, 0.3589, 0.4127, 0.4245, 0.4383, 0.4464, 0.4492, 0.452, 0.456, 0.4516,\n        0.4569, 0.4802, 0.4412, 0.474, 0.4466, 0.4474,\n        None, None, None, None, None, None, None, None\n    ],\n    \"gini_rur\": [\n        0.3329, 0.3422, 0.349, 0.3542, 0.3584, 0.3619, 0.3707, 0.3774, 0.3827, 0.387,\n        0.3907, 0.4043, 0.4128, 0.4201, 0.4262, 0.4275, 0.43, 0.4315, 0.4267, 0.4311,\n        0.4531, 0.4608, 0.4665, 0.4677, 0.4601, 0.4886, 0.483, 0.4921, 0.4903, 0.4963,\n        0.5239, 0.5292, 0.5259, 0.524, 0.5232, 0.524, \n        None, None, None, None, None, None, None, None\n    ]\n}\n\ndf = pd.DataFrame(data)\ndf['var_consumption'] = df['urban_consumption'] / df['rural_consumption']\ndf['var_population'] = df['urban_population'] / df['rural_population']\ndf['gini'] = df['gini_pos']\ndf = df[['year', 'gini', 'var_consumption', 'var_population', 'gini_urb', 'gini_rur']]\n\n# Data Visualization\n# =====================================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Franklin Gothic'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Create figure and axis\nfig, ax1 = plt.subplots(figsize=(8, 6))\n\n# Axis 1 DISPARITY\nax1.set_ylabel('Gini coefficient', fontsize=10)\nline1, = ax1.plot(df['year'], df['gini'], color='#C00000', linewidth=2)\nax1.tick_params(axis='y')\nax1.set_xlim(1980, 2024)\nax1.set_ylim(0, 0.6)\nax1.tick_params(axis='x', labelsize=9)\nax1.tick_params(axis='y', labelsize=8)\n\n# Axis 2 GINI\nax2 = ax1.twinx()\nax2.set_ylabel('Urban-rural ratio', fontsize=10)\nline2, = ax2.plot(df['year'], df['var_consumption'], color='#215C98', linewidth=2)\nline3, = ax2.plot(df['year'], df['var_population'], color='#282828', linewidth=1, linestyle=\":\")\nax2.tick_params(axis='y')\nax2.set_ylim(0, 4)\nax2.tick_params(axis='y', labelsize=8)\n\n# Title and grid\nplt.text(0.02, 1.13, f'Inequality Trends in China', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0.02, 1.08, f'Urban-Rural Consumption Ratio and Gini Coefficient since 1980', fontsize=11, color=\"#3A3A3A\", ha='left', transform=plt.gca().transAxes)\nax1.grid(axis='y', linestyle='-', alpha=0.5)\n\n# Remove spines\nfor ax in (ax1, ax2):\n    for spine_name, spine in ax.spines.items():\n        if spine_name == 'bottom':\n            spine.set_visible(True)\n            spine.set_linewidth(0.5)\n        else:\n            spine.set_visible(False)\n\n# Legend at bottom center\nplt.plot([], [], color='#C00000', label='Gini coefficient')\nplt.plot([], [], color='#215C98', label='Consumption ratio')\nplt.plot([], [], color='#282828', label='Population ratio', linestyle=':')\nplt.legend(\n    loc='lower center',\n    bbox_to_anchor=(0.5, -0.15),\n    ncol=3,\n    fontsize=8,\n    frameon=False,\n    handlelength=1,\n    handleheight=1,\n    borderpad=0.2,\n    columnspacing=0.5\n)\n\n# Add Data Source\nplt.text(0, -0.18, 'Data Source:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 23\nplt.text(0, -0.18, space + 'National Bureau of Statistics of China (NBS), World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.21, 'Ratio:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 11\nplt.text(0, -0.21, space + 'Urban-Rural Ratio measures the relative size between urban and rural for population and consumption', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.24, 'Gini:', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\nspace = \" \" * 9\nplt.text(0, -0.24, space + 'Gini coefficient is calculated using post-tax national income to measure income inequality', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    color='gray')\n\n# Adjust\nplt.tight_layout()\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_NBS_Inequality_China.png\")\nplt.savefig(filename, dpi=300, bbox_inches='tight')\n\n# Show it :)\nplt.show()"
  },
  {
    "objectID": "posts/202607-middle-income-trap/index.html",
    "href": "posts/202607-middle-income-trap/index.html",
    "title": "Middle-Income Trap",
    "section": "",
    "text": "In development economics, the middle income trap is a situation where a country has developed until GDP per capita has reached a middle level of income, but the country does not develop further and it does not attain high income country status.\n\n\nCode\n# Libraries\n# =====================================================================\nimport os\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'cod_country'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.CD', 'SP.POP.TOTL']\ncountries = df_countries['cod_country'].tolist()\ndata_range = ['1960', '2023']\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'cod_country',\n    'time': 'year',\n    'NY.GDP.PCAP.CD': 'gdpc',\n    'SP.POP.TOTL': 'pop'\n})\n\n# Data Manipulation\n# ========================================================\n# Filter nulls and both years\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_unique = df_wb.groupby('cod_country')['year'].nunique()\ncountry_ok = df_unique[df_unique == 2].index\ndf_wb = df_wb[df_wb['cod_country'].isin(country_ok)]\n\n# Add gdpc_usa\nusa_gdpc = df_wb[df_wb['cod_country'] == 'USA'][['year', 'gdpc']].rename(columns={'gdpc': 'gdpc_usa'})\ndf_wb = df_wb.merge(usa_gdpc, on='year', how='left')\ndf_wb['gdpc_usa_rel'] = df_wb['gdpc'] / df_wb['gdpc_usa'] * 100\ndf_wb['ln_gdpc_usa_rel'] = np.log(df_wb['gdpc_usa_rel'])\n\n# Select columns\ndf_wb = df_wb[['cod_country', 'year', 'pop', 'gdpc', 'gdpc_usa_rel', 'ln_gdpc_usa_rel']]\n\n# Rename year row values\ndf_wb['year'] = df_wb['year'].replace({1960: 'start', 2023: 'end'})\n\n# Unpivot to columns\ndf_wb = df_wb.pivot_table(index='cod_country', columns='year', values=['pop', 'gdpc', 'gdpc_usa_rel', 'ln_gdpc_usa_rel'])\ndf_wb.columns = [f'{var}_{year}' for var, year in df_wb.columns]\ndf_wb = df_wb.reset_index()\ndf_wb = df_wb.rename(columns={'ln_gdpc_usa_rel_start': 'start', 'ln_gdpc_usa_rel_end': 'end'})\n\n# Merge queries\ndf = df_wb.merge(df_countries, how='left', left_on='cod_country', right_on='cod_country')\ndf = df[['Region', 'Country_Abr', 'cod_country', 'pop_end', 'gdpc_start', 'gdpc_end', 'gdpc_usa_rel_start', 'gdpc_usa_rel_end', 'start', 'end']]\ndf = df.rename(columns={'Region': 'region', 'Country_Abr': 'country'})\ndf = df[df['region'].notna()]\n\n# Population Log\ndf['pop_end_log'] = np.log(df_wb['pop_end'])\n\n# Palette dot\ncolor_map_dot = {\n    'Oceania': \"#AFEBFF\",\n    'Europe':  \"#C0FFD8\",\n    'Africa':  \"#FFC1A9\",\n    'Americas': \"#FFBEBE\",\n    'Asia':    '#FFFFE0'\n}\n\n# Palette dot line\ncolor_map_dot_line = {\n    'Oceania': \"#001CB9\",\n    'Europe': \"#00AA3E\",\n    'Africa': \"#D16500\",\n    'Americas': \"#BB0000\",\n    'Asia': \"#D6D600\"\n}\n\n# Add columns with colors\ndf['color_line'] = df['region'].map(color_map_dot_line)\ndf['color_dot'] = df['region'].map(color_map_dot)\n\nprint(df)\n\n# Data Visualization\n# ========================================================\n# Figure\nfig = go.Figure()\n\nlabels = df['cod_country'].apply(lambda x: x.upper() if x.lower() in ['usa', 'chn'] else \"\")\n\n# Obtener los valores únicos de color y su región asociada (asumimos que la relación es uno a uno)\nfor color in df['color_dot'].unique():\n    df_color = df[df['color_dot'] == color]\n    region_name = df_color['region'].iloc[0]\n    \n    fig.add_trace(go.Scatter(\n        x=df_color['start'],\n        y=df_color['end'],\n        mode='markers+text',\n        name=region_name,\n        marker=dict(\n            size=df_color['pop_end'],\n            color=color,\n            line=dict(color=df_color['color_line'].iloc[0], width=2),\n            sizemode='area',\n            sizeref=2 * max(df['pop_end']) / (60. ** 2),\n            sizemin=2\n        ),\n        text=labels[df_color.index],  # Asegúrate que labels está indexado correctamente\n        textposition='top center',\n        showlegend=True,\n        customdata=df_color[['country', 'gdpc_start', 'gdpc_usa_rel_start', 'gdpc_end', 'gdpc_usa_rel_end']],\n        hovertemplate=(\n            \"&lt;b&gt;%{customdata[0]}&lt;/b&gt;&lt;br&gt;\"\n            \"GDP Capita (1960): %{customdata[1]:,.0f} (%{customdata[2]:,.2f}%)&lt;br&gt;\"\n            \"GDP Capita (2023): %{customdata[3]:,.0f} (%{customdata[4]:,.2f}%)&lt;extra&gt;&lt;/extra&gt;\"\n        )\n    ))\n\n# Axis Labels\nfig.update_layout(\n    xaxis=dict(\n        tickmode='array',\n        tickvals=[0.9, 1.8, 2.7, 3.6, 4.6052],\n        ticktext=['2%', '6%', '15%', '36%', '100%']\n    ),\n    yaxis=dict(\n        tickmode='array',\n        tickvals=[0.9, 1.8, 2.7, 3.6, 4.6052],\n        ticktext=['2%', '6%', '15%', '36%', '100%']\n    )\n)\n\n# Font Type\nfig.update_layout(\n    font=dict(\n        family=\"sans-serif\",\n        size=12,\n        color=\"black\"\n    )\n)\n\n# Configuration\nfig.update_layout(\n    xaxis=dict(range=[0, 5.4], title='Start', showgrid=False),\n    yaxis=dict(range=[0, 5.4], title='End', showgrid=False),\n    title=dict(\n        text=(\n            \"&lt;b style='font-size:22px;'&gt;The Middle Income Trap&lt;/b&gt;\"\n            \"&lt;span style='font-size:2px;'&gt; &lt;/span&gt;&lt;br&gt;\"\n            \"&lt;span style='font-size:14px; color:gray;'&gt;Income per person relative to United States, 1960 vs 2023&lt;/span&gt;\"\n        ),\n        font=dict(size=24, color=\"black\"),\n        x=0.1,\n        xanchor='left',\n        yanchor='top'\n    ),    \n    width=700,\n    height=600,\n    plot_bgcolor='white',\n    paper_bgcolor='white'\n)\n\n# Label Axis\nfig.update_layout(\n    xaxis_title=dict(\n        text=\"&lt;b&gt;Income per person relative to US, 1960&lt;/b&gt;\",\n        font=dict(size=12, color=\"black\", family=\"sans-serif\")\n    ),\n    yaxis_title=dict(\n        text=\"&lt;b&gt;Income per person relative to US, 2023&lt;/b&gt;\",\n        font=dict(size=12, color=\"black\", family=\"sans-serif\")\n    )\n)\n\n# Annotations\nfig.update_layout(\n    annotations=[\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; World Bank, World Development Indicators (2024)\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.15,\n            showarrow=False,\n            font=dict(size=10, color=\"black\"),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;b&gt;Size:&lt;/b&gt; The size of each bubble represents the population size, scaled proportionally to ensure visual comparability.\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.18,\n            showarrow=False,\n            font=dict(size=10, color=\"black\"),\n            align=\"left\"\n        )\n    ],\n    shapes=[\n        dict(\n            type=\"rect\",\n            xref=\"paper\", yref=\"paper\",\n            x0=-0.06, y0=1.03,\n            x1=-0.04, y1=1.17, \n            fillcolor=\"darkblue\",\n            line=dict(width=0),\n            layer=\"above\"\n        )\n    ]\n)\n\n# Low Text\nfig.add_annotation(\n    x=0.2,\n    y=1.7,\n    text=\"&lt;b&gt;Low&lt;/b&gt;\",\n    showarrow=False,\n    textangle=0,\n    font=dict(size=11, color=\"red\"),\n    xref=\"x\",\n    yref=\"y\"\n)\n\n# Middle Text\nfig.add_annotation(\n    x=2,\n    y=3.5,\n    text=\"&lt;b&gt;Middle&lt;/b&gt;\",\n    showarrow=False,\n    textangle=0,\n    font=dict(size=11, color=\"orange\"),\n    xref=\"x\",\n    yref=\"y\"\n)\n\n# High Text\nfig.add_annotation(\n    x=3.8,\n    y=5.3,\n    text=\"&lt;b&gt;High&lt;/b&gt;\",\n    showarrow=False,\n    textangle=0,\n    font=dict(size=11, color=\"green\"),\n    xref=\"x\",\n    yref=\"y\"\n)\n\n# Box Middle-Income Trap\nfig.add_shape(\n    type=\"rect\",\n    x0=0, y0=0,\n    x1=1.8, y1=1.8,\n    line=dict(color=\"red\", width=1),\n    fillcolor=\"#E6ADAD\",\n    opacity=0.3,\n    layer=\"below\"\n)\n\n# Box Middle-Income Trap\nfig.add_shape(\n    type=\"rect\",\n    x0=1.8, y0=1.8,\n    x1=3.6, y1=3.6,\n    line=dict(color=\"yellow\", width=1),\n    fillcolor=\"#E6E2AD\",\n    opacity=0.3,\n    layer=\"below\"\n)\n\n# Box High-Income Trap\nfig.add_shape(\n    type=\"rect\",\n    x0=3.6, y0=3.6,\n    x1=5.4, y1=5.4,\n    line=dict(color=\"green\", width=1),\n    fillcolor=\"#B2E6AD\",\n    opacity=0.3,\n    layer=\"below\"\n)\n\n# Grid Vertical Lines\nfig.add_shape(type=\"line\", x0=1.8, y0=0, x1=1.8, y1=5.4,\n              line=dict(color=\"gray\", width=0.25, dash=\"solid\"))\nfig.add_shape(type=\"line\", x0=3.6, y0=0, x1=3.6, y1=5.4,\n              line=dict(color=\"gray\", width=0.25, dash=\"solid\"))\n\n# Grid Horizontal lines\nfig.add_shape(type=\"line\", x0=0, y0=1.8, x1=5.4, y1=1.8,\n              line=dict(color=\"gray\", width=0.25, dash=\"solid\"))\nfig.add_shape(type=\"line\", x0=0, y0=3.6, x1=5.4, y1=3.6,\n              line=dict(color=\"gray\", width=0.25, dash=\"solid\"))\n\n# Diagonal = 1\nfig.add_shape(type=\"line\", x0=0, y0=0, x1=5.4, y1=5.4,\n              line=dict(color=\"red\", width=1, dash=\"solid\")\n)\n\n# USA Lines\nfig.add_shape(\n    type=\"line\",\n    x0=4.6,\n    x1=4.6,\n    y0=0,\n    y1=4.6,\n    line=dict(color=\"red\", width=0.5, dash=\"dot\"),\n    xref=\"x\",\n    yref=\"y\"\n)\nfig.add_shape(\n    type=\"line\",\n    x0=0,\n    x1=4.6,\n    y0=4.6,\n    y1=4.6,\n    line=dict(color=\"red\", width=0.5, dash=\"dot\"),\n    xref=\"x\",\n    yref=\"y\"\n)\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_WB_Middle_Income_Trap\")\nfig.write_html(filename + \".html\")\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202607-middle-income-trap/index.html#summary",
    "href": "posts/202607-middle-income-trap/index.html#summary",
    "title": "Middle-Income Trap",
    "section": "",
    "text": "In development economics, the middle income trap is a situation where a country has developed until GDP per capita has reached a middle level of income, but the country does not develop further and it does not attain high income country status.\n\n\nCode\n# Libraries\n# =====================================================================\nimport os\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'cod_country'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.CD', 'SP.POP.TOTL']\ncountries = df_countries['cod_country'].tolist()\ndata_range = ['1960', '2023']\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'cod_country',\n    'time': 'year',\n    'NY.GDP.PCAP.CD': 'gdpc',\n    'SP.POP.TOTL': 'pop'\n})\n\n# Data Manipulation\n# ========================================================\n# Filter nulls and both years\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_unique = df_wb.groupby('cod_country')['year'].nunique()\ncountry_ok = df_unique[df_unique == 2].index\ndf_wb = df_wb[df_wb['cod_country'].isin(country_ok)]\n\n# Add gdpc_usa\nusa_gdpc = df_wb[df_wb['cod_country'] == 'USA'][['year', 'gdpc']].rename(columns={'gdpc': 'gdpc_usa'})\ndf_wb = df_wb.merge(usa_gdpc, on='year', how='left')\ndf_wb['gdpc_usa_rel'] = df_wb['gdpc'] / df_wb['gdpc_usa'] * 100\ndf_wb['ln_gdpc_usa_rel'] = np.log(df_wb['gdpc_usa_rel'])\n\n# Select columns\ndf_wb = df_wb[['cod_country', 'year', 'pop', 'gdpc', 'gdpc_usa_rel', 'ln_gdpc_usa_rel']]\n\n# Rename year row values\ndf_wb['year'] = df_wb['year'].replace({1960: 'start', 2023: 'end'})\n\n# Unpivot to columns\ndf_wb = df_wb.pivot_table(index='cod_country', columns='year', values=['pop', 'gdpc', 'gdpc_usa_rel', 'ln_gdpc_usa_rel'])\ndf_wb.columns = [f'{var}_{year}' for var, year in df_wb.columns]\ndf_wb = df_wb.reset_index()\ndf_wb = df_wb.rename(columns={'ln_gdpc_usa_rel_start': 'start', 'ln_gdpc_usa_rel_end': 'end'})\n\n# Merge queries\ndf = df_wb.merge(df_countries, how='left', left_on='cod_country', right_on='cod_country')\ndf = df[['Region', 'Country_Abr', 'cod_country', 'pop_end', 'gdpc_start', 'gdpc_end', 'gdpc_usa_rel_start', 'gdpc_usa_rel_end', 'start', 'end']]\ndf = df.rename(columns={'Region': 'region', 'Country_Abr': 'country'})\ndf = df[df['region'].notna()]\n\n# Population Log\ndf['pop_end_log'] = np.log(df_wb['pop_end'])\n\n# Palette dot\ncolor_map_dot = {\n    'Oceania': \"#AFEBFF\",\n    'Europe':  \"#C0FFD8\",\n    'Africa':  \"#FFC1A9\",\n    'Americas': \"#FFBEBE\",\n    'Asia':    '#FFFFE0'\n}\n\n# Palette dot line\ncolor_map_dot_line = {\n    'Oceania': \"#001CB9\",\n    'Europe': \"#00AA3E\",\n    'Africa': \"#D16500\",\n    'Americas': \"#BB0000\",\n    'Asia': \"#D6D600\"\n}\n\n# Add columns with colors\ndf['color_line'] = df['region'].map(color_map_dot_line)\ndf['color_dot'] = df['region'].map(color_map_dot)\n\nprint(df)\n\n# Data Visualization\n# ========================================================\n# Figure\nfig = go.Figure()\n\nlabels = df['cod_country'].apply(lambda x: x.upper() if x.lower() in ['usa', 'chn'] else \"\")\n\n# Obtener los valores únicos de color y su región asociada (asumimos que la relación es uno a uno)\nfor color in df['color_dot'].unique():\n    df_color = df[df['color_dot'] == color]\n    region_name = df_color['region'].iloc[0]\n    \n    fig.add_trace(go.Scatter(\n        x=df_color['start'],\n        y=df_color['end'],\n        mode='markers+text',\n        name=region_name,\n        marker=dict(\n            size=df_color['pop_end'],\n            color=color,\n            line=dict(color=df_color['color_line'].iloc[0], width=2),\n            sizemode='area',\n            sizeref=2 * max(df['pop_end']) / (60. ** 2),\n            sizemin=2\n        ),\n        text=labels[df_color.index],  # Asegúrate que labels está indexado correctamente\n        textposition='top center',\n        showlegend=True,\n        customdata=df_color[['country', 'gdpc_start', 'gdpc_usa_rel_start', 'gdpc_end', 'gdpc_usa_rel_end']],\n        hovertemplate=(\n            \"&lt;b&gt;%{customdata[0]}&lt;/b&gt;&lt;br&gt;\"\n            \"GDP Capita (1960): %{customdata[1]:,.0f} (%{customdata[2]:,.2f}%)&lt;br&gt;\"\n            \"GDP Capita (2023): %{customdata[3]:,.0f} (%{customdata[4]:,.2f}%)&lt;extra&gt;&lt;/extra&gt;\"\n        )\n    ))\n\n# Axis Labels\nfig.update_layout(\n    xaxis=dict(\n        tickmode='array',\n        tickvals=[0.9, 1.8, 2.7, 3.6, 4.6052],\n        ticktext=['2%', '6%', '15%', '36%', '100%']\n    ),\n    yaxis=dict(\n        tickmode='array',\n        tickvals=[0.9, 1.8, 2.7, 3.6, 4.6052],\n        ticktext=['2%', '6%', '15%', '36%', '100%']\n    )\n)\n\n# Font Type\nfig.update_layout(\n    font=dict(\n        family=\"sans-serif\",\n        size=12,\n        color=\"black\"\n    )\n)\n\n# Configuration\nfig.update_layout(\n    xaxis=dict(range=[0, 5.4], title='Start', showgrid=False),\n    yaxis=dict(range=[0, 5.4], title='End', showgrid=False),\n    title=dict(\n        text=(\n            \"&lt;b style='font-size:22px;'&gt;The Middle Income Trap&lt;/b&gt;\"\n            \"&lt;span style='font-size:2px;'&gt; &lt;/span&gt;&lt;br&gt;\"\n            \"&lt;span style='font-size:14px; color:gray;'&gt;Income per person relative to United States, 1960 vs 2023&lt;/span&gt;\"\n        ),\n        font=dict(size=24, color=\"black\"),\n        x=0.1,\n        xanchor='left',\n        yanchor='top'\n    ),    \n    width=700,\n    height=600,\n    plot_bgcolor='white',\n    paper_bgcolor='white'\n)\n\n# Label Axis\nfig.update_layout(\n    xaxis_title=dict(\n        text=\"&lt;b&gt;Income per person relative to US, 1960&lt;/b&gt;\",\n        font=dict(size=12, color=\"black\", family=\"sans-serif\")\n    ),\n    yaxis_title=dict(\n        text=\"&lt;b&gt;Income per person relative to US, 2023&lt;/b&gt;\",\n        font=dict(size=12, color=\"black\", family=\"sans-serif\")\n    )\n)\n\n# Annotations\nfig.update_layout(\n    annotations=[\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; World Bank, World Development Indicators (2024)\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.15,\n            showarrow=False,\n            font=dict(size=10, color=\"black\"),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;b&gt;Size:&lt;/b&gt; The size of each bubble represents the population size, scaled proportionally to ensure visual comparability.\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.18,\n            showarrow=False,\n            font=dict(size=10, color=\"black\"),\n            align=\"left\"\n        )\n    ],\n    shapes=[\n        dict(\n            type=\"rect\",\n            xref=\"paper\", yref=\"paper\",\n            x0=-0.06, y0=1.03,\n            x1=-0.04, y1=1.17, \n            fillcolor=\"darkblue\",\n            line=dict(width=0),\n            layer=\"above\"\n        )\n    ]\n)\n\n# Low Text\nfig.add_annotation(\n    x=0.2,\n    y=1.7,\n    text=\"&lt;b&gt;Low&lt;/b&gt;\",\n    showarrow=False,\n    textangle=0,\n    font=dict(size=11, color=\"red\"),\n    xref=\"x\",\n    yref=\"y\"\n)\n\n# Middle Text\nfig.add_annotation(\n    x=2,\n    y=3.5,\n    text=\"&lt;b&gt;Middle&lt;/b&gt;\",\n    showarrow=False,\n    textangle=0,\n    font=dict(size=11, color=\"orange\"),\n    xref=\"x\",\n    yref=\"y\"\n)\n\n# High Text\nfig.add_annotation(\n    x=3.8,\n    y=5.3,\n    text=\"&lt;b&gt;High&lt;/b&gt;\",\n    showarrow=False,\n    textangle=0,\n    font=dict(size=11, color=\"green\"),\n    xref=\"x\",\n    yref=\"y\"\n)\n\n# Box Middle-Income Trap\nfig.add_shape(\n    type=\"rect\",\n    x0=0, y0=0,\n    x1=1.8, y1=1.8,\n    line=dict(color=\"red\", width=1),\n    fillcolor=\"#E6ADAD\",\n    opacity=0.3,\n    layer=\"below\"\n)\n\n# Box Middle-Income Trap\nfig.add_shape(\n    type=\"rect\",\n    x0=1.8, y0=1.8,\n    x1=3.6, y1=3.6,\n    line=dict(color=\"yellow\", width=1),\n    fillcolor=\"#E6E2AD\",\n    opacity=0.3,\n    layer=\"below\"\n)\n\n# Box High-Income Trap\nfig.add_shape(\n    type=\"rect\",\n    x0=3.6, y0=3.6,\n    x1=5.4, y1=5.4,\n    line=dict(color=\"green\", width=1),\n    fillcolor=\"#B2E6AD\",\n    opacity=0.3,\n    layer=\"below\"\n)\n\n# Grid Vertical Lines\nfig.add_shape(type=\"line\", x0=1.8, y0=0, x1=1.8, y1=5.4,\n              line=dict(color=\"gray\", width=0.25, dash=\"solid\"))\nfig.add_shape(type=\"line\", x0=3.6, y0=0, x1=3.6, y1=5.4,\n              line=dict(color=\"gray\", width=0.25, dash=\"solid\"))\n\n# Grid Horizontal lines\nfig.add_shape(type=\"line\", x0=0, y0=1.8, x1=5.4, y1=1.8,\n              line=dict(color=\"gray\", width=0.25, dash=\"solid\"))\nfig.add_shape(type=\"line\", x0=0, y0=3.6, x1=5.4, y1=3.6,\n              line=dict(color=\"gray\", width=0.25, dash=\"solid\"))\n\n# Diagonal = 1\nfig.add_shape(type=\"line\", x0=0, y0=0, x1=5.4, y1=5.4,\n              line=dict(color=\"red\", width=1, dash=\"solid\")\n)\n\n# USA Lines\nfig.add_shape(\n    type=\"line\",\n    x0=4.6,\n    x1=4.6,\n    y0=0,\n    y1=4.6,\n    line=dict(color=\"red\", width=0.5, dash=\"dot\"),\n    xref=\"x\",\n    yref=\"y\"\n)\nfig.add_shape(\n    type=\"line\",\n    x0=0,\n    x1=4.6,\n    y0=4.6,\n    y1=4.6,\n    line=dict(color=\"red\", width=0.5, dash=\"dot\"),\n    xref=\"x\",\n    yref=\"y\"\n)\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_WB_Middle_Income_Trap\")\nfig.write_html(filename + \".html\")\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202608-neocolonialism-floating-ex/index.html",
    "href": "posts/202608-neocolonialism-floating-ex/index.html",
    "title": "Neocolonialism: The power of a floating exchange rate market",
    "section": "",
    "text": "The chart shows the evolution of currencies in each country relative to the USD from the year 2001 to 2025.\n\n\nCode\n# Libraries\n# ============================================\nfrom sqlalchemy import create_engine, text\nimport pandas as pd\nimport plotly.express as px\nimport requests\nimport os\n\n# Data Extraction\n# ============================================\nserver = \"DESKTOP-FUOV4IE\\\\MSSQLSERVER_TAB2\"\ndatabase = \"master\"\n\nconnection_string = (\n    f\"mssql+pyodbc://@{server}/{database}\"\n    \"?driver=ODBC+Driver+17+for+SQL+Server\"\n    \"&trusted_connection=yes\"\n)\n\nengine = create_engine(connection_string)\n\nwith engine.connect() as conn:\n    # Query h_currencies\n    result = conn.execute(text(\"SELECT right(symbol, 3) as symbol, date, rate FROM h_currencies_exh WHERE date &gt; '2001-01-01'\"))\n    df = pd.DataFrame(result.fetchall(), columns=result.keys())\n\n    # Query d_countries\n    url = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/refs/heads/master/Data/DIM_Country.json\"\n    data = pd.read_json(url)\n    df_countries = pd.DataFrame(data).T.reset_index().rename(columns={\"index\": \"cod_iso3\", \"ISO2\": \"cod_iso2\", \"Cod_Currency\": \"cod_currency\", \"Country_Abr\": \"country\"})\n    df_countries['currency'] = df_countries['Currency'] + \" (\" + df_countries['Symbol'] + \")\"\n    df_countries = df_countries[['cod_currency', 'currency', 'cod_iso3', 'country']]\n    df_countries = df_countries[df_countries['cod_iso3'] != 'ATA']\n\n    # Adjust SQS (Somaliland)\n    sos_lines = [\n        {\"cod_currency\": \"SQS\", \"currency\": \"Somaliland Shilling (S)\", \"cod_iso3\": 'SOL', \"country\": \"Somaliland\"},\n    ]\n    df_countries = pd.concat([df_countries, pd.DataFrame(sos_lines)], ignore_index=True)\n\n# Data Manipulation\n# ============================================\n# Format date\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust VES (Venezuela)\ndf['rate'] = df.apply(lambda row: row['rate'] / 100000 if row['symbol'] == 'VEF' else row['rate'], axis=1)\ndf['symbol'] = df['symbol'].apply(lambda x: 'VES' if x == 'VEF' else x)\n\n# Adjust ZMW (Zambia)\ndf['rate'] = df.apply(lambda row: row['rate'] / 1000 if row['symbol'] == 'ZMK' else row['rate'], axis=1)\ndf['symbol'] = df['symbol'].apply(lambda x: 'ZMW' if x == 'ZMK' else x)\n\n# Adjust USD (United States and others)\nusa_lines = [\n    {\"symbol\": \"USD\", \"date\": \"2001-01-01\", \"rate\": 1},\n    {\"symbol\": \"USD\", \"date\": \"2001-05-28\", \"rate\": 1},\n]\ndf = pd.concat([df, pd.DataFrame(usa_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust SSP (South Sudan)\nssp_lines = [\n    {\"symbol\": \"SSP\", \"date\": \"2008-01-01\", \"rate\": 3.21},\n    {\"symbol\": \"SSP\", \"date\": \"2025-05-28\", \"rate\": 130},\n]\ndf = pd.concat([df, pd.DataFrame(ssp_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust SQS (Somaliland)\nssp_lines = [\n    {\"symbol\": \"SQS\", \"date\": \"2001-01-01\", \"rate\": 2967},\n    {\"symbol\": \"SQS\", \"date\": \"2024-01-01\", \"rate\": 9703},\n]\ndf = pd.concat([df, pd.DataFrame(ssp_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust ZWL (Zimbawe)\nzwl_lines = [\n    {\"symbol\": \"ZWL\", \"date\": \"2001-01-01\", \"rate\": 1 / (10 ** 25)}\n]\ndf = pd.concat([df, pd.DataFrame(zwl_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust CUP (Cuba)\nzwl_lines = [\n    {\"symbol\": \"CUP\", \"date\": \"2001-01-01\", \"rate\": 1}\n]\ndf = pd.concat([df, pd.DataFrame(zwl_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust MRU (Mauritania)\nmru_lines = [\n    {\"symbol\": \"MRU\", \"date\": \"2001-01-01\", \"rate\": 23.8}\n]\ndf = pd.concat([df, pd.DataFrame(mru_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust AOA (Angola)\nmru_lines = [\n    {\"symbol\": \"AOA\", \"date\": \"2001-01-01\", \"rate\": 18.7}\n]\ndf = pd.concat([df, pd.DataFrame(mru_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust MGA (Madagascar)\nmru_lines = [\n    {\"symbol\": \"MGA\", \"date\": \"2001-01-01\", \"rate\": 1.27}\n]\ndf = pd.concat([df, pd.DataFrame(mru_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Get index of min and max date for each symbol\nmin_idx = df.groupby('symbol')['date'].idxmin()\nmax_idx = df.groupby('symbol')['date'].idxmax()\n\n# Select rows and rename columns\ndf_min = df.loc[min_idx].rename(columns={'date': 'min_date', 'rate': 'min_rate'})\ndf_max = df.loc[max_idx].rename(columns={'date': 'max_date', 'rate': 'max_rate'})\n\n# Merge dataframes minmax\ndf = pd.merge(df_min[['symbol', 'min_date', 'min_rate']],\n                  df_max[['symbol', 'max_date', 'max_rate']],\n                  on='symbol')\n\n# Merge dataframes currencies\ndf = pd.merge(\n    df,\n    df_countries,\n    how='left',\n    left_on='symbol',\n    right_on='cod_currency'\n)\n\n# Filter null currencies\ndf = df[df['cod_iso3'].notna()]\n\n# Calculate variation\ndf['variation'] =  ( ( df['max_rate'] / df['min_rate'] ) -1 )\n\n# Clasification groups\ndf['class'] = pd.cut(df['variation'], \n                     bins=[-float('inf'), -0.5, -0.3, -0.01, 0.01, 0.3, 0.5, 5, 12, 150, float('inf')],\n                     labels=['G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7', 'G8', 'G9', 'G10'])\n\n# Classification groups names\nclass_name_map = {\n    'G1': 'Appreciation &gt; 50%',\n    'G2': 'Appreciation [30-50%]',\n    'G3': 'Appreciation [1-30%]',\n    'G4': 'Equal',\n    'G5': 'Depreciation [1-30%]',\n    'G6': 'Depreciation [30-50%]',\n    'G7': 'Depreciation [50-500%]',\n    'G8': 'Depreciation [500-1000%]',\n    'G9': 'Depreciation [1000-15000%]',\n    'G10': 'Depreciation [&gt;15000%]'\n}\ndf['class_name'] = df['class'].map(class_name_map)\n\n# Sort by class\ndf = df.sort_values(by='class')\n\n# Rate and date column\ndf['before'] = df['min_rate'].map('{:.4f}'.format) + \" (\" + df['min_date'].dt.strftime('%Y-%m-%d') + \")\"\ndf['after'] = df['max_rate'].map('{:.4f}'.format) + \" (\" + df['max_date'].dt.strftime('%Y-%m-%d') + \")\"\n\n# Download to Excel\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, \"FIG_EXAPI_Currency_Map.xlsx\")\ndf.to_excel(filename, index=False)\n\nprint(df)\n\n# Data Manipulation\n# ============================================\n# Map\nurl = 'https://raw.githubusercontent.com/guillemmaya92/Analytics/refs/heads/master/Maps/world-countries-plotly.geojson'\ngeojson = requests.get(url).json()\n\n# Custom Map Color\ncolor_map_name = {\n    'Appreciation &gt; 50%': '#9CF6D2',\n    'Appreciation [30-50%]': '#CDFFE8',\n    'Appreciation [1-30%]': '#EFFFF8',\n    'Equal': '#FFFFFF',\n    'Depreciation [1-30%]': '#F2DCDB',\n    'Depreciation [30-50%]': '#E6B8B7',\n    'Depreciation [50-500%]': '#DA9694',\n    'Depreciation [500-1000%]': '#963634',\n    'Depreciation [1000-15000%]': '#632523',\n    'Depreciation [&gt;15000%]': \"#291312\"\n}\n\n# Figure map choropleth\nfig = px.choropleth(\n    df,\n    geojson=geojson,\n    locations='cod_iso3',\n    featureidkey=\"properties.iso_a3\",\n    color='class_name',\n    hover_name='country',\n    hover_data={\n        'cod_currency': True,\n        'currency': True,\n        'before': True,\n        'after': True,\n        'variation': ':,.2%',\n        'cod_iso3': False,\n        'class_name': False\n    },\n    color_discrete_map=color_map_name,\n    category_orders={'class': ['G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7', 'G8', 'G9', 'G10']},\n    labels={'class_name': 'Classification'}\n)\n\n# Adjust plot\nfig.update_geos(fitbounds=\"locations\", visible=False)\nfig.update_traces(marker_line_width=0.5, marker_line_color=\"#808080\")\nfig.update_layout(\n    annotations=[\n        dict(\n            text=\"&lt;b&gt;The power of a floating exchange rate market&lt;/b&gt;\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.05,\n            showarrow=False,\n            font=dict(size=20)\n        ),\n        dict(\n            text=\"While USD is getting stronger, the world are feeling pain\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.015,\n            showarrow=False,\n            font=dict(size=16)\n        ),\n        dict(\n            text=\"(Variation in exchange rates during the period 2001–2025)\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=0.985,\n            showarrow=False,\n            font=dict(size=13)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; &lt;a href='https://exchangeratesapi.io' target='_blank' style='color:#3c586b;'&gt;exchangerateapi.io&lt;/a&gt;\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=0,\n            showarrow=False,\n            font=dict(size=12),\n            align=\"left\"\n        )\n    ],\n    legend=dict(\n        title=dict(text='&lt;b&gt;Categories&lt;/b&gt;'),\n        font=dict(size=11),\n        x=1.02,\n        y=0.5,\n        yanchor='middle',\n        xanchor='left',\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor=\"#808080\",\n        borderwidth=1\n    )\n)\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_EXAPI_Currency_Map\")\nfig.write_html(filename + \".html\")\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202608-neocolonialism-floating-ex/index.html#summary",
    "href": "posts/202608-neocolonialism-floating-ex/index.html#summary",
    "title": "Neocolonialism: The power of a floating exchange rate market",
    "section": "",
    "text": "The chart shows the evolution of currencies in each country relative to the USD from the year 2001 to 2025.\n\n\nCode\n# Libraries\n# ============================================\nfrom sqlalchemy import create_engine, text\nimport pandas as pd\nimport plotly.express as px\nimport requests\nimport os\n\n# Data Extraction\n# ============================================\nserver = \"DESKTOP-FUOV4IE\\\\MSSQLSERVER_TAB2\"\ndatabase = \"master\"\n\nconnection_string = (\n    f\"mssql+pyodbc://@{server}/{database}\"\n    \"?driver=ODBC+Driver+17+for+SQL+Server\"\n    \"&trusted_connection=yes\"\n)\n\nengine = create_engine(connection_string)\n\nwith engine.connect() as conn:\n    # Query h_currencies\n    result = conn.execute(text(\"SELECT right(symbol, 3) as symbol, date, rate FROM h_currencies_exh WHERE date &gt; '2001-01-01'\"))\n    df = pd.DataFrame(result.fetchall(), columns=result.keys())\n\n    # Query d_countries\n    url = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/refs/heads/master/Data/DIM_Country.json\"\n    data = pd.read_json(url)\n    df_countries = pd.DataFrame(data).T.reset_index().rename(columns={\"index\": \"cod_iso3\", \"ISO2\": \"cod_iso2\", \"Cod_Currency\": \"cod_currency\", \"Country_Abr\": \"country\"})\n    df_countries['currency'] = df_countries['Currency'] + \" (\" + df_countries['Symbol'] + \")\"\n    df_countries = df_countries[['cod_currency', 'currency', 'cod_iso3', 'country']]\n    df_countries = df_countries[df_countries['cod_iso3'] != 'ATA']\n\n    # Adjust SQS (Somaliland)\n    sos_lines = [\n        {\"cod_currency\": \"SQS\", \"currency\": \"Somaliland Shilling (S)\", \"cod_iso3\": 'SOL', \"country\": \"Somaliland\"},\n    ]\n    df_countries = pd.concat([df_countries, pd.DataFrame(sos_lines)], ignore_index=True)\n\n# Data Manipulation\n# ============================================\n# Format date\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust VES (Venezuela)\ndf['rate'] = df.apply(lambda row: row['rate'] / 100000 if row['symbol'] == 'VEF' else row['rate'], axis=1)\ndf['symbol'] = df['symbol'].apply(lambda x: 'VES' if x == 'VEF' else x)\n\n# Adjust ZMW (Zambia)\ndf['rate'] = df.apply(lambda row: row['rate'] / 1000 if row['symbol'] == 'ZMK' else row['rate'], axis=1)\ndf['symbol'] = df['symbol'].apply(lambda x: 'ZMW' if x == 'ZMK' else x)\n\n# Adjust USD (United States and others)\nusa_lines = [\n    {\"symbol\": \"USD\", \"date\": \"2001-01-01\", \"rate\": 1},\n    {\"symbol\": \"USD\", \"date\": \"2001-05-28\", \"rate\": 1},\n]\ndf = pd.concat([df, pd.DataFrame(usa_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust SSP (South Sudan)\nssp_lines = [\n    {\"symbol\": \"SSP\", \"date\": \"2008-01-01\", \"rate\": 3.21},\n    {\"symbol\": \"SSP\", \"date\": \"2025-05-28\", \"rate\": 130},\n]\ndf = pd.concat([df, pd.DataFrame(ssp_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust SQS (Somaliland)\nssp_lines = [\n    {\"symbol\": \"SQS\", \"date\": \"2001-01-01\", \"rate\": 2967},\n    {\"symbol\": \"SQS\", \"date\": \"2024-01-01\", \"rate\": 9703},\n]\ndf = pd.concat([df, pd.DataFrame(ssp_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust ZWL (Zimbawe)\nzwl_lines = [\n    {\"symbol\": \"ZWL\", \"date\": \"2001-01-01\", \"rate\": 1 / (10 ** 25)}\n]\ndf = pd.concat([df, pd.DataFrame(zwl_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust CUP (Cuba)\nzwl_lines = [\n    {\"symbol\": \"CUP\", \"date\": \"2001-01-01\", \"rate\": 1}\n]\ndf = pd.concat([df, pd.DataFrame(zwl_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust MRU (Mauritania)\nmru_lines = [\n    {\"symbol\": \"MRU\", \"date\": \"2001-01-01\", \"rate\": 23.8}\n]\ndf = pd.concat([df, pd.DataFrame(mru_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust AOA (Angola)\nmru_lines = [\n    {\"symbol\": \"AOA\", \"date\": \"2001-01-01\", \"rate\": 18.7}\n]\ndf = pd.concat([df, pd.DataFrame(mru_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Adjust MGA (Madagascar)\nmru_lines = [\n    {\"symbol\": \"MGA\", \"date\": \"2001-01-01\", \"rate\": 1.27}\n]\ndf = pd.concat([df, pd.DataFrame(mru_lines)], ignore_index=True)\ndf['date'] = pd.to_datetime(df['date'])\n\n# Get index of min and max date for each symbol\nmin_idx = df.groupby('symbol')['date'].idxmin()\nmax_idx = df.groupby('symbol')['date'].idxmax()\n\n# Select rows and rename columns\ndf_min = df.loc[min_idx].rename(columns={'date': 'min_date', 'rate': 'min_rate'})\ndf_max = df.loc[max_idx].rename(columns={'date': 'max_date', 'rate': 'max_rate'})\n\n# Merge dataframes minmax\ndf = pd.merge(df_min[['symbol', 'min_date', 'min_rate']],\n                  df_max[['symbol', 'max_date', 'max_rate']],\n                  on='symbol')\n\n# Merge dataframes currencies\ndf = pd.merge(\n    df,\n    df_countries,\n    how='left',\n    left_on='symbol',\n    right_on='cod_currency'\n)\n\n# Filter null currencies\ndf = df[df['cod_iso3'].notna()]\n\n# Calculate variation\ndf['variation'] =  ( ( df['max_rate'] / df['min_rate'] ) -1 )\n\n# Clasification groups\ndf['class'] = pd.cut(df['variation'], \n                     bins=[-float('inf'), -0.5, -0.3, -0.01, 0.01, 0.3, 0.5, 5, 12, 150, float('inf')],\n                     labels=['G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7', 'G8', 'G9', 'G10'])\n\n# Classification groups names\nclass_name_map = {\n    'G1': 'Appreciation &gt; 50%',\n    'G2': 'Appreciation [30-50%]',\n    'G3': 'Appreciation [1-30%]',\n    'G4': 'Equal',\n    'G5': 'Depreciation [1-30%]',\n    'G6': 'Depreciation [30-50%]',\n    'G7': 'Depreciation [50-500%]',\n    'G8': 'Depreciation [500-1000%]',\n    'G9': 'Depreciation [1000-15000%]',\n    'G10': 'Depreciation [&gt;15000%]'\n}\ndf['class_name'] = df['class'].map(class_name_map)\n\n# Sort by class\ndf = df.sort_values(by='class')\n\n# Rate and date column\ndf['before'] = df['min_rate'].map('{:.4f}'.format) + \" (\" + df['min_date'].dt.strftime('%Y-%m-%d') + \")\"\ndf['after'] = df['max_rate'].map('{:.4f}'.format) + \" (\" + df['max_date'].dt.strftime('%Y-%m-%d') + \")\"\n\n# Download to Excel\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, \"FIG_EXAPI_Currency_Map.xlsx\")\ndf.to_excel(filename, index=False)\n\nprint(df)\n\n# Data Manipulation\n# ============================================\n# Map\nurl = 'https://raw.githubusercontent.com/guillemmaya92/Analytics/refs/heads/master/Maps/world-countries-plotly.geojson'\ngeojson = requests.get(url).json()\n\n# Custom Map Color\ncolor_map_name = {\n    'Appreciation &gt; 50%': '#9CF6D2',\n    'Appreciation [30-50%]': '#CDFFE8',\n    'Appreciation [1-30%]': '#EFFFF8',\n    'Equal': '#FFFFFF',\n    'Depreciation [1-30%]': '#F2DCDB',\n    'Depreciation [30-50%]': '#E6B8B7',\n    'Depreciation [50-500%]': '#DA9694',\n    'Depreciation [500-1000%]': '#963634',\n    'Depreciation [1000-15000%]': '#632523',\n    'Depreciation [&gt;15000%]': \"#291312\"\n}\n\n# Figure map choropleth\nfig = px.choropleth(\n    df,\n    geojson=geojson,\n    locations='cod_iso3',\n    featureidkey=\"properties.iso_a3\",\n    color='class_name',\n    hover_name='country',\n    hover_data={\n        'cod_currency': True,\n        'currency': True,\n        'before': True,\n        'after': True,\n        'variation': ':,.2%',\n        'cod_iso3': False,\n        'class_name': False\n    },\n    color_discrete_map=color_map_name,\n    category_orders={'class': ['G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7', 'G8', 'G9', 'G10']},\n    labels={'class_name': 'Classification'}\n)\n\n# Adjust plot\nfig.update_geos(fitbounds=\"locations\", visible=False)\nfig.update_traces(marker_line_width=0.5, marker_line_color=\"#808080\")\nfig.update_layout(\n    annotations=[\n        dict(\n            text=\"&lt;b&gt;The power of a floating exchange rate market&lt;/b&gt;\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.05,\n            showarrow=False,\n            font=dict(size=20)\n        ),\n        dict(\n            text=\"While USD is getting stronger, the world are feeling pain\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.015,\n            showarrow=False,\n            font=dict(size=16)\n        ),\n        dict(\n            text=\"(Variation in exchange rates during the period 2001–2025)\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=0.985,\n            showarrow=False,\n            font=dict(size=13)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; &lt;a href='https://exchangeratesapi.io' target='_blank' style='color:#3c586b;'&gt;exchangerateapi.io&lt;/a&gt;\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=0,\n            showarrow=False,\n            font=dict(size=12),\n            align=\"left\"\n        )\n    ],\n    legend=dict(\n        title=dict(text='&lt;b&gt;Categories&lt;/b&gt;'),\n        font=dict(size=11),\n        x=1.02,\n        y=0.5,\n        yanchor='middle',\n        xanchor='left',\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor=\"#808080\",\n        borderwidth=1\n    )\n)\n\n# Save it...\ndownload_folder = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\nfilename = os.path.join(download_folder, f\"FIG_EXAPI_Currency_Map\")\nfig.write_html(filename + \".html\")\n\n# Show the plot!\nfig.show()"
  }
]